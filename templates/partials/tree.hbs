<!-- Code Analysis Tree -->
<div class="results-section">
    <h2 style="margin-bottom: 0.75rem;">Code Analysis Tree</h2>

    <div id="react-tree-root" class="analysis-tree" style="min-height: 560px;">
        <noscript>
            <div class="valknut-tree-empty">
                <h3>Interactive tree requires JavaScript</h3>
            </div>
        </noscript>
    </div>

    <script id="tree-data" type="application/json">
        {
            "unifiedHierarchy": {{#if unified_hierarchy}}{{{json unified_hierarchy}}}{{else}}[]{{/if}},
            "refactoringCandidatesByFile": {{#if refactoring_candidates_by_file}}{{{json refactoring_candidates_by_file}}}{{else}}[]{{/if}},
            "directoryHealthTree": {{#if directory_health_tree}}{{{json directory_health_tree}}}{{else}}null{{/if}},
            "coveragePacks": {{#if coverage_packs}}{{{json coverage_packs}}}{{else}}[]{{/if}}
        }
    </script>

    <script>
        (function () {
            const container = document.getElementById('react-tree-root');
            const dataElement = document.getElementById('tree-data');

            if (!container || !dataElement) {
                console.error('Valknut: tree container or data payload missing');
                container.innerHTML = '<div class="valknut-tree-empty"><h3>Tree initialization failed: missing container or data</h3></div>';
                return;
            }

            const parsePayload = () => {
                try {
                    const raw = dataElement.textContent || '{}';
                    return JSON.parse(raw);
                } catch (error) {
                    console.error('Valknut: failed to parse tree payload', error);
                    return null;
                }
            };

            const payload = parsePayload();
            if (!payload) {
                console.error('Valknut: invalid payload data');
                container.innerHTML = '<div class="valknut-tree-empty"><h3>Tree initialization failed: invalid data</h3></div>';
                return;
            }

            function aggregateNode(node) {
                if (!node || typeof node !== 'object') {
                    return { totalIssues: 0, entityCount: 0, fileCount: 0, severityCounts: { critical: 0, high: 0, medium: 0, low: 0 }, avgScore: null, scoreSum: 0, scoreWeight: 0 };
                }

                const children = Array.isArray(node.children) ? node.children : [];
                let totalIssues = Number(node.totalIssues ?? node.total_issues ?? node.refactoringNeeded ?? node.refactoring_needed ?? node.issueCount ?? node.issue_count ?? 0) || 0;
                let entityCount = Number(node.entityCount ?? node.entity_count ?? 0) || 0;
                let fileCount = Number(node.fileCount ?? node.file_count ?? 0) || 0;
                const severityCounts = { critical: 0, high: 0, medium: 0, low: 0 };
                const mergeSeverity = (counts) => {
                    if (!counts) return;
                    severityCounts.critical += Number(counts.critical || 0);
                    severityCounts.high += Number(counts.high || 0);
                    severityCounts.medium += Number(counts.medium || 0);
                    severityCounts.low += Number(counts.low || 0);
                };
                mergeSeverity(node.severityCounts || node.severity_counts);

                let scoreSum = 0;
                let scoreWeight = 0;
                const valueOrNull = (val) => {
                    const numeric = Number(val);
                    return Number.isFinite(numeric) ? numeric : null;
                };
                const nodeScore = valueOrNull(node.avgScore ?? node.avg_score ?? node.score);
                if (nodeScore != null) {
                    const weight = node.type === 'entity' ? 1 : node.type === 'file' ? (entityCount > 0 ? entityCount : 1) : 1;
                    scoreSum += nodeScore * weight;
                    scoreWeight += weight;
                }

                children.forEach((child) => {
                    const aggregate = aggregateNode(child);
                    totalIssues += aggregate.totalIssues;
                    entityCount += aggregate.entityCount;
                    fileCount += aggregate.fileCount;
                    mergeSeverity(aggregate.severityCounts);
                    scoreSum += aggregate.scoreSum;
                    scoreWeight += aggregate.scoreWeight;
                });

                if (node.type === 'folder') {
                    node.totalIssues = totalIssues;
                    node.total_issues = totalIssues;
                    node.entityCount = entityCount;
                    node.entity_count = entityCount;
                    node.fileCount = fileCount;
                    node.file_count = fileCount;
                    node.severityCounts = severityCounts;
                    node.severity_counts = severityCounts;
                    node.avgScore = scoreWeight > 0 ? scoreSum / scoreWeight : nodeScore;
                    node.avgScore = valueOrNull(node.avgScore);
                }

                return {
                    totalIssues,
                    entityCount,
                    fileCount,
                    severityCounts,
                    scoreSum,
                    scoreWeight,
                };
            }

            function aggregateHierarchy(nodes) {
                if (!Array.isArray(nodes)) {
                    return;
                }
                nodes.forEach((node) => {
                    aggregateNode(node);
                    if (Array.isArray(node.children)) {
                        aggregateHierarchy(node.children);
                    }
                });
            }

            function mountReactTree() {
                try {
                    const React = window.React;
                    const ReactDOM = window.ReactDOM;
                    const TreeComponent = window.CodeAnalysisTree || window.ReactTreeBundle;

                    if (!React || !ReactDOM || !TreeComponent) {
                        throw new Error('React tree bundle not available');
                    }

                    if (Array.isArray(payload.unifiedHierarchy)) {
                        aggregateHierarchy(payload.unifiedHierarchy);
                    }

                    console.log('Mounting Valknut virtualized tree with data:', payload);
                    const root = ReactDOM.createRoot(container);
                    root.render(React.createElement(TreeComponent, { data: payload }));
                } catch (error) {
                    console.error('Valknut: failed to mount React tree', error);
                    container.innerHTML = '<div class="valknut-tree-empty"><h3>React tree failed to load</h3><p>' + error.message + '</p></div>';
                }
            }

            function ensureBundle() {
                if (window.CodeAnalysisTree || window.ReactTreeBundle) {
                    mountReactTree();
                    return;
                }

                try {
                    // Inline React tree bundle - executed directly (no template literals to avoid syntax issues)
                    {{inline_js "react-tree-bundle.js"}}
                    mountReactTree();
                } catch (error) {
                    console.error('Failed to execute inlined React tree bundle', error);
                    container.innerHTML = '<div class="valknut-tree-empty"><h3>Failed to load React tree bundle</h3><p>Inlined bundle execution failed: ' + error.message + '</p></div>';
                }
            }

            ensureBundle();
        })();
    </script>
</div>
