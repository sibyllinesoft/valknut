<!-- Files -->
<div class="results-section tab-panel" data-tab="files">
    <div class="tab-heading-row" style="display:none;">
        <h2 class="tab-heading">Files</h2>
    </div>
    <div class="tab-body">
        <div id="react-tree-root" class="analysis-tree" style="height: calc(100vh - 128px); min-height: 300px;">
            <noscript>
                <div class="valknut-tree-empty">
                    <h3>Interactive tree requires JavaScript</h3>
                </div>
            </noscript>
        </div>
    </div>

    <script id="tree-data" type="application/json">
        {
            "projectRoot": {{#if project_root}}"{{{project_root}}}"{{else}}""{{/if}},
            "refactoring_candidates": {{#if refactoring_candidates}}{{{json refactoring_candidates}}}{{else}}[]{{/if}},
            "refactoring_candidates_by_file": {{#if refactoring_candidates_by_file}}{{{json refactoring_candidates_by_file}}}{{else}}[]{{/if}},
            "coverage_packs": {{#if coverage_packs}}{{{json coverage_packs}}}{{else}}[]{{/if}},
            "code_dictionary": {{#if code_dictionary}}{{{json code_dictionary}}}{{else}}{}{{/if}},
            "unified_hierarchy": {{#if unified_hierarchy}}{{{json unified_hierarchy}}}{{else}}[]{{/if}},
            "directory_health_tree": {{#if directory_health_tree}}{{{json directory_health_tree}}}{{else}}null{{/if}},
            "documentation": {{#if documentation}}{{{json documentation}}}{{else}}null{{/if}},
            "graph_insights": {{#if graph_insights}}{{{json graph_insights}}}{{else}}{"hasInsights":false}{{/if}},
            "cohesion": {{#if cohesion}}{{{json cohesion}}}{{else}}null{{/if}},
            "clone_pairs": {{#if clone_pairs}}{{{json clone_pairs}}}{{else}}[]{{/if}},
            "clone_analysis": {{#if clone_analysis}}{{{json clone_analysis}}}{{else}}null{{/if}},
            "directory_health": {{#if directory_health}}{{{json directory_health}}}{{else}}{}{{/if}},
            "file_health": {{#if file_health}}{{{json file_health}}}{{else}}{}{{/if}},
            "entity_health": {{#if entity_health}}{{{json entity_health}}}{{else}}{}{{/if}}
        }
    </script>

    <script>
        (function () {
            const container = document.getElementById('react-tree-root');
            const dataElement = document.getElementById('tree-data');

            if (!container || !dataElement) {
                console.error('Valknut: tree container or data payload missing');
                container.innerHTML = '<div class="valknut-tree-empty"><h3>Tree initialization failed: missing container or data</h3></div>';
                return;
            }

            const parsePayload = () => {
                try {
                    const raw = dataElement.textContent || '{}';
                    return JSON.parse(raw);
                } catch (error) {
                    console.error('Valknut: failed to parse tree payload', error);
                    return null;
                }
            };

            const payload = parsePayload();
            if (!payload) {
                console.error('Valknut: invalid payload data');
                container.innerHTML = '<div class="valknut-tree-empty"><h3>Tree initialization failed: invalid data</h3></div>';
                return;
            }

            const normalizePath = (value = '') => {
                if (typeof value !== 'string') return '';
                let normalized = value.replace(/\\/g, '/');
                if (normalized === '.') return '.';
                // drop trailing slash
                if (normalized.endsWith('/')) {
                    normalized = normalized.slice(0, -1);
                }
                return normalized;
            };

            function buildHealthLookup(tree, fileHealth = {}, entityHealth = {}, codeFileHealth = {}, directoryHealth = {}) {
                const map = {};
                let rootPath = '';
                if (tree && tree.directories) {
                    rootPath = normalizePath(tree.root?.path || '');

                    Object.entries(tree.directories).forEach(([key, value]) => {
                        if (!value || typeof value !== 'object') return;
                        const normalizedKey = normalizePath(key || '');
                        const health = typeof value.health_score === 'number' ? value.health_score : null;
                        if (health === null) return;

                        const variants = new Set();
                        variants.add(normalizedKey);
                        if (normalizedKey === '.') variants.add('');

                        if (rootPath && normalizedKey.startsWith(rootPath)) {
                            const relative = normalizedKey.slice(rootPath.length).replace(/^\//, '');
                            if (relative) variants.add(relative);
                            variants.add('./' + relative);
                        }

                        const srcIdx = normalizedKey.indexOf('/src/');
                        if (srcIdx >= 0) {
                            const srcSlice = normalizedKey.slice(srcIdx);
                            variants.add(srcSlice);
                            variants.add('./' + srcSlice.replace(/^\//, ''));
                        }
                        const base = normalizedKey.split('/').filter(Boolean).pop();
                        if (base) variants.add(base);

                        variants.forEach((k) => {
                            if (!map[k]) map[k] = { health_score: health };
                        });
                    });
                }

                // Directory-level health from directory_health HashMap (path -> score)
                Object.entries(directoryHealth || {}).forEach(([path, score]) => {
                    const normalized = normalizePath(path);
                    const healthScore = score > 1 ? score / 100 : score;
                    const variants = new Set();
                    variants.add(normalized);
                    variants.add(normalized.replace(/^\.\//, ''));
                    if (normalized.startsWith('./')) {
                        variants.add(normalized.slice(2));
                    } else {
                        variants.add('./' + normalized);
                    }
                    const base = normalized.split('/').filter(Boolean).pop();
                    if (base) variants.add(base);

                    variants.forEach((k) => {
                        if (!k) return;
                        if (!map[k]) map[k] = {};
                        map[k].health_score = healthScore;
                    });
                });

                // File-level doc health overrides/augments map
                Object.entries(fileHealth || {}).forEach(([path, score]) => {
                    const normalized = normalizePath(path);
                    const variants = [normalized, normalized.replace(/^\.\//, ''), normalized.split('/').pop()];
                    variants.forEach((k) => {
                        if (!k) return;
                        if (!map[k]) map[k] = {};
                        map[k].doc_health = score;
                    });
                });

                // File-level code health (from file_health HashMap)
                Object.entries(codeFileHealth || {}).forEach(([path, score]) => {
                    const normalized = normalizePath(path);
                    // Convert from 0-100 to 0-1 if needed
                    const healthScore = score > 1 ? score / 100 : score;
                    const variants = [normalized, normalized.replace(/^\.\//, ''), normalized.split('/').pop()];
                    variants.forEach((k) => {
                        if (!k) return;
                        if (!map[k]) map[k] = {};
                        map[k].health_score = healthScore;
                    });
                });

                // Entity-level health (functions, classes, etc.)
                Object.entries(entityHealth || {}).forEach(([entityId, score]) => {
                    // entity_id format is typically "file_path:type:name" or similar
                    // Convert from 0-100 to 0-1 if needed
                    const healthScore = score > 1 ? score / 100 : score;
                    // Store by full entity_id
                    if (!map[entityId]) map[entityId] = {};
                    map[entityId].health_score = healthScore;
                    // Also store by just the entity name (last part after colon)
                    const parts = entityId.split(':');
                    if (parts.length >= 2) {
                        const entityName = parts[parts.length - 1];
                        if (entityName && !map[entityName]) {
                            map[entityName] = { health_score: healthScore };
                        }
                    }
                });

                return { map, rootPath };
            }

            function applyHealthToHierarchy(nodes, directoriesMap, parentPath = '', rootPath = '') {
                if (!Array.isArray(nodes)) return;

                nodes.forEach((node) => {
                    if (!node || typeof node !== 'object') return;

                    // Build a path key: prefer provided path, else derive from parent/name
                    const explicitPath = node.path || node.file_path || node.filePath || null;
                    let derivedPath = parentPath ? `${parentPath}/${node.name || ''}` : (node.name || '');
                    let pathKey = normalizePath(explicitPath || derivedPath || '.');

                    const altKey = pathKey.startsWith('./') ? pathKey.slice(2) : `./${pathKey}`;
                    const base = pathKey.split('/').filter(Boolean).pop();
                    const rootPrefixed = rootPath ? normalizePath(`${rootPath}/${pathKey}`) : null;

                    // For entities (functions, classes), also try to match by entity_id
                    const entityId = node.entity_id || node.entityId || null;
                    const nodeName = node.name || '';

                    let healthSource =
                        directoriesMap[pathKey]
                        || directoriesMap[altKey]
                        || (base ? directoriesMap[base] : null)
                        || (rootPrefixed ? directoriesMap[rootPrefixed] : null);

                    // For entities, try entity_id lookup first, then by name
                    if (!healthSource && entityId) {
                        healthSource = directoriesMap[entityId];
                    }
                    if (!healthSource && nodeName && node.type === 'entity') {
                        healthSource = directoriesMap[nodeName];
                    }

                    // Fall back to root only for directories/files, not entities
                    if (!healthSource && node.type !== 'entity') {
                        healthSource = directoriesMap['.'];
                    }

                    if (healthSource && typeof healthSource.health_score === 'number') {
                        node.healthScore = healthSource.health_score; // 0-1 range
                        node.health_score = healthSource.health_score;
                    }
                    if (healthSource && typeof healthSource.doc_health === 'number') {
                        node.docHealth = healthSource.doc_health;
                        node.doc_health = healthSource.doc_health;
                    }

                    if (Array.isArray(node.children) && node.children.length > 0) {
                        applyHealthToHierarchy(node.children, directoriesMap, pathKey, rootPath);
                    }
                });
            }

            function aggregateNode(node) {
                if (!node || typeof node !== 'object') {
                    return { totalIssues: 0, entityCount: 0, fileCount: 0, severityCounts: { critical: 0, high: 0, medium: 0, low: 0 }, avgScore: null, scoreSum: 0, scoreWeight: 0 };
                }

                const children = Array.isArray(node.children) ? node.children : [];
                const directIssues = Array.isArray(node.issues) ? node.issues.length : 0;
                let totalIssues = Number(node.totalIssues ?? node.total_issues ?? node.refactoringNeeded ?? node.refactoring_needed ?? node.issueCount ?? node.issue_count ?? 0) || 0;
                if (totalIssues === 0 && directIssues > 0) {
                    totalIssues = directIssues;
                } else if (directIssues > totalIssues) {
                    totalIssues = directIssues;
                }
                let entityCount = Number(node.entityCount ?? node.entity_count ?? 0) || 0;
                let fileCount = Number(node.fileCount ?? node.file_count ?? 0) || 0;
                const severityCounts = { critical: 0, high: 0, medium: 0, low: 0 };
                const mergeSeverity = (counts) => {
                    if (!counts) return;
                    severityCounts.critical += Number(counts.critical || 0);
                    severityCounts.high += Number(counts.high || 0);
                    severityCounts.medium += Number(counts.medium || 0);
                    severityCounts.low += Number(counts.low || 0);
                };
                mergeSeverity(node.severityCounts || node.severity_counts);

                let scoreSum = 0;
                let scoreWeight = 0;
                const valueOrNull = (val) => {
                    const numeric = Number(val);
                    return Number.isFinite(numeric) ? numeric : null;
                };
                const nodeScore = valueOrNull(node.avgScore ?? node.avg_score ?? node.score);
                if (nodeScore != null) {
                    const weight = node.type === 'entity' ? 1 : node.type === 'file' ? (entityCount > 0 ? entityCount : 1) : 1;
                    scoreSum += nodeScore * weight;
                    scoreWeight += weight;
                }

                children.forEach((child) => {
                    const aggregate = aggregateNode(child);
                    totalIssues += aggregate.totalIssues;
                    entityCount += aggregate.entityCount;
                    fileCount += aggregate.fileCount;
                    mergeSeverity(aggregate.severityCounts);
                    scoreSum += aggregate.scoreSum;
                    scoreWeight += aggregate.scoreWeight;
                });

                if (node.type === 'folder') {
                    node.totalIssues = totalIssues;
                    node.total_issues = totalIssues;
                    node.entityCount = entityCount;
                    node.entity_count = entityCount;
                    node.fileCount = fileCount;
                    node.file_count = fileCount;
                    node.severityCounts = severityCounts;
                    node.severity_counts = severityCounts;
                    node.avgScore = scoreWeight > 0 ? scoreSum / scoreWeight : nodeScore;
                    node.avgScore = valueOrNull(node.avgScore);
                }

                return {
                    totalIssues,
                    entityCount,
                    fileCount,
                    severityCounts,
                    scoreSum,
                    scoreWeight,
                };
            }

            function collectEntityDetails(nodes) {
                if (!Array.isArray(nodes)) {
                    return;
                }

                const ISSUE_TYPES = new Set(['issue', 'issue-row']);
                const SUGGESTION_TYPES = new Set(['suggestion', 'suggestion-row']);
                const CATEGORY_TYPES = new Set(['category']);
                const INFO_TYPES = new Set(['info', 'info-row']);

                const cloneNode = (detail) => {
                    if (!detail || typeof detail !== 'object') {
                        return null;
                    }
                    const { children, ...rest } = detail;
                    return { ...rest };
                };

                const appendIssue = (entity, issue) => {
                    const payload = cloneNode(issue);
                    if (!payload) return;
                    entity.issues = Array.isArray(entity.issues) ? entity.issues : [];
                    entity.issues.push(payload);
                };

                const appendSuggestion = (entity, suggestion) => {
                    const payload = cloneNode(suggestion);
                    if (!payload) return;
                    entity.suggestions = Array.isArray(entity.suggestions) ? entity.suggestions : [];
                    entity.suggestions.push(payload);
                };

                const appendInfo = (entity, info) => {
                    if (!info || typeof info !== 'object') {
                        return;
                    }
                    const label = String(info.name || info.title || '').toLowerCase();
                    const numeric = Number(String(info.name || '').replace(/[^0-9.]/g, ''));
                    entity.coverage = entity.coverage || { coverageBefore: null, coverageAfter: null, linesOfCode: null };
                    if (label.includes('coverage before') && Number.isFinite(numeric)) {
                        entity.coverage.coverageBefore = numeric > 1 ? numeric / 100 : numeric;
                    } else if (label.includes('coverage after') && Number.isFinite(numeric)) {
                        entity.coverage.coverageAfter = numeric > 1 ? numeric / 100 : numeric;
                    } else if (label.includes('lines of code') && Number.isFinite(numeric)) {
                        entity.coverage.linesOfCode = Math.round(numeric);
                    }
                };

                nodes.forEach((node) => {
                    if (!node || typeof node !== 'object' || !Array.isArray(node.children)) {
                        return;
                    }

                    collectEntityDetails(node.children);

                    if (String(node.type || '').toLowerCase() !== 'entity') {
                        return;
                    }

                    const filteredChildren = [];

                    node.children.forEach((child) => {
                        const type = String(child?.type || '').toLowerCase();
                        if (CATEGORY_TYPES.has(type) && Array.isArray(child.children)) {
                            child.children.forEach((grandchild) => {
                                const grandType = String(grandchild?.type || '').toLowerCase();
                                if (ISSUE_TYPES.has(grandType)) {
                                    appendIssue(node, grandchild);
                                } else if (SUGGESTION_TYPES.has(grandType)) {
                                    appendSuggestion(node, grandchild);
                                } else if (INFO_TYPES.has(grandType)) {
                                    appendInfo(node, grandchild);
                                }
                            });
                            return;
                        }

                        if (ISSUE_TYPES.has(type)) {
                            appendIssue(node, child);
                            return;
                        }

                        if (SUGGESTION_TYPES.has(type)) {
                            appendSuggestion(node, child);
                            return;
                        }

                        if (INFO_TYPES.has(type)) {
                            appendInfo(node, child);
                            return;
                        }

                        filteredChildren.push(child);
                    });

                    node.children = filteredChildren;
                });

            }

            function aggregateHierarchy(nodes) {
                if (!Array.isArray(nodes)) {
                    return;
                }
                nodes.forEach((node) => {
                    aggregateNode(node);
                    if (Array.isArray(node.children)) {
                        aggregateHierarchy(node.children);
                    }
                    // push aggregates upward: if a folder/file has children, sum their counts
                    if (node.type === 'file' && Array.isArray(node.children)) {
                        const childIssues = node.children.reduce((sum, c) => sum + (c.totalIssues || c.total_issues || (Array.isArray(c.issues) ? c.issues.length : 0) || 0), 0);
                        if ((node.totalIssues || node.total_issues || 0) < childIssues) {
                            node.totalIssues = childIssues;
                            node.total_issues = childIssues;
                        }
                        const childEntities = node.children.reduce((sum, c) => sum + (c.entityCount || c.entity_count || (c.type === 'entity' ? 1 : 0)), 0);
                        if ((node.entityCount || node.entity_count || 0) < childEntities) {
                            node.entityCount = childEntities;
                            node.entity_count = childEntities;
                        }
                    }
                    if (node.type === 'folder' && Array.isArray(node.children)) {
                        const childIssues = node.children.reduce((sum, c) => sum + (c.totalIssues || c.total_issues || (Array.isArray(c.issues) ? c.issues.length : 0) || 0), 0);
                        if ((node.totalIssues || node.total_issues || 0) < childIssues) {
                            node.totalIssues = childIssues;
                            node.total_issues = childIssues;
                        }
                        const childEntities = node.children.reduce((sum, c) => sum + (c.entityCount || c.entity_count || (c.type === 'entity' ? 1 : 0)), 0);
                        if ((node.entityCount || node.entity_count || 0) < childEntities) {
                            node.entityCount = childEntities;
                            node.entity_count = childEntities;
                        }
                        const childFiles = node.children.reduce((sum, c) => sum + (c.fileCount || c.file_count || (c.type === 'file' ? 1 : 0)), 0);
                        if ((node.fileCount || node.file_count || 0) < childFiles) {
                            node.fileCount = childFiles;
                            node.file_count = childFiles;
                        }
                    }
                });
            }

            function buildCohesionLookup(cohesionData) {
                const map = {};
                if (!cohesionData || !cohesionData.enabled) return map;

                // Detect project root from paths for stripping absolute prefixes
                const projectRoot = normalizePath(payload.projectRoot || '');

                const addVariants = (path, score, type) => {
                    const normalized = normalizePath(path);
                    const variants = new Set();

                    // Add absolute path
                    variants.add(normalized);

                    // Add relative path by stripping project root
                    if (projectRoot && normalized.startsWith(projectRoot + '/')) {
                        const relative = normalized.slice(projectRoot.length + 1);
                        variants.add(relative);
                        variants.add('./' + relative);
                    }

                    // Try common prefixes (src/, templates/, etc.)
                    const commonPrefixes = ['src/', 'templates/', 'tests/', 'benchmarks/', 'datasets/', 'docs/', 'examples/', 'vscode-extension/'];
                    for (const prefix of commonPrefixes) {
                        const idx = normalized.indexOf('/' + prefix);
                        if (idx >= 0) {
                            const relative = normalized.slice(idx + 1);
                            variants.add(relative);
                            variants.add('./' + relative);
                        }
                    }

                    // Add without leading ./
                    variants.add(normalized.replace(/^\.\//, ''));

                    // Add just the last component (folder/file name)
                    const lastComponent = normalized.split('/').pop();
                    if (lastComponent) variants.add(lastComponent);

                    variants.forEach(k => {
                        if (!k) return;
                        // For files, always set; for folders, don't override files
                        if (type === 'file') {
                            if (!map[k]) {
                                map[k] = { cohesion: score.cohesion, outliers: score.outliers || [], type: 'file' };
                            }
                        } else {
                            if (!map[k] || map[k].type !== 'file') {
                                map[k] = { cohesion: score.cohesion, outliers: score.outliers || [], type: 'folder' };
                            }
                        }
                    });
                };

                // Build lookup from file_scores
                if (cohesionData.file_scores) {
                    Object.entries(cohesionData.file_scores).forEach(([path, score]) => {
                        addVariants(path, score, 'file');
                    });
                }

                // Build lookup from folder_scores
                if (cohesionData.folder_scores) {
                    Object.entries(cohesionData.folder_scores).forEach(([path, score]) => {
                        addVariants(path, score, 'folder');
                    });
                }

                return map;
            }

            function applyCohesionToHierarchy(nodes, cohesionMap, parentPath = '') {
                if (!Array.isArray(nodes)) return;

                nodes.forEach((node) => {
                    if (!node || typeof node !== 'object') return;

                    const explicitPath = node.path || node.file_path || node.filePath || null;
                    let derivedPath = parentPath ? `${parentPath}/${node.name || ''}` : (node.name || '');
                    let pathKey = normalizePath(explicitPath || derivedPath || '.');

                    const altKey = pathKey.startsWith('./') ? pathKey.slice(2) : `./${pathKey}`;
                    const base = pathKey.split('/').filter(Boolean).pop();

                    const cohesionSource =
                        cohesionMap[pathKey]
                        || cohesionMap[altKey]
                        || (base ? cohesionMap[base] : null);

                    if (cohesionSource && typeof cohesionSource.cohesion === 'number') {
                        node.cohesion = cohesionSource.cohesion;
                        if (Array.isArray(cohesionSource.outliers) && cohesionSource.outliers.length > 0) {
                            node.cohesionOutliers = cohesionSource.outliers;
                        }
                    }

                    if (Array.isArray(node.children) && node.children.length > 0) {
                        applyCohesionToHierarchy(node.children, cohesionMap, pathKey);
                    }
                });
            }

            function mountReactTree() {
                try {
                    const React = window.React;
                    const ReactDOM = window.ReactDOM;
                    const TreeComponent = window.CodeAnalysisTree || window.ReactTreeBundle;

                    if (!React || !ReactDOM || !TreeComponent) {
                        throw new Error('React tree bundle not available');
                    }

                    if (Array.isArray(payload.unified_hierarchy) && payload.unified_hierarchy.length > 0) {
                        collectEntityDetails(payload.unified_hierarchy);
                        // Build health lookup from all sources: directory tree, doc health, entity health, file health, directory health
                        const { map: healthMap, rootPath } = buildHealthLookup(
                            payload.directory_health_tree || null,
                            (payload.documentation && payload.documentation.file_doc_health) || {},
                            payload.entity_health || {},
                            payload.file_health || {},
                            payload.directory_health || {}
                        );
                        applyHealthToHierarchy(payload.unified_hierarchy, healthMap, '', rootPath);

                        // Apply cohesion scores to hierarchy
                        if (payload.cohesion && payload.cohesion.enabled) {
                            const cohesionMap = buildCohesionLookup(payload.cohesion);
                            applyCohesionToHierarchy(payload.unified_hierarchy, cohesionMap, '');
                        }

                        aggregateHierarchy(payload.unified_hierarchy);
                    }

                    const root = ReactDOM.createRoot(container);
                    root.render(React.createElement(TreeComponent, { data: payload }));
                } catch (error) {
                    console.error('Valknut: failed to mount React tree', error);
                    container.innerHTML = '<div class="valknut-tree-empty"><h3>React tree failed to load</h3><p>' + error.message + '</p></div>';
                }
            }

            function ensureBundle() {
                if (window.CodeAnalysisTree || window.ReactTreeBundle) {
                    mountReactTree();
                    return;
                }

                try {
                    // Inline React tree bundle - executed directly (no template literals to avoid syntax issues)
                    {{inline_js "react-tree-bundle.js"}}
                    mountReactTree();
                } catch (error) {
                    console.error('Failed to execute inlined React tree bundle', error);
                    container.innerHTML = '<div class="valknut-tree-empty"><h3>Failed to load React tree bundle</h3><p>Inlined bundle execution failed: ' + error.message + '</p></div>';
                }
            }

            ensureBundle();
        })();
    </script>
</div>
