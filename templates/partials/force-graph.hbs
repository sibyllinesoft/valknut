<section class="results-section tab-panel" data-tab="dependencies">
    <div class="tab-heading-row" style="display:none;">
        <h2 class="tab-heading">Dependencies</h2>
        <p class="tab-subtitle">Force-directed module graph with cycles, fan-in/out, and chokepoints.</p>
    </div>
    <div class="tab-body">
        <div class="metric-cards">
            <div class="metric-card">
                <div class="metric-label">Docs Health</div>
                <div class="metric-value">
                    {{#if documentation.doc_health_score}}
                        {{percentage documentation.doc_health_score "0"}}%
                    {{else}}
                        N/A
                    {{/if}}
                </div>
                <div class="metric-subtext">Aggregate documentation score</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Modules in Graph</div>
                <div class="metric-value" id="force-graph-node-count">–</div>
                <div class="metric-subtext">Pruned & normalized</div>
            </div>
            <div class="metric-card">
                <div class="metric-label">Edges</div>
                <div class="metric-value" id="force-graph-edge-count">–</div>
                <div class="metric-subtext">Weighted dependencies</div>
            </div>
        </div>

        <div id="force-graph-container" style="width:100%;min-height:520px;"></div>
        <div id="force-graph-empty" class="insights-empty" style="display:none;">
            Force-directed graph data was not produced for this run.
        </div>
    </div>

    <script>
    (function() {
        let plotInitialized = false;

        function ensurePlotly() {
            if (window.Plotly) return Promise.resolve();
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = 'https://cdn.plot.ly/plotly-2.32.0.min.js';
                script.onload = () => resolve();
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        function getPayload() {
            const dataEl = document.getElementById('tree-data');
            if (!dataEl) return {};
            try { return JSON.parse(dataEl.textContent || '{}'); }
            catch { return {}; }
        }

        function fallbackLayout(nodes) {
            const n = Math.max(nodes.length, 1);
            const tau = Math.PI * 2;
            return nodes.map((_, i) => {
                const angle = (i / n) * tau;
                return { x: Math.cos(angle), y: Math.sin(angle) };
            });
        }

        function renderForceGraph() {
            if (plotInitialized) return;
            plotInitialized = true;

            const payload = getPayload();
            const graph = (payload.passes && payload.passes.impact && payload.passes.impact.module_force_graph)
                || payload.module_force_graph
                || null;

            if (!graph || !Array.isArray(graph.nodes) || graph.nodes.length === 0) {
                document.getElementById('force-graph-empty').style.display = 'block';
                return;
            }

            const nodes = graph.nodes;
            const links = Array.isArray(graph.links) ? graph.links : [];

            const coords = nodes.map((n, idx) => {
                const x = typeof n.x === 'number' ? n.x : null;
                const y = typeof n.y === 'number' ? n.y : null;
                return x != null && y != null ? { x, y } : null;
            });

            if (coords.some(c => c === null)) {
                const fallback = fallbackLayout(nodes);
                fallback.forEach((p, i) => { coords[i] = p; });
            }

            const nodeIndex = {};
            nodes.forEach((n, i) => { nodeIndex[n.id] = i; });

            const edgeTraces = [];
            if (links.length) {
                const xCoords = [];
                const yCoords = [];
                links.forEach(link => {
                    const s = nodeIndex[link.source];
                    const t = nodeIndex[link.target];
                    if (s == null || t == null) return;
                    xCoords.push(coords[s].x, coords[t].x, null);
                    yCoords.push(coords[s].y, coords[t].y, null);
                });
                edgeTraces.push({
                    type: 'scatter',
                    mode: 'lines',
                    x: xCoords,
                    y: yCoords,
                    hoverinfo: 'skip',
                    line: { width: 1.5, color: 'rgba(148, 163, 184, 0.6)' }
                });
            }

            const nodeTrace = {
                type: 'scatter',
                mode: 'markers+text',
                x: coords.map(c => c.x),
                y: coords.map(c => c.y),
                text: nodes.map(n => n.label || n.id),
                textposition: 'top center',
                marker: {
                    size: nodes.map(n => 10 + ((n.size || 1) * 4)),
                    color: nodes.map(n => n.in_cycle ? '#ef4444' : '#2563eb'),
                    line: { width: 1, color: '#e2e8f0' },
                    opacity: 0.9
                },
                hovertemplate: nodes.map(n =>
                    `<b>${n.label || n.id}</b><br>` +
                    `${n.path || ''}<br>` +
                    `Functions: ${n.functions || 0}<br>` +
                    `Fan-in / Fan-out: ${n.fan_in || 0} / ${n.fan_out || 0}<br>` +
                    `Chokepoint: ${(n.chokepoint_score || 0).toFixed(1)}<br>` +
                    `Cycle: ${n.in_cycle ? 'yes' : 'no'}<extra></extra>`
                )
            };

            const layout = {
                margin: { l: 10, r: 10, t: 10, b: 10 },
                xaxis: { visible: false },
                yaxis: { visible: false },
                showlegend: false,
                hovermode: 'closest'
            };

            const nodeCountEl = document.getElementById('force-graph-node-count');
            const edgeCountEl = document.getElementById('force-graph-edge-count');
            if (nodeCountEl) nodeCountEl.textContent = nodes.length;
            if (edgeCountEl) edgeCountEl.textContent = links.length;

            Plotly.newPlot('force-graph-container', [...edgeTraces, nodeTrace], layout, { displayModeBar: false, responsive: true });
        }

        window.addEventListener('valknut-tab-activated', (ev) => {
            if (ev.detail && ev.detail.id === 'dependencies') {
                ensurePlotly().then(renderForceGraph).catch(() => {
                    document.getElementById('force-graph-empty').style.display = 'block';
                });
            }
        });
    })();
    </script>
</section>
