    <!-- Raw Data for Debugging -->
    <div class="raw-data">
        <details>
            <summary>Raw Analysis Data (Debug)</summary>
            <pre>{{#if results}}{{json results}}{{else}}No debug data available{{/if}}</pre>
        </details>
    </div>
</div>

<script>
    // Filter dropdown functionality (optional - only works if filter elements exist)
    function toggleFilterMenu() {
        const menu = document.getElementById('filter-menu');
        const button = document.getElementById('filter-button');
        
        // Only proceed if filter elements exist
        if (!menu || !button) {
            console.warn('Filter menu elements not found - filter functionality unavailable');
            return;
        }
        
        const chevron = button.querySelector('[data-lucide="chevron-down"]');
        
        if (menu.style.display === 'none') {
            menu.style.display = 'block';
            if (chevron) {
                chevron.setAttribute('data-expanded', 'true');
            }
        } else {
            menu.style.display = 'none';
            if (chevron) {
                chevron.setAttribute('data-expanded', 'false');
            }
        }
    }
    
    // Close filter menu when clicking outside (only if filter elements exist)
    document.addEventListener('click', function(event) {
        const dropdown = document.querySelector('.filter-dropdown');
        const menu = document.getElementById('filter-menu');
        
        // Only proceed if filter elements actually exist
        if (dropdown && menu && !dropdown.contains(event.target)) {
            menu.style.display = 'none';
            const chevron = document.querySelector('#filter-button [data-lucide="chevron-down"]');
            if (chevron) {
                chevron.setAttribute('data-expanded', 'false');
            }
        }
    });
    
    // Apply filters based on checkboxes (optional - only works if filter elements exist)
    function applyFilters() {
        // FIXME: Temporarily disable all filtering - show everything
        return true;
        
        // Check if filter elements exist before proceeding
        const filterElements = [
            'filter-high-complexity',
            'filter-extract-method', 
            'filter-simplify-conditionals',
            'filter-improve-structure',
            'filter-general-refactoring'
        ];
        
        const hasAllFilters = filterElements.every(id => document.getElementById(id) !== null);
        if (!hasAllFilters) {
            console.warn('Filter checkboxes not found - filter functionality unavailable');
            return true; // Show everything if filters don't exist
        }
        
        const highComplexityOnly = document.getElementById('filter-high-complexity').checked;
        const extractMethod = document.getElementById('filter-extract-method').checked;
        const simplifyConditionals = document.getElementById('filter-simplify-conditionals').checked;
        const improveStructure = document.getElementById('filter-improve-structure').checked;
        const generalRefactoring = document.getElementById('filter-general-refactoring').checked;
        
        const fileNodes = document.querySelectorAll('.file-node');
        
        fileNodes.forEach(fileNode => {
            let shouldShow = false;
            
            // Check if file meets complexity filter
            const priority = fileNode.getAttribute('data-priority');
            const meetsComplexityFilter = !highComplexityOnly || priority === 'Critical' || priority === 'High';
            
            if (meetsComplexityFilter) {
                // Check if file has any refactoring suggestions that match the selected types
                const suggestions = fileNode.querySelectorAll('.suggestion-item');
                if (suggestions.length === 0) {
                    // If no specific suggestions found, show the file (it might have general refactoring needs)
                    shouldShow = true;
                } else {
                    // Check each suggestion to see if it matches selected refactoring types
                    suggestions.forEach(suggestion => {
                        const suggestionText = suggestion.textContent.toLowerCase();
                        if ((extractMethod && suggestionText.includes('extract')) ||
                            (simplifyConditionals && suggestionText.includes('conditional')) ||
                            (improveStructure && suggestionText.includes('structure')) ||
                            (generalRefactoring && !suggestionText.includes('extract') && 
                             !suggestionText.includes('conditional') && !suggestionText.includes('structure'))) {
                            shouldShow = true;
                        }
                    });
                }
            }
            
            // Apply filter
            if (shouldShow) {
                fileNode.classList.remove('filtered-out');
            } else {
                fileNode.classList.add('filtered-out');
            }
        });
        
        // Log filtering results
        const visibleFiles = document.querySelectorAll('.file-node:not(.filtered-out)').length;
        const totalFiles = fileNodes.length;
        console.log(`Filter: Showing ${visibleFiles} of ${totalFiles} files`);
    }
    
    // Initialize components when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        {{#if enable_animation}}
        // Initialize trefoil animation if enabled
        if (typeof window.initTrefoilAnimation === 'function') {
            const canvas = document.getElementById('neural-network');
            if (canvas) {
                window.initTrefoilAnimation(canvas);
            }
        }
        {{/if}}
        
        console.log(`Target: Valknut Analysis Report Loaded`);
        console.log(`Chart: Found ${document.querySelectorAll('.tree-node').length} refactoring candidates`);
        console.log(`Palette: Using Sibylline Design System Theme`);
        
        // Initialize Lucide icons
        lucide.createIcons();
    });
    
    // Smooth scrolling for tree navigation
    function scrollToNode(nodeId) {
        const element = document.getElementById(nodeId);
        if (element) {
            element.scrollIntoView({ 
                behavior: 'smooth', 
                block: 'center' 
            });
        }
    }
    
    // Initialize Lucide icons when DOM is loaded
    document.addEventListener('DOMContentLoaded', function() {
        lucide.createIcons();
    });

    // Oracle phase toggle functionality
    function togglePhase(element) {
        const phaseCard = element.closest('.phase-card');
        const phaseContent = phaseCard.querySelector('.phase-content');
        const chevron = element.querySelector('[data-lucide="chevron-right"]');
        
        if (phaseContent.style.display === 'none') {
            phaseContent.style.display = 'block';
            chevron.setAttribute('data-expanded', 'true');
        } else {
            phaseContent.style.display = 'none';
            chevron.setAttribute('data-expanded', 'false');
        }
    }

    // Helper function to capitalize strings (for Handlebars templates that might need it)
    function capitalize(str) {
        if (!str) return '';
        return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
    }
</script>
</body>
</html>