<!-- Dashboard -->
<div class="results-section tab-panel" data-tab="treemap">
    <div class="tab-heading-row" style="display:none;">
        <h2 class="tab-heading">Dashboard</h2>
    </div>
    <div class="tab-body">
        <div style="display:flex; align-items:center; gap:12px; margin-bottom:0.5rem;">
            <label for="treemap-color-metric" style="font-size:0.9rem;color:var(--text-secondary);">Color by:</label>
            <select id="treemap-color-metric" style="background: var(--panel,rgba(255,255,255,0.06)); color: var(--text); border:1px solid rgba(255,255,255,0.08); border-radius:6px; padding:6px 10px; font-size:0.9rem;">
                <option value="complexity" selected>Complexity</option>
                <option value="cognitive">Cognitive</option>
                <option value="debt">Debt</option>
                <option value="maintainability">Maintainability</option>
                <option value="structure">Structure</option>
                <option value="docs">Docs</option>
                <option value="coverage">Coverage</option>
            </select>
        </div>
        <div id="treemap-root" style="width: 100%; height: calc(100vh - 128px); min-height: 300px;"></div>
        <div id="treemap-tooltip" class="valknut-tooltip" style="display:none; position:fixed; pointer-events:none; z-index:9999;"></div>
        <script id="treemap-data" type="application/json">
            {
                "candidates": {{#if refactoring_candidates}}{{{json refactoring_candidates}}}{{else}}[]{{/if}},
                "clone_pairs": {{#if clone_pairs}}{{{json clone_pairs}}}{{else}}[]{{/if}},
                "documentation": {{#if documentation}}{{{json documentation}}}{{else}}null{{/if}},
                "coverage_packs": {{#if coverage_packs}}{{{json coverage_packs}}}{{else}}[]{{/if}},
                "code_dictionary": {{#if code_dictionary}}{{{json code_dictionary}}}{{else}}{"issues":{},"suggestions":{}}{{/if}}
            }
        </script>
        <script>
            (function() {
                const dataEl = document.getElementById('treemap-data');
                const colorSelect = document.getElementById('treemap-color-metric');
                const rootEl = document.getElementById('treemap-root');
                if (!dataEl || !rootEl) return;

                const rawText = dataEl.textContent || '{}';
                const payload = JSON.parse(rawText);

                const candidates = Array.isArray(payload.candidates) ? payload.candidates : [];
                const clonePairs = Array.isArray(payload.clone_pairs) ? payload.clone_pairs : [];
                const docHealthMap = payload.documentation?.file_doc_health || {};
                const coveragePacks = Array.isArray(payload.coverage_packs) ? payload.coverage_packs : [];
                const codeDictionary = payload.code_dictionary || { issues: {}, suggestions: {} };

                // Build file-level coverage map from coverage_packs
                const fileCoverageMap = {};
                coveragePacks.forEach((pack) => {
                    const path = String(pack.path || '').replace(/\\/g, '/');
                    const coverageBefore = pack.file_info?.coverage_before;
                    if (path && typeof coverageBefore === 'number') {
                        // Coverage is 0-1 range, convert to percentage
                        const coveragePct = coverageBefore <= 1 ? coverageBefore * 100 : coverageBefore;
                        // Store with multiple path variants for matching
                        fileCoverageMap[path] = coveragePct;
                        // Without leading ./
                        if (path.startsWith('./')) {
                            fileCoverageMap[path.slice(2)] = coveragePct;
                        } else {
                            fileCoverageMap['./' + path] = coveragePct;
                        }
                        // Also store just filename for fallback
                        const filename = path.split('/').pop();
                        if (filename && !fileCoverageMap[filename]) {
                            fileCoverageMap[filename] = coveragePct;
                        }
                    }
                });

                const metricDescriptions = {
                    complexity: 'Complexity: combined cyclomatic & cognitive complexity severities; higher = more branching/logic to simplify.',
                    cognitive: 'Cognitive: focuses on how hard the code is to mentally follow (nesting, deep conditionals, tricky flow).',
                    debt: 'Debt: technical debt severity derived from debt score and contributing factors; higher = more costly to fix later.',
                    maintainability: 'Maintainability: severity inverted from maintainability index; higher = harder to sustain over time.',
                    structure: 'Structure: severity for structural issues (coupling, cohesion, file/module organization).',
                    docs: 'Docs: severity derived from documentation health (lower health = higher severity).',
                    coverage: 'Coverage: severity derived from test coverage (lower coverage = higher severity / more red).'
                };

                function getLinesOfCode(entity) {
                    let loc = entity.lines_of_code || entity.linesOfCode || null;
                    if (loc) return loc;
                    const issues = Array.isArray(entity.issues) ? entity.issues : [];
                    for (const issue of issues) {
                        const feats = Array.isArray(issue.contributing_features) ? issue.contributing_features : [];
                        for (const f of feats) {
                            if (String(f.feature_name || '').toLowerCase() === 'lines_of_code') {
                                return Number(f.value) || Number(f.contribution) || 1;
                            }
                        }
                    }
                    return 1;
                }

                function severityForCategory(entity, category) {
                    const issues = Array.isArray(entity.issues) ? entity.issues : [];
                    if (category === 'docs') {
                        const raw = String(entity.file_path || entity.filePath || '').replace(/\\\\/g, '/');
                        const variants = [
                            raw,
                            raw.replace(/^[.][/]/, ''),
                            raw.replace(/^.*?src[/]/, 'src/'),
                            raw.split('/').slice(-2).join('/'),
                            raw.split('/').pop() || raw,
                        ];
                        for (const v of variants) {
                            const docScore = Number(docHealthMap[v]);
                            if (Number.isFinite(docScore)) {
                                return Math.max(0, 100 - docScore);
                            }
                        }
                        return 100; // treat missing doc data as worst severity
                    }
                    if (category === 'coverage') {
                        // First, check if entity has coverage_percentage directly
                        const entityCov = entity.coverage_percentage;
                        if (typeof entityCov === 'number' && Number.isFinite(entityCov)) {
                            // Invert: 0% coverage = 100 severity, 100% coverage = 0 severity
                            return Math.max(0, 100 - entityCov);
                        }

                        // Fall back to file-level coverage map
                        const raw = String(entity.file_path || entity.filePath || '').replace(/\\/g, '/');
                        const variants = [
                            raw,
                            raw.replace(/^[.][/]/, ''),
                            raw.replace(/^.*?src[/]/, 'src/'),
                            raw.split('/').slice(-2).join('/'),
                            raw.split('/').pop() || raw,
                        ];
                        for (const v of variants) {
                            const coveragePct = fileCoverageMap[v];
                            if (typeof coveragePct === 'number' && Number.isFinite(coveragePct)) {
                                // Invert: 0% coverage = 100 severity, 100% coverage = 0 severity
                                return Math.max(0, 100 - coveragePct);
                            }
                        }
                        // No coverage data - assume neutral (50% severity)
                        return 50;
                    }
                    for (const issue of issues) {
                        const cat = String(issue.category || '').toLowerCase();
                        if (cat === category) {
                            return Number(issue.severity) || 0;
                        }
                    }
                    return Number(entity.score) || 0;
                }

                function normalizeId(id) {
                    return String(id || '').trim().toLowerCase();
                }

                function buildCloneMap(nodeIndexById) {
                    const map = new Map();
                    const addLink = (a, b) => {
                        const na = normalizeId(a);
                        const nb = normalizeId(b);
                        const ia = nodeIndexById.get(na);
                        const ib = nodeIndexById.get(nb);
                        if (ia == null || ib == null) return;
                        if (!map.has(na)) map.set(na, new Set());
                        if (!map.has(nb)) map.set(nb, new Set());
                        map.get(na).add(ia); map.get(na).add(ib);
                        map.get(nb).add(ib); map.get(nb).add(ia);
                    };
                    clonePairs.forEach((pair) => {
                        const sId = pair?.source?.id || pair?.source?.entity_id || pair?.source?.name;
                        const tId = pair?.target?.id || pair?.target?.entity_id || pair?.target?.name;
                        if (sId && tId) addLink(sId, tId);
                    });
                    return map;
                }

                function buildTreemap(colorMetric, maxScale) {
                    const nodes = new Map();
                    const custom = [];

                    const ensureNode = (id, label, parent = '', entity = null) => {
                        if (!nodes.has(id)) {
                            nodes.set(id, { id, label, parent, children: [], value: 0, color: 0, entity, entities: [] });
                            if (parent && nodes.has(parent)) {
                                nodes.get(parent).children.push(id);
                            }
                        }
                        return nodes.get(id);
                    };

                    // Root
                    ensureNode('Project', 'Project', '');

                    const severityCache = new Map();

                    const getSeverity = (entity, metric) => {
                        const key = (entity.entity_id || entity.name || '') + '|' + metric;
                        if (severityCache.has(key)) return severityCache.get(key);
                        const val = severityForCategory(entity, metric);
                        severityCache.set(key, val);
                        return val;
                    };

                    candidates.forEach((entity) => {
                        const filePath = String(entity.file_path || entity.filePath || '').replace(/\\/g, '/');
                        const parts = filePath.split('/').filter(Boolean);
                        const fileName = parts.pop() || filePath || 'file';
                        let parentId = 'Project';
                        let pathSoFar = '';
                        parts.forEach((part) => {
                            pathSoFar = pathSoFar ? pathSoFar + '/' + part : part;
                            const dirId = 'dir:' + pathSoFar;
                            ensureNode(dirId, part, parentId);
                            parentId = dirId;
                        });
                        const fileId = 'file:' + filePath;
                        const fileNode = ensureNode(fileId, fileName, parentId);
                        fileNode.entities.push(entity);
                        fileNode.filePath = filePath;

                        const leafId = 'entity:' + (entity.entity_id || entity.name || Math.random());
                        const loc = getLinesOfCode(entity);
                        const colorVal = Math.min(getSeverity(entity, colorMetric), maxScale);
                        const leaf = ensureNode(leafId, entity.name || fileName, fileId, entity);
                        leaf.value = loc;
                        leaf.color = colorVal;
                        leaf.filePath = filePath;
                    });

                    // Aggregate values and colors up the tree
                    const aggregate = (id) => {
                        const node = nodes.get(id);
                        if (!node.children.length) {
                            return { value: node.value, colorSum: node.color * node.value, weight: node.value || 1 };
                        }
                        let total = 0;
                        let colorSum = 0;
                        let weight = 0;
                        node.children.forEach((childId) => {
                            const res = aggregate(childId);
                            total += res.value;
                            colorSum += res.colorSum;
                            weight += res.weight;
                        });
                        node.value = total;
                        node.color = weight ? colorSum / weight : 0;
                        return { value: node.value, colorSum: node.color * node.value, weight: node.value || weight || 1 };
                    };
                    aggregate('Project');

                    const ids = [];
                    const labels = [];
                    const parents = [];
                    const values = [];
                    const colors = [];

                    const nodeIndexById = new Map();
                    const nodeDataById = new Map();

                    nodes.forEach((node, idx) => {
                        nodeIndexById.set(normalizeId(node.id), idx);
                        nodeDataById.set(node.id, node);
                        ids.push(node.id);
                        labels.push(node.label);
                        parents.push(node.parent);
                        values.push(node.value);
                        colors.push(node.color);
                        // Attach node id for lookup
                        custom.push([node.filePath || '', node.id, normalizeId(node.id)]);
                    });

                    const cloneMap = buildCloneMap(nodeIndexById);
                    const tooltipEl = document.getElementById('treemap-tooltip');

                    // Tooltip rendering helpers
                    const renderValue = (v) => {
                        if (v === null || v === undefined || v === '') return '—';
                        const num = Number(v);
                        if (Number.isFinite(num)) {
                            const rounded = num.toFixed(1);
                            return rounded.endsWith('.0') ? rounded.slice(0, -2) : rounded;
                        }
                        return v;
                    };

                    // Get color for severity percentage (0-100, higher = worse/more critical)
                    // Uses badge colors: grey (low), yellow (medium), orange (high), red (critical)
                    const getSeverityColor = (pct) => {
                        if (pct === null || pct === undefined) return 'inherit';
                        if (pct >= 80) return '#dc3545'; // red - critical
                        if (pct >= 60) return '#fd7e14'; // orange - high concern
                        if (pct >= 40) return '#ffc107'; // yellow - medium
                        return '#6c757d'; // grey - low/acceptable
                    };

                    // Get color for maintainability index (0-100, higher = better health)
                    const getMaintainabilityColor = (mi) => {
                        if (mi === null || mi === undefined) return 'inherit';
                        if (mi >= 65) return '#6c757d'; // grey - good
                        if (mi >= 40) return '#ffc107'; // yellow - medium
                        if (mi >= 20) return '#fd7e14'; // orange - high concern
                        return '#dc3545'; // red - critical
                    };

                    const formatIssue = (issue = {}) => {
                        const severity = typeof issue.severity === 'number' ? issue.severity.toFixed(1) : '—';
                        const category = (issue.category || issue.code || '').toString().toLowerCase();
                        let title = issue.title || issue.category || issue.code || 'Issue';
                        let summary = issue.summary || '';

                        const feats = Array.isArray(issue.contributing_features) ? issue.contributing_features : [];

                        const getFeat = (key) => {
                            const m = feats.find(f => String(f.feature_name || '').toLowerCase().includes(key));
                            return m && m.value !== undefined ? Number(m.value) : null;
                        };

                        const cyclo = getFeat('cyclomatic');
                        const cognitive = getFeat('cognitive');
                        const mi = getFeat('maintainability');
                        const debt = getFeat('technical_debt');
                        const nesting = getFeat('nesting');

                        // Calculate a normalized severity percentage based on the issue category
                        // Higher percentage = worse/more critical (like treemap: 100% = critical)
                        let healthPct = null;
                        if (category.includes('debt')) {
                            title = 'Poor code organization';
                            healthPct = debt != null ? Math.min(100, debt) : null;
                            if (!summary) {
                                summary = debt != null
                                    ? `Technical debt score ${debt.toFixed(1)} — higher means more restructuring needed`
                                    : 'Organization/debt exceeds the acceptable baseline';
                            }
                        } else if (category.includes('maintain')) {
                            title = 'Too much code coupling';
                            healthPct = mi != null ? Math.max(0, 100 - mi) : null;
                            if (!summary) {
                                summary = mi != null
                                    ? `Maintainability Index ${mi.toFixed(1)} — lower MI suggests tighter coupling; target ≥ 60`
                                    : 'Maintainability/coupling exceeds the acceptable baseline';
                            }
                        } else if (category.includes('cognit')) {
                            title = 'Too many code paths';
                            healthPct = cognitive != null ? Math.min(100, (cognitive / 15) * 50) : null;
                            if (!summary && cognitive != null) {
                                summary = `Cognitive complexity ${cognitive.toFixed(0)} — target ≤ 15 (lower is better)`;
                            }
                        } else if (category.includes('complex')) {
                            title = 'Too many branch points';
                            healthPct = cyclo != null ? Math.min(100, (cyclo / 10) * 50) : null;
                            if (!summary && cyclo != null) {
                                summary = `Cyclomatic complexity ${cyclo.toFixed(0)} — target ≤ 10 (lower is better)`;
                            }
                        } else if (category.includes('struct')) {
                            title = 'Deep nesting';
                            if (nesting != null) {
                                if (nesting <= 3) {
                                    healthPct = (nesting / 3) * 40;
                                } else if (nesting <= 6) {
                                    healthPct = 40 + ((nesting - 3) / 3) * 40;
                                } else {
                                    const excess = nesting - 6;
                                    healthPct = 80 + 20 * (1 - Math.exp(-excess / 3));
                                }
                                healthPct = Math.min(100, Math.max(0, healthPct));
                            }
                            if (!summary) {
                                summary = nesting != null
                                    ? `Nesting depth ${nesting} — target ≤ 3 (lower is better)`
                                    : 'Deeply nested control flow; consider extracting helper functions';
                            }
                        } else if (category.includes('coverage')) {
                            title = 'Missing test coverage';
                            if (!summary) summary = 'Add tests for this code path';
                        }

                        return { title, severity, summary, healthPct };
                    };

                    // Get maintainability index from entity's issues contributing_features
                    const getEntityMaintainability = (entity) => {
                        if (!entity) return null;
                        if (entity.maintainability_index != null) return entity.maintainability_index;
                        const issues = entity.issues || [];
                        for (const issue of issues) {
                            const feats = issue.contributing_features || [];
                            const miFeat = feats.find(f => (f.feature_name || '').toLowerCase().includes('maintainability'));
                            if (miFeat && miFeat.value != null) return Number(miFeat.value);
                        }
                        return null;
                    };

                    const buildTooltipHtml = (nodeId, colorVal) => {
                        const node = nodeDataById.get(nodeId);
                        if (!node) return '';

                        const isEntity = nodeId.startsWith('entity:');
                        const isFile = nodeId.startsWith('file:');
                        const isDir = nodeId.startsWith('dir:');

                        let html = '<div class="tooltip-name">' + (node.label || 'Unknown') + '</div>';

                        if (isEntity && node.entity) {
                            const entity = node.entity;
                            const rawIssues = Array.isArray(entity.issues) ? entity.issues : [];
                            const rawSuggestions = Array.isArray(entity.suggestions) ? entity.suggestions : [];

                            // Format and sort issues by healthPct descending (higher % = worse = first)
                            const issues = rawIssues
                                .map(formatIssue)
                                .sort((a, b) => {
                                    const aPct = a.healthPct ?? -1;
                                    const bPct = b.healthPct ?? -1;
                                    return bPct - aPct;
                                });

                            // Metrics
                            html += '<ul class="tooltip-metrics">';
                            html += '<li><span class="metric-label">Severity</span><span class="metric-value">' + renderValue(colorVal) + '</span></li>';
                            html += '<li><span class="metric-label">Lines</span><span class="metric-value">' + renderValue(node.value) + '</span></li>';
                            if (entity.line_range) {
                                html += '<li><span class="metric-label">Range</span><span class="metric-value">' + entity.line_range[0] + '–' + entity.line_range[1] + '</span></li>';
                            }
                            html += '</ul>';

                            // Issues with color-coded percentages (matching tree panel format)
                            if (issues.length > 0) {
                                html += '<div class="tooltip-section"><h4>Issues</h4><ul class="tooltip-section-list">';
                                issues.slice(0, 5).forEach(fmt => {
                                    const pct = fmt.healthPct;
                                    const pctColor = getSeverityColor(pct);
                                    const pctDisplay = pct != null ? Math.round(pct) + '%' : null;
                                    html += '<li><div class="issue-heading" style="display:flex;justify-content:space-between;gap:0.5rem">';
                                    html += '<span>' + fmt.title + '</span>';
                                    if (pctDisplay) {
                                        html += '<span style="color:' + pctColor + ';font-weight:500">' + pctDisplay + '</span>';
                                    }
                                    html += '</div></li>';
                                });
                                html += '</ul></div>';
                            }

                            // Suggestions (matching tree panel format, using codeDictionary for friendly names)
                            if (rawSuggestions.length > 0) {
                                // Extract unique suggestion texts, looking up from codeDictionary if needed
                                const suggestionTexts = [...new Set(rawSuggestions.map(s => {
                                    // First try the suggestion's own summary/title
                                    let text = s.summary || s.explanation || s.heading || s.title || '';
                                    // If not found, look up in codeDictionary by code
                                    if (!text && s.code && codeDictionary.suggestions) {
                                        const dictEntry = codeDictionary.suggestions[s.code];
                                        if (dictEntry) {
                                            text = dictEntry.summary || dictEntry.title || '';
                                        }
                                    }
                                    // Last resort: clean up refactoring_type (remove trailing numbers)
                                    if (!text && s.refactoring_type) {
                                        text = s.refactoring_type.replace(/_\d+$/, '').replace(/_/g, ' ');
                                    }
                                    return (text || '').trim();
                                }).filter(Boolean))];

                                if (suggestionTexts.length > 0) {
                                    html += '<div class="tooltip-section"><h4>Suggested Actions</h4><ul class="tooltip-section-list">';
                                    suggestionTexts.slice(0, 3).forEach(txt => {
                                        html += '<li><div class="issue-summary">' + txt + '</div></li>';
                                    });
                                    html += '</ul></div>';
                                }
                            }
                        } else if (isFile && node.entities.length > 0) {
                            // File-level tooltip
                            html += '<ul class="tooltip-metrics">';
                            html += '<li><span class="metric-label">Entities</span><span class="metric-value">' + node.entities.length + '</span></li>';
                            html += '<li><span class="metric-label">Severity</span><span class="metric-value">' + renderValue(colorVal) + '</span></li>';
                            html += '<li><span class="metric-label">Lines</span><span class="metric-value">' + renderValue(node.value) + '</span></li>';
                            html += '</ul>';

                            // Top entities with color-coded severity (inverted MI: 100% = bad, 0% = good)
                            // Sort by severity descending (worst first)
                            const sortedEntities = node.entities
                                .map(entity => {
                                    const mi = getEntityMaintainability(entity);
                                    const severityPct = mi != null ? Math.max(0, 100 - mi) : null;
                                    return { entity, severityPct };
                                })
                                .sort((a, b) => (b.severityPct ?? -1) - (a.severityPct ?? -1))
                                .slice(0, 5);

                            if (sortedEntities.length > 0) {
                                html += '<div class="tooltip-section"><h4>Top Entities</h4><ul class="tooltip-section-list">';
                                sortedEntities.forEach(({ entity, severityPct }) => {
                                    const severityColor = getSeverityColor(severityPct);
                                    const severityDisplay = severityPct != null ? Math.round(severityPct) + '%' : null;
                                    html += '<li><div class="issue-heading">' + (entity.name || 'Entity');
                                    if (severityDisplay) {
                                        html += ' · <span style="color:' + severityColor + '">' + severityDisplay + '</span>';
                                    }
                                    html += '</div></li>';
                                });
                                html += '</ul></div>';
                            }
                        } else if (isDir) {
                            // No tooltip for directories
                            return '';
                        } else {
                            // Root or unknown
                            html += '<ul class="tooltip-metrics">';
                            html += '<li><span class="metric-label">Severity</span><span class="metric-value">' + renderValue(colorVal) + '</span></li>';
                            html += '<li><span class="metric-label">Lines</span><span class="metric-value">' + renderValue(node.value) + '</span></li>';
                            html += '</ul>';
                        }

                        return html;
                    };

                    const trace = {
                        type: 'treemap',
                        ids,
                        labels,
                        parents,
                        values,
                        marker: {
                            colors,
                            coloraxis: 'coloraxis'
                        },
                        coloraxis: 'coloraxis',
                        branchvalues: 'total',
                        hoverinfo: 'none',
                        customdata: custom
                    };

                    const containerHeight = rootEl.getBoundingClientRect().height || Math.max(300, window.innerHeight - 128);
                    Plotly.newPlot(rootEl, [trace], {
                        margin: { l: 0, r: 0, t: 0, b: 10 },
                        height: containerHeight,
                        paper_bgcolor: 'transparent',
                        plot_bgcolor: 'transparent',
                        font: { color: getComputedStyle(document.documentElement).getPropertyValue('--text') || '#e5e7eb' },
                        coloraxis: {
                            colorscale: [
                                [0, '#6b7280'],
                                [0.5, '#8b4513'],
                                [1, '#991b1b']
                            ],
                            cmin: 0,
                            cmax: maxScale,
                            showscale: false
                        }
                    }, {
                        displaylogo: false,
                        responsive: true
                    });

                    function clearSelection() {
                        Plotly.restyle(rootEl, { selectedpoints: [null] }, [0]);
                    }

                    let lastMouseX = 0, lastMouseY = 0;
                    rootEl.addEventListener('mousemove', (e) => {
                        lastMouseX = e.clientX;
                        lastMouseY = e.clientY;
                    });

                    const showTooltip = (nodeId, colorVal) => {
                        if (!tooltipEl) return;
                        const html = buildTooltipHtml(nodeId, colorVal);
                        if (!html) { tooltipEl.style.display = 'none'; return; }
                        tooltipEl.innerHTML = html;
                        tooltipEl.style.display = 'block';
                        // Position near mouse but avoid edges
                        const rect = tooltipEl.getBoundingClientRect();
                        let x = lastMouseX + 15;
                        let y = lastMouseY + 15;
                        if (x + rect.width > window.innerWidth - 10) x = lastMouseX - rect.width - 15;
                        if (y + rect.height > window.innerHeight - 10) y = lastMouseY - rect.height - 15;
                        tooltipEl.style.left = x + 'px';
                        tooltipEl.style.top = y + 'px';
                    };

                    const hideTooltip = () => {
                        if (tooltipEl) tooltipEl.style.display = 'none';
                    };

                    rootEl.on('plotly_hover', function(ev) {
                        const pt = ev?.points?.[0];
                        const nodeId = pt?.customdata?.[1];
                        const normId = pt?.customdata?.[2];
                        const colorVal = pt?.color;

                        // Show custom tooltip
                        if (nodeId) showTooltip(nodeId, colorVal);

                        // Clone highlighting
                        if (!normId) { clearSelection(); return; }
                        const matches = cloneMap.get(normId);
                        if (!matches || matches.size === 0) { clearSelection(); return; }
                        Plotly.restyle(rootEl, { selectedpoints: [Array.from(matches)] }, [0]);
                    });

                    rootEl.on('plotly_unhover', function() {
                        clearSelection();
                        hideTooltip();
                    });
                }

                function resizePlot() {
                    const rect = rootEl.getBoundingClientRect();
                    const w = rect.width || (rootEl.parentElement && rootEl.parentElement.getBoundingClientRect().width) || undefined;
                    const h = rect.height || Math.max(300, window.innerHeight - 128);
                    Plotly.relayout(rootEl, { width: w, height: h });
                }

                function render() {
                    const metric = (colorSelect && colorSelect.value) || 'complexity';
                    buildTreemap(metric.toLowerCase(), 100);
                    // hook hover after build
                    rootEl.on('plotly_hover', function(ev) {
                        const pt = ev?.points?.[0];
                        const cd = pt ? pt.customdata : null;
                        const filePath = Array.isArray(cd) ? cd[0] : null;
                        const entityId = Array.isArray(cd) ? cd[1] : null;
                        window.dispatchEvent(new CustomEvent('valknut-treemap-hover', { detail: { filePath, entityId }}));
                    });
                    rootEl.on('plotly_unhover', function() {
                        window.dispatchEvent(new CustomEvent('valknut-treemap-hover', { detail: { filePath: null, entityId: null }}));
                    });
                    setTimeout(resizePlot, 0);
                }

                if (colorSelect) colorSelect.addEventListener('change', render);

                if (document.readyState === 'complete' || document.readyState === 'interactive') {
                    render();
                } else {
                    document.addEventListener('DOMContentLoaded', render);
                }

                window.addEventListener('resize', resizePlot);
                window.addEventListener('valknut-tab-activated', (ev) => {
                    if (ev.detail && ev.detail.id === 'treemap') {
                        resizePlot();
                    }
                });
            })();
        </script>
    </div>
</div>
