<!-- Complexity Treemap -->
<div class="results-section accordion">
    <h2 class="accordion-heading" data-target="accordion-treemap" role="button" aria-expanded="true" style="margin-bottom: 0.75rem;">
        <span class="accordion-icon" data-lucide="chevron-down" aria-hidden="true"></span>
        Complexity Treemap
    </h2>
    <div id="accordion-treemap" class="accordion-body" style="display: block;">
        <div style="display:flex; align-items:center; gap:12px; margin-bottom:0.5rem;">
            <label for="treemap-color-metric" style="font-size:0.9rem;color:var(--text-secondary);">Color by:</label>
            <select id="treemap-color-metric" style="background: var(--panel,rgba(255,255,255,0.06)); color: var(--text); border:1px solid rgba(255,255,255,0.08); border-radius:6px; padding:6px 10px; font-size:0.9rem;">
                <option value="complexity" selected>Complexity</option>
                <option value="cognitive">Cognitive</option>
                <option value="debt">Debt</option>
                <option value="maintainability">Maintainability</option>
                <option value="structure">Structure</option>
            </select>
            <label for="treemap-max-scale" style="font-size:0.9rem;color:var(--text-secondary);">Max scale:</label>
            <input id="treemap-max-scale" type="number" value="80" min="10" max="200" step="5" style="width:80px; background: var(--panel,rgba(255,255,255,0.06)); color: var(--text); border:1px solid rgba(255,255,255,0.08); border-radius:6px; padding:6px 8px; font-size:0.9rem;">
        </div>
        <div id="treemap-root" style="width: 100%; min-height: 420px;"></div>
        <script id="treemap-data" type="application/json">
            {
                "candidates": {{#if refactoring_candidates}}{{{json refactoring_candidates}}}{{else}}[]{{/if}},
                "clone_pairs": {{#if clone_pairs}}{{{json clone_pairs}}}{{else}}[]{{/if}}
            }
        </script>
        <script>
            (function() {
                const dataEl = document.getElementById('treemap-data');
                const colorSelect = document.getElementById('treemap-color-metric');
                const maxScaleInput = document.getElementById('treemap-max-scale');
                const rootEl = document.getElementById('treemap-root');
                if (!dataEl || !rootEl) return;

                const payload = JSON.parse(dataEl.textContent || '{}');
                const candidates = Array.isArray(payload.candidates) ? payload.candidates : [];
                const clonePairs = Array.isArray(payload.clone_pairs) ? payload.clone_pairs : [];

                function getLinesOfCode(entity) {
                    let loc = entity.lines_of_code || entity.linesOfCode || null;
                    if (loc) return loc;
                    const issues = Array.isArray(entity.issues) ? entity.issues : [];
                    for (const issue of issues) {
                        const feats = Array.isArray(issue.contributing_features) ? issue.contributing_features : [];
                        for (const f of feats) {
                            if (String(f.feature_name || '').toLowerCase() === 'lines_of_code') {
                                return Number(f.value) || Number(f.contribution) || 1;
                            }
                        }
                    }
                    return 1;
                }

                function severityForCategory(entity, category) {
                    const issues = Array.isArray(entity.issues) ? entity.issues : [];
                    for (const issue of issues) {
                        const cat = String(issue.category || '').toLowerCase();
                        if (cat === category) {
                            return Number(issue.severity) || 0;
                        }
                    }
                    return Number(entity.score) || 0;
                }

                function normalizeId(id) {
                    return String(id || '').trim().toLowerCase();
                }

                function buildCloneMap(nodeIndexById) {
                    const map = new Map();
                    const addLink = (a, b) => {
                        const na = normalizeId(a);
                        const nb = normalizeId(b);
                        const ia = nodeIndexById.get(na);
                        const ib = nodeIndexById.get(nb);
                        if (ia == null || ib == null) return;
                        if (!map.has(na)) map.set(na, new Set());
                        if (!map.has(nb)) map.set(nb, new Set());
                        map.get(na).add(ia); map.get(na).add(ib);
                        map.get(nb).add(ib); map.get(nb).add(ia);
                    };
                    clonePairs.forEach((pair) => {
                        const sId = pair?.source?.id || pair?.source?.entity_id || pair?.source?.name;
                        const tId = pair?.target?.id || pair?.target?.entity_id || pair?.target?.name;
                        if (sId && tId) addLink(sId, tId);
                    });
                    return map;
                }

                function buildTreemap(colorMetric, maxScale) {
                    const nodes = new Map();
                    const custom = [];

                    const ensureNode = (id, label, parent = '') => {
                        if (!nodes.has(id)) {
                            nodes.set(id, { id, label, parent, children: [], value: 0, color: 0 });
                            if (parent && nodes.has(parent)) {
                                nodes.get(parent).children.push(id);
                            }
                        }
                        return nodes.get(id);
                    };

                    // Root
                    ensureNode('Project', 'Project', '');

                    const severityCache = new Map();

                    const getSeverity = (entity, metric) => {
                        const key = (entity.entity_id || entity.name || '') + '|' + metric;
                        if (severityCache.has(key)) return severityCache.get(key);
                        const val = severityForCategory(entity, metric);
                        severityCache.set(key, val);
                        return val;
                    };

                    candidates.forEach((entity) => {
                        const filePath = String(entity.file_path || entity.filePath || '').replace(/\\/g, '/');
                        const parts = filePath.split('/').filter(Boolean);
                        const fileName = parts.pop() || filePath || 'file';
                        let parentId = 'Project';
                        let pathSoFar = '';
                        parts.forEach((part) => {
                            pathSoFar = pathSoFar ? pathSoFar + '/' + part : part;
                            const dirId = 'dir:' + pathSoFar;
                            ensureNode(dirId, part, parentId);
                            parentId = dirId;
                        });
                        const fileId = 'file:' + filePath;
                        ensureNode(fileId, fileName, parentId);

                        const leafId = 'entity:' + (entity.entity_id || entity.name || Math.random());
                        const loc = getLinesOfCode(entity);
                        const colorVal = Math.min(getSeverity(entity, colorMetric), maxScale);
                        const leaf = ensureNode(leafId, entity.name || fileName, fileId);
                        leaf.value = loc;
                        leaf.color = colorVal;
                    });

                    // Aggregate values and colors up the tree
                    const aggregate = (id) => {
                        const node = nodes.get(id);
                        if (!node.children.length) {
                            return { value: node.value, colorSum: node.color * node.value, weight: node.value || 1 };
                        }
                        let total = 0;
                        let colorSum = 0;
                        let weight = 0;
                        node.children.forEach((childId) => {
                            const res = aggregate(childId);
                            total += res.value;
                            colorSum += res.colorSum;
                            weight += res.weight;
                        });
                        node.value = total;
                        node.color = weight ? colorSum / weight : 0;
                        return { value: node.value, colorSum: node.color * node.value, weight: node.value || weight || 1 };
                    };
                    aggregate('Project');

                    const ids = [];
                    const labels = [];
                    const parents = [];
                    const values = [];
                    const colors = [];

                    const nodeIndexById = new Map();

                    nodes.forEach((node, idx) => {
                        nodeIndexById.set(normalizeId(node.id), idx);
                        ids.push(node.id);
                        labels.push(node.label);
                        parents.push(node.parent);
                        values.push(node.value);
                        colors.push(node.color);
                        // Attach file path or id for hover -> clone highlight
                        custom.push([node.filePath || '', node.id, normalizeId(node.id)]);
                    });

                    const cloneMap = buildCloneMap(nodeIndexById);

                    const trace = {
                        type: 'treemap',
                        ids,
                        labels,
                        parents,
                        values,
                        marker: {
                            colors,
                            coloraxis: 'coloraxis'
                        },
                        coloraxis: 'coloraxis',
                        branchvalues: 'total',
                        hovertemplate: '%{label}<br>Size: %{value}<br>Severity: %{color:.1f}<extra></extra>',
                        customdata: custom
                    };

                    Plotly.newPlot(rootEl, [trace], {
                        margin: { l: 0, r: 0, t: 0, b: 80 },
                        paper_bgcolor: 'transparent',
                        plot_bgcolor: 'transparent',
                        font: { color: getComputedStyle(document.documentElement).getPropertyValue('--text') || '#e5e7eb' },
                        coloraxis: {
                            colorscale: [
                                [0, '#6b7280'],
                                [0.5, '#8b4513'],
                                [1, '#991b1b']
                            ],
                            cmin: 0,
                            cmax: maxScale,
                            colorbar: {
                                title: `${colorMetric.charAt(0).toUpperCase() + colorMetric.slice(1)} severity`,
                                tickformat: '.0f',
                                orientation: 'h',
                                y: -0.35,
                                yanchor: 'top',
                                x: 0.5,
                                xanchor: 'center',
                                len: 0.7,
                                thickness: 14,
                                bgcolor: 'rgba(0,0,0,0)'
                            }
                        }
                    }, {
                        displaylogo: false,
                        responsive: true
                    });

                    function clearSelection() {
                        Plotly.restyle(rootEl, { selectedpoints: [null] }, [0]);
                    }

                    rootEl.on('plotly_hover', function(ev) {
                        const pt = ev?.points?.[0];
                        const normId = pt?.customdata?.[2];
                        if (!normId) { clearSelection(); return; }
                        const matches = cloneMap.get(normId);
                        if (!matches || matches.size === 0) { clearSelection(); return; }
                        Plotly.restyle(rootEl, { selectedpoints: [Array.from(matches)] }, [0]);
                    });

                    rootEl.on('plotly_unhover', function() {
                        clearSelection();
                    });
                }

                function render() {
                    const metric = (colorSelect && colorSelect.value) || 'complexity';
                    const maxScale = Number(maxScaleInput && maxScaleInput.value) || 60;
                    buildTreemap(metric.toLowerCase(), maxScale);
                    // hook hover after build
                    rootEl.on('plotly_hover', function(ev) {
                        const pt = ev?.points?.[0];
                        const cd = pt ? pt.customdata : null;
                        const filePath = Array.isArray(cd) ? cd[0] : null;
                        const entityId = Array.isArray(cd) ? cd[1] : null;
                        window.dispatchEvent(new CustomEvent('valknut-treemap-hover', { detail: { filePath, entityId }}));
                    });
                    rootEl.on('plotly_unhover', function() {
                        window.dispatchEvent(new CustomEvent('valknut-treemap-hover', { detail: { filePath: null, entityId: null }}));
                    });
                }

                if (colorSelect) colorSelect.addEventListener('change', render);
                if (maxScaleInput) maxScaleInput.addEventListener('change', render);

                if (document.readyState === 'complete' || document.readyState === 'interactive') {
                    render();
                } else {
                    document.addEventListener('DOMContentLoaded', render);
                }
            })();
        </script>
    </div>
</div>
