<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Repository Analysis: Scribe Analysis</title>
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/react-arborist@3.4.0/dist/index.umd.js"></script>
    <style>
        :root {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2a2a2a;
            --bg-tertiary: #3a3a3a;
            --text-primary: #e5e5e5;
            --text-secondary: #b5b5b5;
            --text-muted: #888;
            --accent-primary: #4f9cf9;
            --accent-secondary: #7c3aed;
            --border-color: #404040;
            --hover-color: #333333;
            --code-bg: #252525;
        }
        
        * {
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Inter', sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-size: 14px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--bg-secondary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .header {
            background: rgba(255, 255, 255, 0.03);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-bottom: 1px solid rgba(255, 255, 255, 0.02);
            color: white;
            padding: 32px;
            position: relative;
            overflow: hidden;
        }
        
        .header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 30%, rgba(255, 255, 255, 0.02) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(255, 255, 255, 0.01) 0%, transparent 50%);
            pointer-events: none;
        }
        
        .header::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: url("data:image/svg+xml,%3csvg width='40' height='40' viewBox='0 0 40 40' xmlns='http://www.w3.org/2000/svg'%3e%3cg fill='none' fill-rule='evenodd'%3e%3cg fill='%23ffffff' fill-opacity='0.02'%3e%3ccircle cx='20' cy='20' r='1'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e");
            pointer-events: none;
        }
        
        .header h1 {
            margin: 0;
            font-size: 32px;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 12px;
            position: relative;
            z-index: 1;
        }
        
        .header .meta {
            margin-top: 20px;
            opacity: 0.9;
            font-size: 13px;
            position: relative;
            z-index: 1;
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
            gap: 16px;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
            background: rgba(255, 255, 255, 0.08);
            padding: 8px 12px;
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        .meta-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateY(-1px);
        }
        
        .stats {
            background: var(--bg-tertiary);
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 24px;
        }
        
        .stat {
            text-align: center;
            padding: 20px;
            background: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            transition: all 0.2s ease;
        }
        
        .stat:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .stat-value {
            font-size: 28px;
            font-weight: 700;
            color: var(--accent-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        
        .stat-label {
            font-size: 12px;
            text-transform: uppercase;
            color: var(--text-muted);
            letter-spacing: 0.5px;
            font-weight: 500;
        }
        
        .toc {
            background: var(--bg-tertiary);
            padding: 24px;
            border-bottom: 1px solid var(--border-color);
        }
        
        .toc h3 {
            margin: 0 0 20px 0;
            font-size: 18px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }
        
        .toc ul {
            margin: 0;
            padding: 0;
            list-style: none;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 8px;
        }
        
        .toc li {
            margin: 0;
        }
        
        .toc a {
            color: var(--text-secondary);
            text-decoration: none;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 6px;
            transition: all 0.2s ease;
        }
        
        .toc a:hover {
            color: var(--accent-primary);
            background: var(--hover-color);
        }
        
        .file-list {
            max-height: 400px;
            overflow-y: auto;
            border-bottom: 1px solid var(--border-color);
            background: var(--bg-secondary);
        }
        
        .file-item {
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.2s ease;
        }
        
        .file-item:hover {
            background-color: var(--hover-color);
        }
        
        .file-item:last-child {
            border-bottom: none;
        }
        
        .file-name {
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-meta {
            font-size: 12px;
            color: var(--text-muted);
        }
        
        .content {
            padding: 24px;
            background: var(--bg-secondary);
        }
        
        .file-section {
            margin-bottom: 32px;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
            background: var(--bg-primary);
        }
        
        .file-header {
            background: var(--bg-tertiary);
            padding: 16px 20px;
            border-bottom: 1px solid var(--border-color);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-weight: 600;
            font-size: 14px;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .file-content {
            max-height: 600px;
            overflow-y: auto;
            position: relative;
        }
        
        .file-content::-webkit-scrollbar {
            width: 8px;
        }
        
        .file-content::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }
        
        .file-content::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }
        
        .file-content::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }
        
        pre {
            margin: 0;
            padding: 24px;
            background: var(--code-bg);
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            line-height: 1.5;
            white-space: pre-wrap;
            word-wrap: break-word;
            color: var(--text-primary);
        }
        
        .icon {
            width: 16px;
            height: 16px;
        }
        
        .icon-lg {
            width: 20px;
            height: 20px;
        }

        /* React Arborist Tree Styles */
        .tree-container {
            height: 400px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            overflow: hidden;
        }

        .tree-node {
            display: flex;
            align-items: center;
            padding: 4px 8px;
            cursor: pointer;
            font-family: 'SF Mono', 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            color: var(--text-secondary);
            transition: all 0.2s ease;
            user-select: none;
        }

        .tree-node:hover {
            background: var(--hover-color);
            color: var(--accent-primary);
        }

        .tree-node.selected {
            background: var(--accent-primary);
            color: white;
        }

        .tree-node-content {
            display: flex;
            align-items: center;
            gap: 6px;
            flex: 1;
        }

        .tree-arrow {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 4px;
            transition: transform 0.2s ease;
        }

        .tree-arrow.expanded {
            transform: rotate(90deg);
        }

        .tree-icon {
            width: 16px;
            height: 16px;
            flex-shrink: 0;
        }

        .tree-label {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .folder-icon {
            color: var(--accent-secondary);
        }

        .file-icon {
            color: var(--text-secondary);
        }

        .react-arborist-tree {
            background: transparent !important;
            color: var(--text-primary) !important;
        }

        .react-arborist-node {
            color: var(--text-secondary) !important;
        }

        .react-arborist-node:hover {
            background: var(--hover-color) !important;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 12px;
            }
            
            .header {
                padding: 20px;
            }
            
            .header h1 {
                font-size: 24px;
            }
            
            .header .meta {
                flex-direction: column;
                align-items: stretch;
                gap: 8px;
            }
            
            .meta-item {
                justify-content: center;
            }
            
            .stats {
                grid-template-columns: 1fr;
                gap: 16px;
                padding: 16px;
            }
            
            .toc ul {
                grid-template-columns: 1fr;
            }
            
            .content {
                padding: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>
                üîç Repository Analysis
            </h1>
            <div class="meta">
                <div class="meta-item">
                    <i data-lucide="cpu" class="icon"></i>
                    <span><strong>Algorithm:</strong> V5Integrated (Enhanced)</span>
                </div>
                <div class="meta-item">
                    <i data-lucide="clock" class="icon"></i>
                    <span><strong>Generated:</strong> 2025-09-15 04:39:56 UTC</span>
                </div>
                <div class="meta-item">
                    <i data-lucide="zap" class="icon"></i>
                    <span><strong>Selection Time:</strong> 6462250ms</span>
                </div>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat">
                <div class="stat-value">
                    <i data-lucide="files" class="icon-lg"></i>
                    73
                </div>
                <div class="stat-label">Files Selected</div>
            </div>
            <div class="stat">
                <div class="stat-value">
                    <i data-lucide="hash" class="icon-lg"></i>
                    20,000
                </div>
                <div class="stat-label">Estimated Tokens</div>
            </div>
            <div class="stat">
                <div class="stat-value">
                    <i data-lucide="hard-drive" class="icon-lg"></i>
                    165.0 KB
                </div>
                <div class="stat-label">Total Size</div>
            </div>
            <div class="stat">
                <div class="stat-value">
                    <i data-lucide="target" class="icon-lg"></i>
                    1.2%
                </div>
                <div class="stat-label">Coverage</div>
            </div>
        </div>
        
        <div class="toc">
            <h3>
                <i data-lucide="folder-tree" class="icon"></i>
                File Explorer
            </h3>
            <div id="file-tree-container" class="tree-container"></div>
        </div>
        
        <div class="file-list">
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/resolve/test/resolver/cup.coffee</span>
                <span class="file-meta">1 B ‚Ä¢ ~0 tokens ‚Ä¢ Score: 2.48</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/resolver/same_names/foo/index.js</span>
                <span class="file-meta">20 B ‚Ä¢ ~4 tokens ‚Ä¢ Score: 2.43</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/resolver/dot_main/index.js</span>
                <span class="file-meta">20 B ‚Ä¢ ~4 tokens ‚Ä¢ Score: 2.43</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/resolver/dot_slash_main/index.js</span>
                <span class="file-meta">20 B ‚Ä¢ ~4 tokens ‚Ä¢ Score: 2.43</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/resolver/quux/foo/index.js</span>
                <span class="file-meta">20 B ‚Ä¢ ~4 tokens ‚Ä¢ Score: 2.43</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/delayed-stream/.npmignore</span>
                <span class="file-meta">5 B ‚Ä¢ ~1 tokens ‚Ä¢ Score: 2.39</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/require-directory/.npmignore</span>
                <span class="file-meta">8 B ‚Ä¢ ~1 tokens ‚Ä¢ Score: 2.39</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="list" class="icon"></i>templates/assets/node_modules/randombytes/.zuul.yml</span>
                <span class="file-meta">9 B ‚Ä¢ ~2 tokens ‚Ä¢ Score: 2.39</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/call-bind/.eslintignore</span>
                <span class="file-meta">10 B ‚Ä¢ ~1 tokens ‚Ä¢ Score: 2.39</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/node_path/x/aaa/index.js</span>
                <span class="file-meta">22 B ‚Ä¢ ~4 tokens ‚Ä¢ Score: 2.35</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/node_path/x/ccc/index.js</span>
                <span class="file-meta">22 B ‚Ä¢ ~4 tokens ‚Ä¢ Score: 2.35</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/node_path/y/bbb/index.js</span>
                <span class="file-meta">22 B ‚Ä¢ ~4 tokens ‚Ä¢ Score: 2.35</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/node_path/y/ccc/index.js</span>
                <span class="file-meta">23 B ‚Ä¢ ~4 tokens ‚Ä¢ Score: 2.32</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/precedence/aaa/index.js</span>
                <span class="file-meta">25 B ‚Ä¢ ~4 tokens ‚Ä¢ Score: 2.25</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/precedence/aaa/main.js</span>
                <span class="file-meta">28 B ‚Ä¢ ~1 tokens ‚Ä¢ Score: 2.21</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="git-branch" class="icon"></i>templates/assets/node_modules/is-map/.gitattributes</span>
                <span class="file-meta">12 B ‚Ä¢ ~2 tokens ‚Ä¢ Score: 2.19</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="git-branch" class="icon"></i>templates/assets/node_modules/is-set/.gitattributes</span>
                <span class="file-meta">12 B ‚Ä¢ ~2 tokens ‚Ä¢ Score: 2.19</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="git-branch" class="icon"></i>templates/assets/node_modules/is-weakset/.gitattributes</span>
                <span class="file-meta">12 B ‚Ä¢ ~2 tokens ‚Ä¢ Score: 2.19</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/dotdot/index.js</span>
                <span class="file-meta">29 B ‚Ä¢ ~4 tokens ‚Ä¢ Score: 2.15</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@sinclair/typebox/errors/index.d.ts</span>
                <span class="file-meta">26 B ‚Ä¢ ~5 tokens ‚Ä¢ Score: 2.09</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@sinclair/typebox/system/index.d.ts</span>
                <span class="file-meta">26 B ‚Ä¢ ~5 tokens ‚Ä¢ Score: 2.09</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@babel/core/src/config/files/index.ts</span>
                <span class="file-meta">747 B ‚Ä¢ ~114 tokens ‚Ä¢ Score: 2.09</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@jest/core/node_modules/react-is/index.js</span>
                <span class="file-meta">196 B ‚Ä¢ ~22 tokens ‚Ä¢ Score: 2.06</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/sprintf-js/.npmignore</span>
                <span class="file-meta">14 B ‚Ä¢ ~1 tokens ‚Ä¢ Score: 2.02</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@webassemblyjs/utf8/src/index.js</span>
                <span class="file-meta">82 B ‚Ä¢ ~18 tokens ‚Ä¢ Score: 2.02</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@babel/core/src/config/files/index-browser.ts</span>
                <span class="file-meta">2.9 KB ‚Ä¢ ~412 tokens ‚Ä¢ Score: 1.98</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@testing-library/jest-dom/types/index.d.ts</span>
                <span class="file-meta">35 B ‚Ä¢ ~5 tokens ‚Ä¢ Score: 1.98</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@testing-library/react/types/pure.d.ts</span>
                <span class="file-meta">19 B ‚Ä¢ ~5 tokens ‚Ä¢ Score: 1.83</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>node_modules/tldts-core/src/domain.ts</span>
                <span class="file-meta">3.1 KB ‚Ä¢ ~625 tokens ‚Ä¢ Score: 1.83</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@react-dnd/asap/src/index.ts</span>
                <span class="file-meta">117 B ‚Ä¢ ~21 tokens ‚Ä¢ Score: 1.82</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/acorn-import-phases/src/index.cjs</span>
                <span class="file-meta">182 B ‚Ä¢ ~29 tokens ‚Ä¢ Score: 1.80</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/math-intrinsics/abs.d.ts</span>
                <span class="file-meta">18 B ‚Ä¢ ~4 tokens ‚Ä¢ Score: 1.79</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/math-intrinsics/max.d.ts</span>
                <span class="file-meta">18 B ‚Ä¢ ~4 tokens ‚Ä¢ Score: 1.79</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/playwright-core/index.mjs</span>
                <span class="file-meta">1.0 KB ‚Ä¢ ~198 tokens ‚Ä¢ Score: 1.77</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/command-line-shell/before/src/main.py</span>
                <span class="file-meta">3.8 KB ‚Ä¢ ~580 tokens ‚Ä¢ Score: 1.76</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/command-line-shell/after/src/main.py</span>
                <span class="file-meta">2.5 KB ‚Ä¢ ~333 tokens ‚Ä¢ Score: 1.75</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/acorn-import-phases/src/index.d.mts</span>
                <span class="file-meta">203 B ‚Ä¢ ~33 tokens ‚Ä¢ Score: 1.74</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="book-open" class="icon"></i>templates/assets/node_modules/playwright-core/README.md</span>
                <span class="file-meta">120 B ‚Ä¢ ~13 tokens ‚Ä¢ Score: 1.73</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/acorn-import-phases/src/index.d.cts</span>
                <span class="file-meta">223 B ‚Ä¢ ~36 tokens ‚Ä¢ Score: 1.73</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>src/core/pipeline/mod.rs</span>
                <span class="file-meta">6.1 KB ‚Ä¢ ~501 tokens ‚Ä¢ Score: 1.69</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="book-open" class="icon"></i>templates/assets/node_modules/@jest/core/README.md</span>
                <span class="file-meta">163 B ‚Ä¢ ~33 tokens ‚Ä¢ Score: 1.61</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>node_modules/playwright-core/index.mjs</span>
                <span class="file-meta">1.0 KB ‚Ä¢ ~198 tokens ‚Ä¢ Score: 1.49</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>src/core/config.rs</span>
                <span class="file-meta">44.9 KB ‚Ä¢ ~5,469 tokens ‚Ä¢ Score: 1.45</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>src/core/pipeline/pipeline_config.rs</span>
                <span class="file-meta">6.7 KB ‚Ä¢ ~741 tokens ‚Ä¢ Score: 1.43</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/@types/yargs/helpers.d.mts</span>
                <span class="file-meta">30 B ‚Ä¢ ~5 tokens ‚Ä¢ Score: 1.38</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>src/detectors/structure/directory.rs</span>
                <span class="file-meta">71.2 KB ‚Ä¢ ~7,745 tokens ‚Ä¢ Score: 1.38</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="book-open" class="icon"></i>templates/assets/node_modules/@babel/core/README.md</span>
                <span class="file-meta">401 B ‚Ä¢ ~52 tokens ‚Ä¢ Score: 1.37</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="terminal" class="icon"></i>templates/assets/node_modules/playwright-core/bin/install_media_pack.ps1</span>
                <span class="file-meta">174 B ‚Ä¢ ~26 tokens ‚Ä¢ Score: 1.33</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/point-of-sale/after/main.py</span>
                <span class="file-meta">995 B ‚Ä¢ ~122 tokens ‚Ä¢ Score: 1.32</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/point-of-sale/before/main.py</span>
                <span class="file-meta">650 B ‚Ä¢ ~86 tokens ‚Ä¢ Score: 1.32</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/escalade/sync/index.d.mts</span>
                <span class="file-meta">177 B ‚Ä¢ ~37 tokens ‚Ä¢ Score: 1.30</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="list" class="icon"></i>templates/assets/node_modules/walker/.travis.yml</span>
                <span class="file-meta">35 B ‚Ä¢ ~6 tokens ‚Ä¢ Score: 1.30</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="list" class="icon"></i>templates/assets/node_modules/makeerror/.travis.yml</span>
                <span class="file-meta">35 B ‚Ä¢ ~6 tokens ‚Ä¢ Score: 1.30</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/y18n/index.mjs</span>
                <span class="file-meta">183 B ‚Ä¢ ~33 tokens ‚Ä¢ Score: 1.29</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="list" class="icon"></i>templates/assets/node_modules/require-directory/.travis.yml</span>
                <span class="file-meta">36 B ‚Ä¢ ~6 tokens ‚Ä¢ Score: 1.28</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/cliui/index.mjs</span>
                <span class="file-meta">309 B ‚Ä¢ ~52 tokens ‚Ä¢ Score: 1.28</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/yargs/index.mjs</span>
                <span class="file-meta">231 B ‚Ä¢ ~29 tokens ‚Ä¢ Score: 1.27</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/get-package-type/index.cjs</span>
                <span class="file-meta">210 B ‚Ä¢ ~24 tokens ‚Ä¢ Score: 1.25</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>src/detectors/structure/config.rs</span>
                <span class="file-meta">8.6 KB ‚Ä¢ ~1,361 tokens ‚Ä¢ Score: 1.25</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/escalade/index.d.mts</span>
                <span class="file-meta">236 B ‚Ä¢ ~45 tokens ‚Ä¢ Score: 1.23</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/get-package-type/cache.cjs</span>
                <span class="file-meta">43 B ‚Ä¢ ~8 tokens ‚Ä¢ Score: 1.22</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="list" class="icon"></i>templates/assets/node_modules/concat-map/.travis.yml</span>
                <span class="file-meta">43 B ‚Ä¢ ~9 tokens ‚Ä¢ Score: 1.18</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>src/lib.rs</span>
                <span class="file-meta">5.5 KB ‚Ä¢ ~848 tokens ‚Ä¢ Score: 1.18</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/memoize-one/src/memoize-one.js.flow</span>
                <span class="file-meta">231 B ‚Ä¢ ~38 tokens ‚Ä¢ Score: 1.14</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/get-caller-file/index.js.map</span>
                <span class="file-meta">773 B ‚Ä¢ ~1 tokens ‚Ä¢ Score: 0.88</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/fastest-levenshtein/esm/mod.d.ts.map</span>
                <span class="file-meta">258 B ‚Ä¢ ~1 tokens ‚Ä¢ Score: 0.57</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/command-line-shell/before/src/UtilPackage/TestingDir/UTestEncoding.py</span>
                <span class="file-meta">27 B ‚Ä¢ ~2 tokens ‚Ä¢ Score: 0.54</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/@jridgewell/trace-mapping/types/strip-filename.d.cts.map</span>
                <span class="file-meta">218 B ‚Ä¢ ~1 tokens ‚Ä¢ Score: 0.52</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/command-line-shell/after/src/shell/__init__.py</span>
                <span class="file-meta">1 B ‚Ä¢ ~0 tokens ‚Ä¢ Score: 0.46</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/resolve/test/resolver/mug.coffee</span>
                <span class="file-meta">0 B ‚Ä¢ ~0 tokens ‚Ä¢ Score: 0.33</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file" class="icon"></i>templates/assets/test-results/.playwright-artifacts-1/f68b0a029edec8b1ad5d972accf3be0f.webm</span>
                <span class="file-meta">0 B ‚Ä¢ ~0 tokens ‚Ä¢ Score: 0.33</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/point-of-sale/after/pos/__init__.py</span>
                <span class="file-meta">1 B ‚Ä¢ ~0 tokens ‚Ä¢ Score: 0.01</span>
            </div>
            <div class="file-item">
                <span class="file-name"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/point-of-sale/before/pos/__init__.py</span>
                <span class="file-meta">1 B ‚Ä¢ ~0 tokens ‚Ä¢ Score: 0.01</span>
            </div>
        </div>
        
        <div class="content">
            <div class="file-section" id="file-1">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/resolve/test/resolver/cup.coffee</div>
                <div class="file-content">
                    <pre>
</pre>
                </div>
            </div>
            <div class="file-section" id="file-2">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/resolver/same_names/foo/index.js</div>
                <div class="file-content">
                    <pre>module.exports &#x3D; 1;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-3">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/resolver/dot_main/index.js</div>
                <div class="file-content">
                    <pre>module.exports &#x3D; 1;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-4">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/resolver/dot_slash_main/index.js</div>
                <div class="file-content">
                    <pre>module.exports &#x3D; 1;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-5">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/resolver/quux/foo/index.js</div>
                <div class="file-content">
                    <pre>module.exports &#x3D; 1;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-6">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/delayed-stream/.npmignore</div>
                <div class="file-content">
                    <pre>test
</pre>
                </div>
            </div>
            <div class="file-section" id="file-7">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/require-directory/.npmignore</div>
                <div class="file-content">
                    <pre>test/**
</pre>
                </div>
            </div>
            <div class="file-section" id="file-8">
                <div class="file-header"><i data-lucide="list" class="icon"></i>templates/assets/node_modules/randombytes/.zuul.yml</div>
                <div class="file-content">
                    <pre>ui: tape
</pre>
                </div>
            </div>
            <div class="file-section" id="file-9">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/call-bind/.eslintignore</div>
                <div class="file-content">
                    <pre>coverage/
</pre>
                </div>
            </div>
            <div class="file-section" id="file-10">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/node_path/x/aaa/index.js</div>
                <div class="file-content">
                    <pre>module.exports &#x3D; &amp;#x27;A&amp;#x27;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-11">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/node_path/x/ccc/index.js</div>
                <div class="file-content">
                    <pre>module.exports &#x3D; &amp;#x27;C&amp;#x27;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-12">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/node_path/y/bbb/index.js</div>
                <div class="file-content">
                    <pre>module.exports &#x3D; &amp;#x27;B&amp;#x27;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-13">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/node_path/y/ccc/index.js</div>
                <div class="file-content">
                    <pre>module.exports &#x3D; &amp;#x27;CY&amp;#x27;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-14">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/precedence/aaa/index.js</div>
                <div class="file-content">
                    <pre>module.exports &#x3D; &amp;#x27;okok&amp;#x27;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-15">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/precedence/aaa/main.js</div>
                <div class="file-content">
                    <pre>console.log(require(&amp;#x27;./&amp;#x27;));
</pre>
                </div>
            </div>
            <div class="file-section" id="file-16">
                <div class="file-header"><i data-lucide="git-branch" class="icon"></i>templates/assets/node_modules/is-map/.gitattributes</div>
                <div class="file-content">
                    <pre>* text&#x3D;auto
</pre>
                </div>
            </div>
            <div class="file-section" id="file-17">
                <div class="file-header"><i data-lucide="git-branch" class="icon"></i>templates/assets/node_modules/is-set/.gitattributes</div>
                <div class="file-content">
                    <pre>* text&#x3D;auto
</pre>
                </div>
            </div>
            <div class="file-section" id="file-18">
                <div class="file-header"><i data-lucide="git-branch" class="icon"></i>templates/assets/node_modules/is-weakset/.gitattributes</div>
                <div class="file-content">
                    <pre>* text&#x3D;auto
</pre>
                </div>
            </div>
            <div class="file-section" id="file-19">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/resolve/test/dotdot/index.js</div>
                <div class="file-content">
                    <pre>module.exports &#x3D; &amp;#x27;whatever&amp;#x27;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-20">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@sinclair/typebox/errors/index.d.ts</div>
                <div class="file-content">
                    <pre>export * from &amp;#x27;./errors&amp;#x27;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-21">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@sinclair/typebox/system/index.d.ts</div>
                <div class="file-content">
                    <pre>export * from &amp;#x27;./system&amp;#x27;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-22">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@babel/core/src/config/files/index.ts</div>
                <div class="file-content">
                    <pre>type indexBrowserType &#x3D; typeof import(&amp;quot;./index-browser&amp;quot;);
type indexType &#x3D; typeof import(&amp;quot;./index&amp;quot;);

// Kind of gross, but essentially asserting that the exports of this module are the same as the
// exports of index-browser, since this file may be replaced at bundle time with index-browser.
({}) as any as indexBrowserType as indexType;

export { findPackageData } from &amp;quot;./package.ts&amp;quot;;

export {
  findConfigUpwards,
  findRelativeConfig,
  findRootConfig,
  loadConfig,
  resolveShowConfigPath,
  ROOT_CONFIG_FILENAMES,
} from &amp;quot;./configuration.ts&amp;quot;;
export type {
  ConfigFile,
  IgnoreFile,
  RelativeConfig,
  FilePackageData,
} from &amp;quot;./types.ts&amp;quot;;
export {
  loadPlugin,
  loadPreset,
  resolvePlugin,
  resolvePreset,
} from &amp;quot;./plugins.ts&amp;quot;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-23">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@jest/core/node_modules/react-is/index.js</div>
                <div class="file-content">
                    <pre>&amp;#x27;use strict&amp;#x27;;

if (process.env.NODE_ENV &#x3D;&#x3D;&#x3D; &amp;#x27;production&amp;#x27;) {
  module.exports &#x3D; require(&amp;#x27;./cjs/react-is.production.min.js&amp;#x27;);
} else {
  module.exports &#x3D; require(&amp;#x27;./cjs/react-is.development.js&amp;#x27;);
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-24">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/sprintf-js/.npmignore</div>
                <div class="file-content">
                    <pre>/node_modules/</pre>
                </div>
            </div>
            <div class="file-section" id="file-25">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@webassemblyjs/utf8/src/index.js</div>
                <div class="file-content">
                    <pre>// @flow

export { decode } from &amp;quot;./decoder&amp;quot;;
export { encode } from &amp;quot;./encoder&amp;quot;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-26">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@babel/core/src/config/files/index-browser.ts</div>
                <div class="file-content">
                    <pre>/* c8 ignore start */

import type { Handler } from &amp;quot;gensync&amp;quot;;

import type {
  ConfigFile,
  IgnoreFile,
  RelativeConfig,
  FilePackageData,
} from &amp;quot;./types.ts&amp;quot;;

import type { CallerMetadata } from &amp;quot;../validation/options.ts&amp;quot;;

export type { ConfigFile, IgnoreFile, RelativeConfig, FilePackageData };

export function findConfigUpwards(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  rootDir: string,
): string | null {
  return null;
}

// eslint-disable-next-line require-yield
export function* findPackageData(filepath: string): Handler&amp;lt;FilePackageData&amp;gt; {
  return {
    filepath,
    directories: [],
    pkg: null,
    isPackage: false,
  };
}

// eslint-disable-next-line require-yield
export function* findRelativeConfig(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  pkgData: FilePackageData,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  envName: string,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  caller: CallerMetadata | undefined,
): Handler&amp;lt;RelativeConfig&amp;gt; {
  return { config: null, ignore: null };
}

// eslint-disable-next-line require-yield
export function* findRootConfig(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dirname: string,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  envName: string,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  caller: CallerMetadata | undefined,
): Handler&amp;lt;ConfigFile | null&amp;gt; {
  return null;
}

// eslint-disable-next-line require-yield
export function* loadConfig(
  name: string,
  dirname: string,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  envName: string,
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  caller: CallerMetadata | undefined,
): Handler&amp;lt;ConfigFile&amp;gt; {
  throw new Error(&#x60;Cannot load ${name} relative to ${dirname} in a browser&#x60;);
}

// eslint-disable-next-line require-yield
export function* resolveShowConfigPath(
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  dirname: string,
): Handler&amp;lt;string | null&amp;gt; {
  return null;
}

export const ROOT_CONFIG_FILENAMES: string[] &#x3D; [];

type Resolved &#x3D;
  | { loader: &amp;quot;require&amp;quot;; filepath: string }
  | { loader: &amp;quot;import&amp;quot;; filepath: string };

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function resolvePlugin(name: string, dirname: string): Resolved | null {
  return null;
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
export function resolvePreset(name: string, dirname: string): Resolved | null {
  return null;
}

export function loadPlugin(
  name: string,
  dirname: string,
): Handler&amp;lt;{
  filepath: string;
  value: unknown;
}&amp;gt; {
  throw new Error(
    &#x60;Cannot load plugin ${name} relative to ${dirname} in a browser&#x60;,
  );
}

export function loadPreset(
  name: string,
  dirname: string,
): Handler&amp;lt;{
  filepath: string;
  value: unknown;
}&amp;gt; {
  throw new Error(
    &#x60;Cannot load preset ${name} relative to ${dirname} in a browser&#x60;,
  );
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-27">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@testing-library/jest-dom/types/index.d.ts</div>
                <div class="file-content">
                    <pre>/// &amp;lt;reference path&#x3D;&amp;quot;jest.d.ts&amp;quot; /&amp;gt;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-28">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@testing-library/react/types/pure.d.ts</div>
                <div class="file-content">
                    <pre>export * from &amp;#x27;./&amp;#x27;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-29">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>node_modules/tldts-core/src/domain.ts</div>
                <div class="file-content">
                    <pre>import { IOptions } from &amp;#x27;./options&amp;#x27;;

/**
 * Check if &#x60;vhost&#x60; is a valid suffix of &#x60;hostname&#x60; (top-domain)
 *
 * It means that &#x60;vhost&#x60; needs to be a suffix of &#x60;hostname&#x60; and we then need to
 * make sure that: either they are equal, or the character preceding &#x60;vhost&#x60; in
 * &#x60;hostname&#x60; is a &amp;#x27;.&amp;#x27; (it should not be a partial label).
 *
 * * hostname &#x3D; &amp;#x27;not.evil.com&amp;#x27; and vhost &#x3D; &amp;#x27;vil.com&amp;#x27;      &#x3D;&amp;gt; not ok
 * * hostname &#x3D; &amp;#x27;not.evil.com&amp;#x27; and vhost &#x3D; &amp;#x27;evil.com&amp;#x27;     &#x3D;&amp;gt; ok
 * * hostname &#x3D; &amp;#x27;not.evil.com&amp;#x27; and vhost &#x3D; &amp;#x27;not.evil.com&amp;#x27; &#x3D;&amp;gt; ok
 */
function shareSameDomainSuffix(hostname: string, vhost: string): boolean {
  if (hostname.endsWith(vhost)) {
    return (
      hostname.length &#x3D;&#x3D;&#x3D; vhost.length ||
      hostname[hostname.length - vhost.length - 1] &#x3D;&#x3D;&#x3D; &amp;#x27;.&amp;#x27;
    );
  }

  return false;
}

/**
 * Given a hostname and its public suffix, extract the general domain.
 */
function extractDomainWithSuffix(
  hostname: string,
  publicSuffix: string,
): string {
  // Locate the index of the last &amp;#x27;.&amp;#x27; in the part of the &#x60;hostname&#x60; preceding
  // the public suffix.
  //
  // examples:
  //   1. not.evil.co.uk  &#x3D;&amp;gt; evil.co.uk
  //         ^    ^
  //         |    | start of public suffix
  //         | index of the last dot
  //
  //   2. example.co.uk   &#x3D;&amp;gt; example.co.uk
  //     ^       ^
  //     |       | start of public suffix
  //     |
  //     | (-1) no dot found before the public suffix
  const publicSuffixIndex &#x3D; hostname.length - publicSuffix.length - 2;
  const lastDotBeforeSuffixIndex &#x3D; hostname.lastIndexOf(&amp;#x27;.&amp;#x27;, publicSuffixIndex);

  // No &amp;#x27;.&amp;#x27; found, then &#x60;hostname&#x60; is the general domain (no sub-domain)
  if (lastDotBeforeSuffixIndex &#x3D;&#x3D;&#x3D; -1) {
    return hostname;
  }

  // Extract the part between the last &amp;#x27;.&amp;#x27;
  return hostname.slice(lastDotBeforeSuffixIndex + 1);
}

/**
 * Detects the domain based on rules and upon and a host string
 */
export default function getDomain(
  suffix: string,
  hostname: string,
  options: IOptions,
): string | null {
  // Check if &#x60;hostname&#x60; ends with a member of &#x60;validHosts&#x60;.
  if (options.validHosts !&#x3D;&#x3D; null) {
    const validHosts &#x3D; options.validHosts;
    for (const vhost of validHosts) {
      if (/*@__INLINE__*/ shareSameDomainSuffix(hostname, vhost)) {
        return vhost;
      }
    }
  }

  let numberOfLeadingDots &#x3D; 0;
  if (hostname.startsWith(&amp;#x27;.&amp;#x27;)) {
    while (
      numberOfLeadingDots &amp;lt; hostname.length &amp;amp;&amp;amp;
      hostname[numberOfLeadingDots] &#x3D;&#x3D;&#x3D; &amp;#x27;.&amp;#x27;
    ) {
      numberOfLeadingDots +&#x3D; 1;
    }
  }

  // If &#x60;hostname&#x60; is a valid public suffix, then there is no domain to return.
  // Since we already know that &#x60;getPublicSuffix&#x60; returns a suffix of &#x60;hostname&#x60;
  // there is no need to perform a string comparison and we only compare the
  // size.
  if (suffix.length &#x3D;&#x3D;&#x3D; hostname.length - numberOfLeadingDots) {
    return null;
  }

  // To extract the general domain, we start by identifying the public suffix
  // (if any), then consider the domain to be the public suffix with one added
  // level of depth. (e.g.: if hostname is &#x60;not.evil.co.uk&#x60; and public suffix:
  // &#x60;co.uk&#x60;, then we take one more level: &#x60;evil&#x60;, giving the final result:
  // &#x60;evil.co.uk&#x60;).
  return /*@__INLINE__*/ extractDomainWithSuffix(hostname, suffix);
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-30">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/@react-dnd/asap/src/index.ts</div>
                <div class="file-content">
                    <pre>export * from &amp;#x27;./asap.js&amp;#x27;
export * from &amp;#x27;./types.js&amp;#x27;
export * from &amp;#x27;./AsapQueue.js&amp;#x27;
export * from &amp;#x27;./TaskFactory.js&amp;#x27;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-31">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/acorn-import-phases/src/index.cjs</div>
                <div class="file-content">
                    <pre>const { plugin } &#x3D; require(&amp;quot;./plugin.cjs&amp;quot;);

module.exports &#x3D; function (options &#x3D; {}) {
  return (Parser) &#x3D;&amp;gt; plugin(options, Parser, (Parser.acorn || require(&amp;quot;acorn&amp;quot;)).tokTypes);
};
</pre>
                </div>
            </div>
            <div class="file-section" id="file-32">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/math-intrinsics/abs.d.ts</div>
                <div class="file-content">
                    <pre>export &#x3D; Math.abs;</pre>
                </div>
            </div>
            <div class="file-section" id="file-33">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/math-intrinsics/max.d.ts</div>
                <div class="file-content">
                    <pre>export &#x3D; Math.max;</pre>
                </div>
            </div>
            <div class="file-section" id="file-34">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/playwright-core/index.mjs</div>
                <div class="file-content">
                    <pre>/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import playwright from &amp;#x27;./index.js&amp;#x27;;

export const chromium &#x3D; playwright.chromium;
export const firefox &#x3D; playwright.firefox;
export const webkit &#x3D; playwright.webkit;
export const selectors &#x3D; playwright.selectors;
export const devices &#x3D; playwright.devices;
export const errors &#x3D; playwright.errors;
export const request &#x3D; playwright.request;
export const _electron &#x3D; playwright._electron;
export const _android &#x3D; playwright._android;
export default playwright;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-35">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/command-line-shell/before/src/main.py</div>
                <div class="file-content">
                    <pre>&amp;quot;&amp;quot;&amp;quot;

Author: Hossin azmoud (Moody0101)
Date: 10/18/2022
LICENCE: MIT
Language: Python3.10

&amp;quot;&amp;quot;&amp;quot;

from time import sleep, time
from colorama import Fore as f
from UtilPackage import (
	Shell, 
	Command,
	ENCODING,
	HASHING,
	EncodingManager, # EncodingManager(Func: callable, s: str | bytes, Op: int)
	ENCODE, 
	DECODE,
	Hasher # Hasher(HashingFunc: callable, s: str | bytes) -&amp;gt; str: 
)

DOC &#x3D; f&amp;quot;&amp;quot;&amp;quot;{f.YELLOW}

	Author: Hossin azmoud (Moody0101)
	Date: 10/18/2022
	LICENCE: MIT
	Language: {f.CYAN}Python3.10 {f.YELLOW}
	Descripion: A tool to hash, encode, decode text.
	command: hash, encode, decode, help, exit
	Usage: 
		To encode/Decode:
			Encode/Decode &amp;lt;Text&amp;gt; &amp;lt;Algorithm&amp;gt;
			Encode/Decode only for help.
		To hash:
			Hash &amp;lt;Text&amp;gt; &amp;lt;Algorithm&amp;gt;
			Hash only for help.
&amp;quot;&amp;quot;&amp;quot;

class Interface:
	&amp;quot;&amp;quot;&amp;quot; An interface that handles user interactions with the shell program &amp;quot;&amp;quot;&amp;quot;
	
	def __init__(self) -&amp;gt; None:
		# Shell initializer
		self.shell &#x3D; Shell()
		
		
		self.DefaultCommands &#x3D; {
			&amp;#x27;EXIT&amp;#x27;: self.Exit,
			&amp;#x27;HELP&amp;#x27;: self.Help,
			&amp;quot;HASH&amp;quot;: self.hashDoc,
			&amp;quot;DECODE&amp;quot;: self.DeDoc,
			&amp;quot;ENCODE&amp;quot;: self.EnDoc
		}

		self.Commands &#x3D; {
			&amp;quot;HASH&amp;quot;: self.hashVal,
			&amp;quot;DECODE&amp;quot;: self.Decode,
			&amp;quot;ENCODE&amp;quot;: self.Encode
		}

	def hashDoc(self):
		&amp;quot;&amp;quot;&amp;quot; Displays doc for hashing &amp;quot;&amp;quot;&amp;quot;
		return HASHING[&amp;quot;Doc&amp;quot;] 

	def DeDoc(self):
		&amp;quot;&amp;quot;&amp;quot; Displays doc for decoding &amp;quot;&amp;quot;&amp;quot;
		return ENCODING[&amp;quot;Doc&amp;quot;][DECODE]

	def EnDoc(self):
		&amp;quot;&amp;quot;&amp;quot; Displays doc for encoding &amp;quot;&amp;quot;&amp;quot;
		return ENCODING[&amp;quot;Doc&amp;quot;][ENCODE]

	def Encode(self, Text, EncoderName):
		if EncoderName.upper().strip() not in ENCODING.keys():
			print()
			print(f&amp;quot;  False algorithm name, {EncoderName}&amp;quot;)
			print(&amp;quot;  you can only use from this list:&amp;quot;)
			for i in ENCODING.keys():
				print(&amp;quot;    %s&amp;quot;, i)
			return

		# Get Encoder function
		func_ &#x3D; ENCODING[EncoderName.upper().strip()][ENCODE]
		# Map the value
		encode &#x3D; EncodingManager(func_, ENCODE)
		# return the value
		return encode(Text)

	def Decode(self, Text, DecoderName):
		if DecoderName.upper().strip() not in ENCODING.keys():
			print()
			print(f&amp;quot;  False algorithm name, {DecoderName}&amp;quot;)
			print(&amp;quot;  you can only use from this list:&amp;quot;)
			for i in ENCODING.keys():
				print(&amp;quot;    %s&amp;quot;, i)
			return

		# Get Encoder function
		func_ &#x3D; ENCODING[DecoderName.upper().strip()][DECODE]
		# Map the value
		decode &#x3D; EncodingManager(func_, DECODE)
		# return the value
		return decode(Text)

	def hashVal(self, Text, HasherName):
		if HasherName.upper().strip() not in HASHING.keys():
			print()
			print(f&amp;quot;  False algorithm name, {DecoderName}&amp;quot;)
			print(&amp;quot;  you can only use from this list:&amp;quot;)
			for i in HASHING.keys():
				print(&amp;quot;    %s&amp;quot;, i)
			return

		return Hasher(HASHING[HasherName.upper().strip()], Text)

	def showFuncs(self):
		
		if self.Tool:
			for i in CONFIG[self.Tool].keys():
				print(&amp;quot;  &amp;quot;, i)

	def SetText(self, Text &#x3D; None): 
		self.text &#x3D; Text

	def Exit(self) -&amp;gt; None:
		
		for i in [&amp;#x27;.&amp;#x27;, &amp;#x27;..&amp;#x27;, &amp;#x27;...&amp;#x27;]:
			print(f&amp;quot;  Exiting{i}&amp;quot;, end&#x3D;&amp;quot;\r&amp;quot;)
			sleep(1)
		exit(0)

	def Help(self):
		return &amp;quot;&amp;quot;&amp;quot;

	To encode/Decode:
		Encode/Decode &amp;lt;Text&amp;gt; &amp;lt;Algorithm&amp;gt;
		Encode/Decode only for help.
	To hash:
		Hash &amp;lt;Text&amp;gt; &amp;lt;Algorithm&amp;gt;
		Hash only for help.

		&amp;quot;&amp;quot;&amp;quot;

	def execute(self, command: Command) -&amp;gt; None:
		&amp;quot;&amp;quot;&amp;quot;  &amp;quot;&amp;quot;&amp;quot;
		if command.CMD in self.DefaultCommands.keys():
			if len(command.argv) &amp;gt; 0:
				print(self.Commands[command.CMD](*command.argv))
			else:
				print(self.DefaultCommands[command.CMD]())
		elif command.CMD in self.Commands.keys():
			if len(command.argv) &amp;gt; 0:
				print(self.Commands[command.CMD](*command.argv))
			else:
				print(self.Commands[command.CMD]())

	def run(self) -&amp;gt; None:
		print()
		print(DOC)
		Interact &#x3D; True
		while Interact:
			self.command &#x3D; self.shell.shellInput()
			if self.command:
				self.execute(self.command)
			else:
				pass

def main():
	Interface_ &#x3D; Interface()
	Interface_.run()

if __name__ &#x3D;&#x3D; &amp;#x27;__main__&amp;#x27;:
	main()
</pre>
                </div>
            </div>
            <div class="file-section" id="file-36">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/command-line-shell/after/src/main.py</div>
                <div class="file-content">
                    <pre>&amp;quot;&amp;quot;&amp;quot;
HEDShell
Date: 10/18/2022
LICENCE: MIT
Language: Python3.10
&amp;quot;&amp;quot;&amp;quot;

from time import sleep

from colorama import Fore as f
from shell.api import (
    decode,
    decoding_algos,
    encode,
    encoding_algos,
    has_decoding_algo,
    has_encoding_algo,
    has_hashing_algo,
    hash_val,
    hashing_algos,
)
from shell.core import add_command, run_shell

STARTUP_DOC &#x3D; f&amp;quot;&amp;quot;&amp;quot;{f.YELLOW}
    HEDShell
    LICENCE: MIT
    Language: {f.CYAN}Python3.10{f.YELLOW}
    Description: A tool to hash, encode, decode text
    Commands: hash, encode, decode, help, exit
&amp;quot;&amp;quot;&amp;quot;

ENCODING_DOC &#x3D; f&amp;quot;&amp;quot;&amp;quot;
    Syntax: Encode &amp;lt;InputText&amp;gt; &amp;lt; {&amp;quot; | &amp;quot;.join(encoding_algos())} &amp;gt;
&amp;quot;&amp;quot;&amp;quot;

DECODING_DOC &#x3D; f&amp;quot;&amp;quot;&amp;quot;
    Syntax: Decode &amp;lt;InputText&amp;gt; &amp;lt; {&amp;quot; | &amp;quot;.join(decoding_algos())} &amp;gt;
&amp;quot;&amp;quot;&amp;quot;

HASHING_DOC &#x3D; f&amp;quot;&amp;quot;&amp;quot;
    Syntax: Hash &amp;lt;InputText&amp;gt; &amp;lt; {&amp;quot; | &amp;quot;.join(hashing_algos())} &amp;gt;
&amp;quot;&amp;quot;&amp;quot;

HELP_DOC &#x3D; &amp;quot;&amp;quot;&amp;quot;
    Usage:
		To encode/Decode:
			Encode/Decode &amp;lt;Text&amp;gt; &amp;lt;Algorithm&amp;gt;
			Encode/Decode only for help.
		To hash:
			Hash &amp;lt;Text&amp;gt; &amp;lt;Algorithm&amp;gt;
			Hash only for help.
&amp;quot;&amp;quot;&amp;quot;


def exit_shell(_: list[str]) -&amp;gt; None:
    for i in [&amp;quot;.&amp;quot;, &amp;quot;..&amp;quot;, &amp;quot;...&amp;quot;]:
        print(f&amp;quot;  Exiting{i}&amp;quot;, end&#x3D;&amp;quot;\r&amp;quot;)
        sleep(1)
    exit(0)


def help_shell(_: list[str]) -&amp;gt; None:
    print(HELP_DOC)


def process_hash(args: list[str]) -&amp;gt; None:
    if len(args) !&#x3D; 2:
        print(HASHING_DOC)
        return
    [text, hashing_algo] &#x3D; args
    if not has_hashing_algo(hashing_algo):
        print(f&amp;quot;Unknown algorithm name: {hashing_algo}.&amp;quot;)
        print(HASHING_DOC)
        return
    hashed_text &#x3D; hash_val(text, hashing_algo)
    print(hashed_text)


def process_decode(args: list[str]) -&amp;gt; None:
    if len(args) !&#x3D; 2:
        print(DECODING_DOC)
        return
    [text, decoder_algo] &#x3D; args
    if not has_decoding_algo(decoder_algo):
        print(f&amp;quot;Unknown algorithm name: {decoder_algo}.&amp;quot;)
        print(DECODING_DOC)
        return
    decoded_text &#x3D; decode(text, decoder_algo)
    print(decoded_text)


def process_encode(args: list[str]) -&amp;gt; None:
    if len(args) !&#x3D; 2:
        print(ENCODING_DOC)
        return
    [text, encoder_algo] &#x3D; args
    if not has_encoding_algo(encoder_algo):
        print(f&amp;quot;Unknown algorithm name: {encoder_algo}.&amp;quot;)
        print(ENCODING_DOC)
        return
    encoded_text &#x3D; encode(text, encoder_algo)
    print(encoded_text)


def main() -&amp;gt; None:
    add_command(&amp;quot;exit&amp;quot;, exit_shell)
    add_command(&amp;quot;help&amp;quot;, help_shell)
    add_command(&amp;quot;hash&amp;quot;, process_hash)
    add_command(&amp;quot;encode&amp;quot;, process_encode)
    add_command(&amp;quot;decode&amp;quot;, process_decode)

    print(STARTUP_DOC)
    run_shell()


if __name__ &#x3D;&#x3D; &amp;quot;__main__&amp;quot;:
    main()
</pre>
                </div>
            </div>
            <div class="file-section" id="file-37">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/acorn-import-phases/src/index.d.mts</div>
                <div class="file-content">
                    <pre>import { Parser } from &amp;quot;acorn&amp;quot;;

interface Options {
  source?: boolean;
  defer?: boolean;
}

export default function acornImportPhases(options?: Options): (BaseParser: typeof Parser) &#x3D;&amp;gt; typeof Parser;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-38">
                <div class="file-header"><i data-lucide="book-open" class="icon"></i>templates/assets/node_modules/playwright-core/README.md</div>
                <div class="file-content">
                    <pre># playwright-core

This package contains the no-browser flavor of [Playwright](http://github.com/microsoft/playwright).
</pre>
                </div>
            </div>
            <div class="file-section" id="file-39">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/acorn-import-phases/src/index.d.cts</div>
                <div class="file-content">
                    <pre>import { Parser } from &amp;quot;acorn&amp;quot;;

interface Options {
  source?: boolean;
  defer?: boolean;
}

declare function acornImportPhases(options?: Options): (BaseParser: typeof Parser) &#x3D;&amp;gt; typeof Parser;
export &#x3D; acornImportPhases;</pre>
                </div>
            </div>
            <div class="file-section" id="file-40">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>src/core/pipeline/mod.rs</div>
                <div class="file-content">
                    <pre>pub use pipeline_config::{AnalysisConfig, QualityGateConfig, QualityGateResult, QualityGateViolation};
pub use pipeline_results::{
    ComprehensiveAnalysisResult, AnalysisSummary, StructureAnalysisResults,
    ComplexityAnalysisResults, RefactoringAnalysisResults, ImpactAnalysisResults,
    CoverageAnalysisResults, HealthMetrics, PipelineResults, PipelineStatistics, 
    MemoryStats, ResultSummary, ScoringResults, FileScore, PipelineStatus
};
pub use pipeline_executor::{AnalysisPipeline, ProgressCallback, ExtractorRegistry};
pub use pipeline_stages::AnalysisStages;

mod pipeline_config;
mod pipeline_results; 
mod pipeline_executor;
mod pipeline_stages;

/// Additional tests for pipeline modules to improve coverage

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;
    use tempfile::TempDir;
    use std::fs;
    
    #[tokio::test]
    async fn test_pipeline_fit_legacy_api() {
        let pipeline &#x3D; AnalysisPipeline::default();
        let mut pipeline &#x3D; pipeline;
        let result &#x3D; pipeline.fit(&amp;amp;[]).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_pipeline_extractor_registry() {
        let pipeline &#x3D; AnalysisPipeline::default();
        let registry &#x3D; pipeline.extractor_registry();
        let extractors: Vec&amp;lt;_&amp;gt; &#x3D; registry.get_all_extractors().collect();
        assert_eq!(extractors.len(), 0);
    }

    #[tokio::test]
    async fn test_pipeline_analyze_vectors_legacy() {
        let pipeline &#x3D; AnalysisPipeline::default();
        let result &#x3D; pipeline.analyze_vectors(vec![]).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_pipeline_status() {
        let pipeline &#x3D; AnalysisPipeline::default();
        let status &#x3D; pipeline.get_status();
        assert!(status.ready);
        assert!(status.is_ready);
        assert!(status.config_valid);
    }

    #[tokio::test]
    async fn test_quality_gates_evaluation() {
        let pipeline &#x3D; AnalysisPipeline::default();
        let config &#x3D; QualityGateConfig::default();
        let results &#x3D; pipeline_results::ComprehensiveAnalysisResult {
            analysis_id: &amp;quot;test&amp;quot;.to_string(),
            timestamp: chrono::Utc::now(),
            processing_time: 1.0,
            config: pipeline_config::AnalysisConfig::default(),
            summary: pipeline_results::AnalysisSummary {
                total_files: 1,
                total_entities: 1,
                total_lines_of_code: 100,
                languages: vec![&amp;quot;Rust&amp;quot;.to_string()],
                total_issues: 0,
                high_priority_issues: 0,
                critical_issues: 0,
            },
            structure: pipeline_results::StructureAnalysisResults {
                enabled: true,
                directory_recommendations: vec![],
                file_splitting_recommendations: vec![],
                issues_count: 0,
            },
            complexity: pipeline_results::ComplexityAnalysisResults {
                enabled: true,
                detailed_results: vec![],
                average_cyclomatic_complexity: 2.0,
                average_cognitive_complexity: 1.5,
                average_technical_debt_score: 10.0,
                average_maintainability_index: 85.0,
                issues_count: 0,
            },
            refactoring: pipeline_results::RefactoringAnalysisResults {
                enabled: true,
                detailed_results: vec![],
                opportunities_count: 0,
            },
            impact: pipeline_results::ImpactAnalysisResults {
                enabled: true,
                dependency_cycles: vec![],
                chokepoints: vec![],
                clone_groups: vec![],
                issues_count: 0,
            },
            lsh: pipeline_results::LshAnalysisResults {
                enabled: false,
                clone_pairs: vec![],
                max_similarity: 0.0,
                avg_similarity: 0.0,
                duplicate_count: 0,
                denoising_enabled: false,
                tfidf_stats: None,
            },
            coverage: pipeline_results::CoverageAnalysisResults {
                enabled: false,
                coverage_files_used: vec![],
                coverage_gaps: vec![],
                gaps_count: 0,
                overall_coverage_percentage: None,
                analysis_method: &amp;quot;none&amp;quot;.to_string(),
            },
            health_metrics: pipeline_results::HealthMetrics {
                overall_health_score: 88.0,
                maintainability_score: 85.0,
                technical_debt_ratio: 10.0,
                complexity_score: 15.0,
                structure_quality_score: 90.0,
            },
        };

        let gate_result &#x3D; pipeline.evaluate_quality_gates(&amp;amp;config, &amp;amp;results);
        assert!(gate_result.passed);
    }

    #[tokio::test]
    async fn test_analyze_directory_integration() {
        let temp_dir &#x3D; TempDir::new().unwrap();
        let file_path &#x3D; temp_dir.path().join(&amp;quot;test.rs&amp;quot;);
        fs::write(&amp;amp;file_path, &amp;quot;fn main() { println!(\&amp;quot;Hello\&amp;quot;); }&amp;quot;).unwrap();
        
        let pipeline &#x3D; AnalysisPipeline::default();
        let result &#x3D; pipeline.analyze_directory(temp_dir.path()).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_analyze_paths_with_progress() {
        let temp_dir &#x3D; TempDir::new().unwrap();
        let file_path &#x3D; temp_dir.path().join(&amp;quot;test.rs&amp;quot;);
        fs::write(&amp;amp;file_path, &amp;quot;fn main() { println!(\&amp;quot;Hello\&amp;quot;); }&amp;quot;).unwrap();
        
        let pipeline &#x3D; AnalysisPipeline::default();
        let paths &#x3D; vec![temp_dir.path().to_path_buf()];
        
        let progress_called &#x3D; std::sync::Arc::new(std::sync::atomic::AtomicBool::new(false));
        let progress_called_clone &#x3D; progress_called.clone();
        let progress_callback &#x3D; Some(Box::new(move |_msg: &amp;amp;str, _progress: f64| {
            progress_called_clone.store(true, std::sync::atomic::Ordering::SeqCst);
        }) as ProgressCallback);
        
        let result &#x3D; pipeline.analyze_paths(&amp;amp;paths, progress_callback).await;
        assert!(result.is_ok());
        assert!(progress_called.load(std::sync::atomic::Ordering::SeqCst));
    }
}</pre>
                </div>
            </div>
            <div class="file-section" id="file-41">
                <div class="file-header"><i data-lucide="book-open" class="icon"></i>templates/assets/node_modules/@jest/core/README.md</div>
                <div class="file-content">
                    <pre># @jest/core

Jest is currently working on providing a programmatic API. This is under development, and usage of this package directly is currently not supported.
</pre>
                </div>
            </div>
            <div class="file-section" id="file-42">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>node_modules/playwright-core/index.mjs</div>
                <div class="file-content">
                    <pre>/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &amp;quot;AS IS&amp;quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import playwright from &amp;#x27;./index.js&amp;#x27;;

export const chromium &#x3D; playwright.chromium;
export const firefox &#x3D; playwright.firefox;
export const webkit &#x3D; playwright.webkit;
export const selectors &#x3D; playwright.selectors;
export const devices &#x3D; playwright.devices;
export const errors &#x3D; playwright.errors;
export const request &#x3D; playwright.request;
export const _electron &#x3D; playwright._electron;
export const _android &#x3D; playwright._android;
export default playwright;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-43">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>src/core/config.rs</div>
                <div class="file-content">
                    <pre>//! Configuration types and management for valknut-rs.
//!
//! This module provides comprehensive configuration structures that mirror
//! the Python implementation while adding Rust-specific optimizations and
//! type safety guarantees.

use std::collections::HashMap;
use std::path::PathBuf;

use serde::{Deserialize, Serialize};
// Removed unused regex import

use crate::core::errors::{Result, ValknutError};
use crate::detectors::structure::StructureConfig;
// use crate::detectors::names::NamesConfig;

/// Main configuration for valknut analysis engine
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ValknutConfig {
    /// Analysis pipeline configuration
    pub analysis: AnalysisConfig,
    
    /// Scoring and normalization settings
    pub scoring: ScoringConfig,
    
    /// Graph analysis configuration
    pub graph: GraphConfig,
    
    /// LSH and similarity detection settings
    pub lsh: LshConfig,
    
    /// Enhanced duplicate detection configuration
    #[serde(default)]
    pub dedupe: DedupeConfig,
    
    /// Clone denoising configuration
    #[serde(default)]
    pub denoise: DenoiseConfig,
    
    /// Language-specific settings
    pub languages: HashMap&amp;lt;String, LanguageConfig&amp;gt;,
    
    /// I/O and persistence settings
    pub io: IoConfig,
    
    /// Performance and resource limits
    pub performance: PerformanceConfig,
    
    /// Structure analysis configuration
    pub structure: StructureConfig,
    
    /// Coverage analysis and file discovery configuration
    #[serde(default)]
    pub coverage: CoverageConfig,
    
    /// Live reachability analysis configuration
    #[serde(skip_serializing_if &#x3D; &amp;quot;Option::is_none&amp;quot;)]
    pub live_reach: Option&amp;lt;LiveReachConfig&amp;gt;,
    
    /// Code quality analysis configuration (simple pattern-based analysis)
    // pub names: NamesConfig,
    /// Placeholder to maintain serialization compatibility
    #[serde(skip)]
    pub _names_placeholder: Option&amp;lt;()&amp;gt;,
}

impl Default for ValknutConfig {
    fn default() -&amp;gt; Self {
        Self {
            analysis: AnalysisConfig::default(),
            scoring: ScoringConfig::default(),
            graph: GraphConfig::default(),
            lsh: LshConfig::default(),
            dedupe: DedupeConfig::default(),
            denoise: DenoiseConfig::default(),
            languages: Self::default_languages(),
            io: IoConfig::default(),
            performance: PerformanceConfig::default(),
            structure: StructureConfig::default(),
            coverage: CoverageConfig::default(),
            live_reach: None,
            // names: NamesConfig::default(),
            _names_placeholder: None,
        }
    }
}

impl ValknutConfig {
    /// Load configuration from a YAML file
    pub fn from_yaml_file(path: impl Into&amp;lt;PathBuf&amp;gt;) -&amp;gt; Result&amp;lt;Self&amp;gt; {
        let path &#x3D; path.into();
        let content &#x3D; std::fs::read_to_string(&amp;amp;path)
            .map_err(|e| ValknutError::io(format!(&amp;quot;Failed to read config file: {}&amp;quot;, path.display()), e))?;
        
        serde_yaml::from_str(&amp;amp;content).map_err(Into::into)
    }
    
    /// Save configuration to a YAML file
    pub fn to_yaml_file(&amp;amp;self, path: impl Into&amp;lt;PathBuf&amp;gt;) -&amp;gt; Result&amp;lt;()&amp;gt; {
        let path &#x3D; path.into();
        let content &#x3D; serde_yaml::to_string(self)?;
        std::fs::write(&amp;amp;path, content)
            .map_err(|e| ValknutError::io(format!(&amp;quot;Failed to write config file: {}&amp;quot;, path.display()), e))
    }
    
    /// Get default language configurations
    fn default_languages() -&amp;gt; HashMap&amp;lt;String, LanguageConfig&amp;gt; {
        let mut languages &#x3D; HashMap::new();
        
        languages.insert(&amp;quot;python&amp;quot;.to_string(), LanguageConfig {
            enabled: true,
            file_extensions: vec![&amp;quot;.py&amp;quot;.to_string(), &amp;quot;.pyi&amp;quot;.to_string()],
            tree_sitter_language: &amp;quot;python&amp;quot;.to_string(),
            max_file_size_mb: 10.0,
            complexity_threshold: 10.0,
            additional_settings: HashMap::new(),
        });
        
        languages.insert(&amp;quot;javascript&amp;quot;.to_string(), LanguageConfig {
            enabled: true,
            file_extensions: vec![&amp;quot;.js&amp;quot;.to_string(), &amp;quot;.mjs&amp;quot;.to_string(), &amp;quot;.jsx&amp;quot;.to_string()],
            tree_sitter_language: &amp;quot;javascript&amp;quot;.to_string(),
            max_file_size_mb: 5.0,
            complexity_threshold: 10.0,
            additional_settings: HashMap::new(),
        });
        
        languages.insert(&amp;quot;typescript&amp;quot;.to_string(), LanguageConfig {
            enabled: true,
            file_extensions: vec![&amp;quot;.ts&amp;quot;.to_string(), &amp;quot;.tsx&amp;quot;.to_string(), &amp;quot;.d.ts&amp;quot;.to_string()],
            tree_sitter_language: &amp;quot;typescript&amp;quot;.to_string(),
            max_file_size_mb: 5.0,
            complexity_threshold: 10.0,
            additional_settings: HashMap::new(),
        });
        
        languages.insert(&amp;quot;rust&amp;quot;.to_string(), LanguageConfig {
            enabled: true,
            file_extensions: vec![&amp;quot;.rs&amp;quot;.to_string()],
            tree_sitter_language: &amp;quot;rust&amp;quot;.to_string(),
            max_file_size_mb: 10.0,
            complexity_threshold: 15.0,
            additional_settings: HashMap::new(),
        });
        
        languages.insert(&amp;quot;go&amp;quot;.to_string(), LanguageConfig {
            enabled: true,
            file_extensions: vec![&amp;quot;.go&amp;quot;.to_string()],
            tree_sitter_language: &amp;quot;go&amp;quot;.to_string(),
            max_file_size_mb: 8.0,
            complexity_threshold: 12.0,
            additional_settings: HashMap::new(),
        });
        
        languages
    }
    
    /// Validate configuration settings
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        self.analysis.validate()?;
        self.scoring.validate()?;
        self.graph.validate()?;
        self.lsh.validate()?;
        self.performance.validate()?;
        // Structure config has built-in validation through Default implementation
        
        // Validate language configurations
        for (lang, config) in &amp;amp;self.languages {
            config.validate().map_err(|e| ValknutError::config_field(
                format!(&amp;quot;Invalid language configuration: {e}&amp;quot;), 
                format!(&amp;quot;languages.{lang}&amp;quot;)
            ))?;
        }
        
        // Validate dedupe configuration
        self.dedupe.validate()?;
        
        // Validate denoise configuration
        self.denoise.validate()?;
        
        // Validate coverage configuration
        self.coverage.validate()?;
        
        Ok(())
    }
}

/// Analysis pipeline configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisConfig {
    /// Enable scoring analysis
    pub enable_scoring: bool,
    
    /// Enable graph analysis
    pub enable_graph_analysis: bool,
    
    /// Enable LSH-based similarity detection
    pub enable_lsh_analysis: bool,
    
    /// Enable refactoring analysis
    pub enable_refactoring_analysis: bool,
    
    /// Enable coverage analysis
    pub enable_coverage_analysis: bool,
    
    /// Enable structure analysis
    pub enable_structure_analysis: bool,
    
    /// Enable code quality analysis
    pub enable_names_analysis: bool,
    
    /// Minimum confidence threshold for results
    pub confidence_threshold: f64,
    
    /// Maximum number of files to process (0 &#x3D; unlimited)
    pub max_files: usize,
    
    /// File patterns to exclude from analysis
    pub exclude_patterns: Vec&amp;lt;String&amp;gt;,
    
    /// File patterns to include in analysis
    pub include_patterns: Vec&amp;lt;String&amp;gt;,
}

impl Default for AnalysisConfig {
    fn default() -&amp;gt; Self {
        Self {
            enable_scoring: true,
            enable_graph_analysis: true,
            enable_lsh_analysis: true,
            enable_refactoring_analysis: true,
            enable_coverage_analysis: true,  // Now enabled by default
            enable_structure_analysis: true,
            enable_names_analysis: true,
            confidence_threshold: 0.7,
            max_files: 0,
            exclude_patterns: vec![
                &amp;quot;*/node_modules/*&amp;quot;.to_string(),
                &amp;quot;*/venv/*&amp;quot;.to_string(),
                &amp;quot;*/target/*&amp;quot;.to_string(),
                &amp;quot;*/__pycache__/*&amp;quot;.to_string(),
                &amp;quot;*.min.js&amp;quot;.to_string(),
            ],
            include_patterns: vec![&amp;quot;**/*&amp;quot;.to_string()],
        }
    }
}

impl AnalysisConfig {
    /// Validate analysis configuration
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.confidence_threshold) {
            return Err(ValknutError::validation(
                format!(&amp;quot;confidence_threshold must be between 0.0 and 1.0, got {}&amp;quot;, self.confidence_threshold)
            ));
        }
        Ok(())
    }
}

/// Scoring and normalization configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScoringConfig {
    /// Normalization scheme to use
    pub normalization_scheme: NormalizationScheme,
    
    /// Enable Bayesian normalization fallbacks
    pub use_bayesian_fallbacks: bool,
    
    /// Enable confidence reporting
    pub confidence_reporting: bool,
    
    /// Feature weights configuration
    pub weights: WeightsConfig,
    
    /// Statistical parameters
    pub statistical_params: StatisticalParams,
}

impl Default for ScoringConfig {
    fn default() -&amp;gt; Self {
        Self {
            normalization_scheme: NormalizationScheme::ZScore,
            use_bayesian_fallbacks: true,
            confidence_reporting: false,
            weights: WeightsConfig::default(),
            statistical_params: StatisticalParams::default(),
        }
    }
}

impl ScoringConfig {
    /// Validate scoring configuration
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        self.weights.validate()?;
        self.statistical_params.validate()?;
        Ok(())
    }
}

/// Available normalization schemes
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all &#x3D; &amp;quot;snake_case&amp;quot;)]
pub enum NormalizationScheme {
    /// Z-score normalization (standardization)
    ZScore,
    /// Min-max normalization to [0, 1] range
    MinMax,
    /// Robust normalization using median and IQR
    Robust,
    /// Z-score with Bayesian priors
    ZScoreBayesian,
    /// Min-max with Bayesian estimation
    MinMaxBayesian,
    /// Robust with Bayesian estimation
    RobustBayesian,
}

/// Feature weights configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WeightsConfig {
    /// Complexity feature weights
    pub complexity: f64,
    
    /// Graph-based feature weights
    pub graph: f64,
    
    /// Structure-based feature weights
    pub structure: f64,
    
    /// Style-based feature weights
    pub style: f64,
    
    /// Coverage-based feature weights
    pub coverage: f64,
}

impl Default for WeightsConfig {
    fn default() -&amp;gt; Self {
        Self {
            complexity: 1.0,
            graph: 0.8,
            structure: 0.9,
            style: 0.5,
            coverage: 0.7,
        }
    }
}

impl WeightsConfig {
    /// Validate weights configuration
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        let weights &#x3D; [self.complexity, self.graph, self.structure, self.style, self.coverage];
        
        for (name, &amp;amp;weight) in [&amp;quot;complexity&amp;quot;, &amp;quot;graph&amp;quot;, &amp;quot;structure&amp;quot;, &amp;quot;style&amp;quot;, &amp;quot;coverage&amp;quot;].iter().zip(&amp;amp;weights) {
            if weight &amp;lt; 0.0 || weight &amp;gt; 10.0 {
                return Err(ValknutError::validation(
                    format!(&amp;quot;Weight for &amp;#x27;{}&amp;#x27; must be between 0.0 and 10.0, got {}&amp;quot;, name, weight)
                ));
            }
        }
        
        Ok(())
    }
}

/// Statistical parameters for analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StatisticalParams {
    /// Confidence interval level (0.95 &#x3D; 95%)
    pub confidence_level: f64,
    
    /// Minimum sample size for statistical analysis
    pub min_sample_size: usize,
    
    /// Outlier detection threshold (in standard deviations)
    pub outlier_threshold: f64,
}

impl Default for StatisticalParams {
    fn default() -&amp;gt; Self {
        Self {
            confidence_level: 0.95,
            min_sample_size: 10,
            outlier_threshold: 3.0,
        }
    }
}

impl StatisticalParams {
    /// Validate statistical parameters
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        if !(0.0..1.0).contains(&amp;amp;self.confidence_level) {
            return Err(ValknutError::validation(
                format!(&amp;quot;confidence_level must be between 0.0 and 1.0, got {}&amp;quot;, self.confidence_level)
            ));
        }
        
        if self.min_sample_size &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;min_sample_size must be greater than 0&amp;quot;));
        }
        
        if self.outlier_threshold &amp;lt;&#x3D; 0.0 {
            return Err(ValknutError::validation(&amp;quot;outlier_threshold must be positive&amp;quot;));
        }
        
        Ok(())
    }
}

/// Graph analysis configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GraphConfig {
    /// Enable betweenness centrality calculation
    pub enable_betweenness: bool,
    
    /// Enable closeness centrality calculation
    pub enable_closeness: bool,
    
    /// Enable cycle detection
    pub enable_cycle_detection: bool,
    
    /// Maximum graph size for exact algorithms
    pub max_exact_size: usize,
    
    /// Use approximation algorithms for large graphs
    pub use_approximation: bool,
    
    /// Sampling rate for approximation algorithms
    pub approximation_sample_rate: f64,
}

impl Default for GraphConfig {
    fn default() -&amp;gt; Self {
        Self {
            enable_betweenness: true,
            enable_closeness: false,
            enable_cycle_detection: true,
            max_exact_size: 10000,
            use_approximation: true,
            approximation_sample_rate: 0.1,
        }
    }
}

impl GraphConfig {
    /// Validate graph configuration
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.approximation_sample_rate) {
            return Err(ValknutError::validation(
                format!(&amp;quot;approximation_sample_rate must be between 0.0 and 1.0, got {}&amp;quot;, self.approximation_sample_rate)
            ));
        }
        Ok(())
    }
}

/// LSH and similarity detection configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LshConfig {
    /// Number of hash functions per band
    pub num_hashes: usize,
    
    /// Number of LSH bands
    pub num_bands: usize,
    
    /// Shingle size for text similarity
    pub shingle_size: usize,
    
    /// Minimum Jaccard similarity threshold
    pub similarity_threshold: f64,
    
    /// Maximum candidates to consider per query
    pub max_candidates: usize,
    
    /// Use advanced similarity algorithms
    pub use_semantic_similarity: bool,
}

impl Default for LshConfig {
    fn default() -&amp;gt; Self {
        Self {
            num_hashes: 128,
            num_bands: 16,
            shingle_size: 3,
            similarity_threshold: 0.7,
            max_candidates: 100,
            use_semantic_similarity: false,  // Keep name for backward compatibility
        }
    }
}

impl LshConfig {
    /// Validate LSH configuration
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        if self.num_hashes &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;num_hashes must be greater than 0&amp;quot;));
        }
        
        if self.num_bands &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;num_bands must be greater than 0&amp;quot;));
        }
        
        if self.num_hashes % self.num_bands !&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;num_hashes must be divisible by num_bands&amp;quot;));
        }
        
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.similarity_threshold) {
            return Err(ValknutError::validation(
                format!(&amp;quot;similarity_threshold must be between 0.0 and 1.0, got {}&amp;quot;, self.similarity_threshold)
            ));
        }
        
        Ok(())
    }
    
    /// Get the number of hashes per band
    pub fn hashes_per_band(&amp;amp;self) -&amp;gt; usize {
        self.num_hashes / self.num_bands
    }
}

/// Language-specific configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LanguageConfig {
    /// Enable analysis for this language
    pub enabled: bool,
    
    /// File extensions to process
    pub file_extensions: Vec&amp;lt;String&amp;gt;,
    
    /// Tree-sitter language identifier
    pub tree_sitter_language: String,
    
    /// Maximum file size to process (in MB)
    pub max_file_size_mb: f64,
    
    /// Complexity threshold for this language
    pub complexity_threshold: f64,
    
    /// Additional language-specific settings
    pub additional_settings: HashMap&amp;lt;String, serde_json::Value&amp;gt;,
}

impl LanguageConfig {
    /// Validate language configuration
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        if self.file_extensions.is_empty() {
            return Err(ValknutError::validation(&amp;quot;file_extensions cannot be empty&amp;quot;));
        }
        
        if self.max_file_size_mb &amp;lt;&#x3D; 0.0 {
            return Err(ValknutError::validation(&amp;quot;max_file_size_mb must be positive&amp;quot;));
        }
        
        if self.complexity_threshold &amp;lt;&#x3D; 0.0 {
            return Err(ValknutError::validation(&amp;quot;complexity_threshold must be positive&amp;quot;));
        }
        
        Ok(())
    }
}

/// I/O and persistence configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IoConfig {
    /// Cache directory path
    pub cache_dir: Option&amp;lt;PathBuf&amp;gt;,
    
    /// Enable result caching
    pub enable_caching: bool,
    
    /// Cache TTL in seconds
    pub cache_ttl_seconds: u64,
    
    /// Report output directory
    pub report_dir: Option&amp;lt;PathBuf&amp;gt;,
    
    /// Report format
    pub report_format: ReportFormat,
    
    /// Enable database persistence
    #[cfg(feature &#x3D; &amp;quot;database&amp;quot;)]
    pub enable_database: bool,
    
    /// Database connection string
    #[cfg(feature &#x3D; &amp;quot;database&amp;quot;)]
    pub database_url: Option&amp;lt;String&amp;gt;,
}

impl Default for IoConfig {
    fn default() -&amp;gt; Self {
        Self {
            cache_dir: None,
            enable_caching: true,
            cache_ttl_seconds: 3600, // 1 hour
            report_dir: None,
            report_format: ReportFormat::Json,
            #[cfg(feature &#x3D; &amp;quot;database&amp;quot;)]
            enable_database: false,
            #[cfg(feature &#x3D; &amp;quot;database&amp;quot;)]
            database_url: None,
        }
    }
}

/// Available report formats
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all &#x3D; &amp;quot;snake_case&amp;quot;)]
pub enum ReportFormat {
    /// JSON format
    Json,
    /// YAML format
    Yaml,
    /// HTML format
    Html,
    /// CSV format (for tabular data)
    Csv,
}

/// Performance and resource configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PerformanceConfig {
    /// Maximum number of parallel threads
    pub max_threads: Option&amp;lt;usize&amp;gt;,
    
    /// Memory limit in MB
    pub memory_limit_mb: Option&amp;lt;usize&amp;gt;,
    
    /// Timeout for individual file analysis (seconds)
    pub file_timeout_seconds: u64,
    
    /// Timeout for entire analysis (seconds)
    pub total_timeout_seconds: Option&amp;lt;u64&amp;gt;,
    
    /// Enable SIMD optimizations
    pub enable_simd: bool,
    
    /// Batch size for parallel processing
    pub batch_size: usize,
}

impl Default for PerformanceConfig {
    fn default() -&amp;gt; Self {
        Self {
            max_threads: None, // Use system default
            memory_limit_mb: None, // No limit
            file_timeout_seconds: 30,
            total_timeout_seconds: None, // No limit
            enable_simd: cfg!(feature &#x3D; &amp;quot;simd&amp;quot;),
            batch_size: 100,
        }
    }
}

impl PerformanceConfig {
    /// Validate performance configuration
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        if let Some(threads) &#x3D; self.max_threads {
            if threads &#x3D;&#x3D; 0 {
                return Err(ValknutError::validation(&amp;quot;max_threads must be greater than 0&amp;quot;));
            }
        }
        
        if let Some(memory) &#x3D; self.memory_limit_mb {
            if memory &#x3D;&#x3D; 0 {
                return Err(ValknutError::validation(&amp;quot;memory_limit_mb must be greater than 0&amp;quot;));
            }
        }
        
        if self.batch_size &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;batch_size must be greater than 0&amp;quot;));
        }
        
        Ok(())
    }
}

/// Configuration for coverage analysis and automatic file discovery
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CoverageConfig {
    /// Enable automatic coverage file discovery
    pub auto_discover: bool,
    
    /// Search paths for coverage files (relative to analysis root)
    pub search_paths: Vec&amp;lt;String&amp;gt;,
    
    /// File patterns to search for
    pub file_patterns: Vec&amp;lt;String&amp;gt;,
    
    /// Maximum age of coverage files in days (0 &#x3D; no age limit)
    pub max_age_days: u32,
    
    /// Specific coverage file path (overrides auto discovery)
    pub coverage_file: Option&amp;lt;PathBuf&amp;gt;,
}

impl Default for CoverageConfig {
    fn default() -&amp;gt; Self {
        Self {
            auto_discover: true,
            search_paths: vec![
                &amp;quot;./coverage/&amp;quot;.to_string(),
                &amp;quot;./target/coverage/&amp;quot;.to_string(),
                &amp;quot;./target/tarpaulin/&amp;quot;.to_string(),
                &amp;quot;./target/&amp;quot;.to_string(),
                &amp;quot;./.coverage/&amp;quot;.to_string(),
                &amp;quot;./htmlcov/&amp;quot;.to_string(),
                &amp;quot;./coverage-reports/&amp;quot;.to_string(),
                &amp;quot;./reports/&amp;quot;.to_string(),
                &amp;quot;./test-results/&amp;quot;.to_string(),
                &amp;quot;./build/coverage/&amp;quot;.to_string(),
                &amp;quot;./build/test-results/&amp;quot;.to_string(),
                &amp;quot;./&amp;quot;.to_string(),  // Root directory last
            ],
            file_patterns: vec![
                // Primary coverage file patterns
                &amp;quot;coverage.xml&amp;quot;.to_string(),
                &amp;quot;lcov.info&amp;quot;.to_string(),
                &amp;quot;coverage.json&amp;quot;.to_string(),
                &amp;quot;coverage.lcov&amp;quot;.to_string(),
                &amp;quot;cobertura.xml&amp;quot;.to_string(),
                
                // Coverage.py variations
                &amp;quot;coverage-final.json&amp;quot;.to_string(),
                &amp;quot;coverage-summary.json&amp;quot;.to_string(),
                &amp;quot;.coverage&amp;quot;.to_string(),
                
                // Common framework patterns  
                &amp;quot;junit.xml&amp;quot;.to_string(),
                &amp;quot;jacoco.xml&amp;quot;.to_string(),
                &amp;quot;clover.xml&amp;quot;.to_string(),
                
                // Recursive patterns
                &amp;quot;**/coverage.xml&amp;quot;.to_string(),
                &amp;quot;**/lcov.info&amp;quot;.to_string(),
                &amp;quot;**/coverage.json&amp;quot;.to_string(),
                &amp;quot;**/cobertura.xml&amp;quot;.to_string(),
                &amp;quot;**/jacoco.xml&amp;quot;.to_string(),
                &amp;quot;**/clover.xml&amp;quot;.to_string(),
                
                // Language-specific patterns
                &amp;quot;target/coverage/*.xml&amp;quot;.to_string(),
                &amp;quot;target/tarpaulin/coverage.xml&amp;quot;.to_string(),
                &amp;quot;target/llvm-cov/coverage.lcov&amp;quot;.to_string(),
                &amp;quot;build/coverage/*.xml&amp;quot;.to_string(),
                &amp;quot;coverage/coverage-final.json&amp;quot;.to_string(),
                &amp;quot;htmlcov/coverage.json&amp;quot;.to_string(),
                
                // Build system patterns
                &amp;quot;**/build/jacoco/*.xml&amp;quot;.to_string(),
                &amp;quot;**/build/reports/jacoco/test/*.xml&amp;quot;.to_string(),
                &amp;quot;**/build/test-results/test/*.xml&amp;quot;.to_string(),
            ],
            max_age_days: 7, // Only use coverage files newer than 7 days
            coverage_file: None,
        }
    }
}

impl CoverageConfig {
    /// Validate coverage configuration
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        if self.file_patterns.is_empty() &amp;amp;&amp;amp; self.auto_discover {
            return Err(ValknutError::validation(&amp;quot;file_patterns cannot be empty when auto_discover is enabled&amp;quot;));
        }
        
        if self.search_paths.is_empty() &amp;amp;&amp;amp; self.auto_discover {
            return Err(ValknutError::validation(&amp;quot;search_paths cannot be empty when auto_discover is enabled&amp;quot;));
        }
        
        Ok(())
    }
}

/// Configuration for live reachability analysis  
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LiveReachConfig {
    /// Ingestion configuration
    pub ingest: IngestConfig,
    
    /// Build/analysis configuration
    pub build: BuildConfig,
}

/// Configuration for stack ingestion
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IngestConfig {
    /// Namespace allow-list (prefixes to include)
    #[serde(default)]
    pub ns_allow: Vec&amp;lt;String&amp;gt;,
    
    /// Language for symbol normalization (auto|jvm|py|go|node|native)
    #[serde(default &#x3D; &amp;quot;default_language&amp;quot;)]
    pub lang: String,
    
    /// Input file glob pattern
    #[serde(default &#x3D; &amp;quot;default_input_glob&amp;quot;)]
    pub input_glob: String,
    
    /// Output directory for processed data
    #[serde(default &#x3D; &amp;quot;default_out_dir&amp;quot;)]
    pub out_dir: String,
    
    /// Upload URI for cloud storage (S3/GCS/Azure)
    #[serde(skip_serializing_if &#x3D; &amp;quot;Option::is_none&amp;quot;)]
    pub upload_uri: Option&amp;lt;String&amp;gt;,
}

/// Configuration for build/analysis phase
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BuildConfig {
    /// Analysis window in days
    #[serde(default &#x3D; &amp;quot;default_since_days&amp;quot;)]
    pub since_days: u32,
    
    /// Services to include in analysis
    #[serde(default &#x3D; &amp;quot;default_services&amp;quot;)]
    pub services: Vec&amp;lt;String&amp;gt;,
    
    /// Weight for static edges relative to runtime edges
    #[serde(default &#x3D; &amp;quot;default_weight_static&amp;quot;)]
    pub weight_static: f64,
    
    /// Island detection configuration
    pub island: IslandConfig,
}

/// Configuration for shadow island detection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IslandConfig {
    /// Minimum community size to consider
    #[serde(default &#x3D; &amp;quot;default_min_size&amp;quot;)]
    pub min_size: usize,
    
    /// Minimum score threshold for shadow islands
    #[serde(default &#x3D; &amp;quot;default_min_score&amp;quot;)]
    pub min_score: f64,
    
    /// Louvain resolution parameter for community detection
    #[serde(default &#x3D; &amp;quot;default_resolution&amp;quot;)]
    pub resolution: f64,
}

// Default value functions
fn default_language() -&amp;gt; String { &amp;quot;auto&amp;quot;.to_string() }
fn default_input_glob() -&amp;gt; String { &amp;quot;stacks/*.txt&amp;quot;.to_string() }
fn default_out_dir() -&amp;gt; String { &amp;quot;.valknut/live/out&amp;quot;.to_string() }
fn default_since_days() -&amp;gt; u32 { 30 }
fn default_services() -&amp;gt; Vec&amp;lt;String&amp;gt; { vec![&amp;quot;api&amp;quot;.to_string()] }
fn default_weight_static() -&amp;gt; f64 { 0.1 }
fn default_min_size() -&amp;gt; usize { 5 }
fn default_min_score() -&amp;gt; f64 { 0.6 }
fn default_resolution() -&amp;gt; f64 { 0.8 }

impl Default for LiveReachConfig {
    fn default() -&amp;gt; Self {
        Self {
            ingest: IngestConfig::default(),
            build: BuildConfig::default(),
        }
    }
}

impl Default for IngestConfig {
    fn default() -&amp;gt; Self {
        Self {
            ns_allow: vec![&amp;quot;myco.&amp;quot;.to_string(), &amp;quot;github.com/myco/&amp;quot;.to_string()],
            lang: default_language(),
            input_glob: default_input_glob(),
            out_dir: default_out_dir(),
            upload_uri: Some(&amp;quot;s3://company-valknut/live&amp;quot;.to_string()),
        }
    }
}

impl Default for BuildConfig {
    fn default() -&amp;gt; Self {
        Self {
            since_days: default_since_days(),
            services: default_services(),
            weight_static: default_weight_static(),
            island: IslandConfig::default(),
        }
    }
}

impl Default for IslandConfig {
    fn default() -&amp;gt; Self {
        Self {
            min_size: default_min_size(),
            min_score: default_min_score(),
            resolution: default_resolution(),
        }
    }
}

impl LiveReachConfig {
    /// Validate the live reachability configuration
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        // Validate language
        if ![&amp;quot;auto&amp;quot;, &amp;quot;jvm&amp;quot;, &amp;quot;py&amp;quot;, &amp;quot;go&amp;quot;, &amp;quot;node&amp;quot;, &amp;quot;native&amp;quot;].contains(&amp;amp;self.ingest.lang.as_str()) {
            return Err(ValknutError::validation(
                format!(&amp;quot;Invalid language: {}&amp;quot;, self.ingest.lang)
            ));
        }
        
        // Validate build config
        if self.build.since_days &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;since_days must be greater than 0&amp;quot;));
        }
        
        if self.build.weight_static &amp;lt; 0.0 {
            return Err(ValknutError::validation(&amp;quot;weight_static must be non-negative&amp;quot;));
        }
        
        if self.build.island.min_size &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;min_size must be greater than 0&amp;quot;));
        }
        
        if self.build.island.min_score &amp;lt; 0.0 || self.build.island.min_score &amp;gt; 1.0 {
            return Err(ValknutError::validation(&amp;quot;min_score must be between 0.0 and 1.0&amp;quot;));
        }
        
        if self.build.island.resolution &amp;lt;&#x3D; 0.0 {
            return Err(ValknutError::validation(&amp;quot;resolution must be positive&amp;quot;));
        }
        
        Ok(())
    }
}

/// Enhanced duplicate detection configuration with adaptive features
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DedupeConfig {
    /// File patterns to include in dedupe analysis
    pub include: Vec&amp;lt;String&amp;gt;,
    
    /// File patterns to exclude from dedupe analysis
    pub exclude: Vec&amp;lt;String&amp;gt;,
    
    /// Minimum number of function tokens to consider
    pub min_function_tokens: usize,
    
    /// Minimum number of AST nodes to consider
    pub min_ast_nodes: usize,
    
    /// Minimum number of matching tokens for a duplicate
    pub min_match_tokens: usize,
    
    /// Minimum coverage ratio for matches
    pub min_match_coverage: f64,
    
    /// Shingle size for k-shingles (8-10 for TF-IDF analysis)
    pub shingle_k: usize,
    
    /// Require distinct blocks for meaningful matches (‚â•2 basic blocks)
    pub require_distinct_blocks: usize,
    
    /// Feature weights for multi-dimensional similarity
    pub weights: DedupeWeights,
    
    /// I/O signature mismatch penalty
    pub io_mismatch_penalty: f64,
    
    /// Final similarity threshold
    pub threshold_s: f64,
    
    /// String patterns for boilerplate detection (used with tree-sitter AST analysis)
    pub stop_phrases: Vec&amp;lt;String&amp;gt;,
    
    /// Ranking criteria for duplicates
    pub rank_by: RankingCriteria,
    
    /// Minimum saved tokens to report
    pub min_saved_tokens: usize,
    
    /// Keep top N duplicates per file
    pub keep_top_per_file: usize,
    
    /// Adaptive denoising configuration
    #[serde(default)]
    pub adaptive: AdaptiveDenoiseConfig,
}

/// Clone denoising configuration for reducing noise in clone detection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DenoiseConfig {
    /// Enable clone denoising system (default: true)
    pub enabled: bool,
    
    /// Enable automatic threshold calibration and denoising (default: true)
    pub auto: bool,
    
    /// Core thresholds (user-configurable)
    /// Minimum number of function tokens to consider (40+ recommended)
    pub min_function_tokens: usize,
    
    /// Minimum number of matching tokens for a duplicate (24+ recommended) 
    pub min_match_tokens: usize,
    
    /// Require minimum distinct blocks for meaningful matches (‚â•2 basic blocks)
    pub require_blocks: usize,
    
    /// Final similarity threshold for clone detection (0.0-1.0)
    pub similarity: f64,
    
    /// Advanced settings
    /// Feature weights for multi-dimensional similarity
    pub weights: DenoiseWeights,
    
    /// I/O signature mismatch penalty
    pub io_mismatch_penalty: f64,
    
    /// Final similarity threshold (alias for similarity)
    pub threshold_s: f64,
    
    /// Stop motifs configuration (AST-based boilerplate filtering)
    pub stop_motifs: StopMotifsConfig,
    
    /// Auto-calibration configuration
    pub auto_calibration: AutoCalibrationConfig,
    
    /// Payoff ranking configuration
    pub ranking: RankingConfig,
    
    /// Enable dry-run mode (analyze but don&amp;#x27;t change behavior)
    pub dry_run: bool,
}

/// Feature weights for denoising multi-dimensional similarity
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DenoiseWeights {
    /// AST similarity weight
    pub ast: f64,
    
    /// Program dependence graph weight  
    pub pdg: f64,
    
    /// Embedding similarity weight
    pub emb: f64,
}

impl Default for DenoiseWeights {
    fn default() -&amp;gt; Self {
        Self {
            ast: 0.35,
            pdg: 0.45,
            emb: 0.20,
        }
    }
}

/// Stop motifs configuration for AST-based boilerplate filtering
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StopMotifsConfig {
    /// Enable stop motifs filtering
    pub enabled: bool,
    
    /// Top percentile of patterns marked as boilerplate (0.0-1.0)
    pub percentile: f64,
    
    /// Cache refresh interval in days
    pub refresh_days: i64,
}

impl Default for StopMotifsConfig {
    fn default() -&amp;gt; Self {
        Self {
            enabled: true,
            percentile: 0.5, // Top 0.5% patterns marked as boilerplate
            refresh_days: 7,
        }
    }
}

/// Auto-calibration configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AutoCalibrationConfig {
    /// Enable auto-calibration
    pub enabled: bool,
    
    /// Quality target (percentage of candidates that must meet quality)
    pub quality_target: f64,
    
    /// Sample size for calibration (top N candidates)
    pub sample_size: usize,
    
    /// Maximum binary search iterations
    pub max_iterations: usize,
}

impl Default for AutoCalibrationConfig {
    fn default() -&amp;gt; Self {
        Self {
            enabled: true,
            quality_target: 0.8, // 80% of candidates must meet quality
            sample_size: 200,    // Top 200 candidates for calibration
            max_iterations: 50,  // Binary search limit
        }
    }
}

/// Payoff ranking configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RankingConfig {
    /// Ranking criteria
    pub by: RankingBy,
    
    /// Minimum saved tokens to report
    pub min_saved_tokens: usize,
    
    /// Minimum rarity gain threshold
    pub min_rarity_gain: f64,
    
    /// Use live reachability data if available
    pub live_reach_boost: bool,
}

/// Ranking criteria options
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all &#x3D; &amp;quot;snake_case&amp;quot;)]
pub enum RankingBy {
    /// Rank by potential token savings
    SavedTokens,
    
    /// Rank by frequency/occurrence count
    Frequency,
}

impl Default for RankingConfig {
    fn default() -&amp;gt; Self {
        Self {
            by: RankingBy::SavedTokens,
            min_saved_tokens: 100,
            min_rarity_gain: 1.2,
            live_reach_boost: true,
        }
    }
}

impl Default for DenoiseConfig {
    fn default() -&amp;gt; Self {
        Self {
            enabled: true,           // Default enabled
            auto: true,              // Default auto-calibration enabled
            min_function_tokens: 40,
            min_match_tokens: 24,
            require_blocks: 2,
            similarity: 0.82,
            weights: DenoiseWeights::default(),
            io_mismatch_penalty: 0.25,
            threshold_s: 0.82,       // Alias for similarity
            stop_motifs: StopMotifsConfig::default(),
            auto_calibration: AutoCalibrationConfig::default(),
            ranking: RankingConfig::default(),
            dry_run: false,
        }
    }
}

impl DenoiseConfig {
    /// Validate denoise configuration
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        if self.min_function_tokens &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;min_function_tokens must be greater than 0&amp;quot;));
        }
        
        if self.min_match_tokens &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;min_match_tokens must be greater than 0&amp;quot;));
        }
        
        if self.require_blocks &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;require_blocks must be greater than 0&amp;quot;));
        }
        
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.similarity) {
            return Err(ValknutError::validation(&amp;quot;similarity must be between 0.0 and 1.0&amp;quot;));
        }
        
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.threshold_s) {
            return Err(ValknutError::validation(&amp;quot;threshold_s must be between 0.0 and 1.0&amp;quot;));
        }
        
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.io_mismatch_penalty) {
            return Err(ValknutError::validation(&amp;quot;io_mismatch_penalty must be between 0.0 and 1.0&amp;quot;));
        }
        
        // Validate weights sum to approximately 1.0
        let weight_sum &#x3D; self.weights.ast + self.weights.pdg + self.weights.emb;
        if (weight_sum - 1.0).abs() &amp;gt; 0.1 {
            return Err(ValknutError::validation(&amp;quot;denoise weights should sum to approximately 1.0&amp;quot;));
        }
        
        // Validate individual weights are non-negative
        if self.weights.ast &amp;lt; 0.0 || self.weights.pdg &amp;lt; 0.0 || self.weights.emb &amp;lt; 0.0 {
            return Err(ValknutError::validation(&amp;quot;denoise weights must be non-negative&amp;quot;));
        }
        
        // Validate stop motifs config
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.stop_motifs.percentile) {
            return Err(ValknutError::validation(&amp;quot;stop_motifs.percentile must be between 0.0 and 1.0&amp;quot;));
        }
        
        if self.stop_motifs.refresh_days &amp;lt;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;stop_motifs.refresh_days must be greater than 0&amp;quot;));
        }
        
        // Validate auto-calibration config
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.auto_calibration.quality_target) {
            return Err(ValknutError::validation(&amp;quot;auto_calibration.quality_target must be between 0.0 and 1.0&amp;quot;));
        }
        
        if self.auto_calibration.sample_size &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;auto_calibration.sample_size must be greater than 0&amp;quot;));
        }
        
        if self.auto_calibration.max_iterations &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;auto_calibration.max_iterations must be greater than 0&amp;quot;));
        }
        
        // Validate ranking config
        if self.ranking.min_saved_tokens &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;ranking.min_saved_tokens must be greater than 0&amp;quot;));
        }
        
        if self.ranking.min_rarity_gain &amp;lt;&#x3D; 0.0 {
            return Err(ValknutError::validation(&amp;quot;ranking.min_rarity_gain must be greater than 0.0&amp;quot;));
        }
        
        Ok(())
    }
}

/// Feature weights for multi-dimensional duplicate detection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DedupeWeights {
    /// AST similarity weight
    pub ast: f64,
    
    /// Program dependence graph weight  
    pub pdg: f64,
    
    /// Embedding similarity weight
    pub emb: f64,
}

/// Ranking criteria for duplicates
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all &#x3D; &amp;quot;snake_case&amp;quot;)]
pub enum RankingCriteria {
    /// Rank by potential token savings
    SavedTokens,
    
    /// Rank by similarity score
    Similarity,
    
    /// Rank by both similarity and savings
    Combined,
}

/// Adaptive denoising configuration for intelligent clone detection
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AdaptiveDenoiseConfig {
    /// Enable automatic denoising with threshold tuning
    pub auto_denoise: bool,
    
    /// Enable adaptive learning of boilerplate patterns
    pub adaptive_learning: bool,
    
    /// Enable TF-IDF rarity weighting for structural analysis
    pub rarity_weighting: bool,
    
    /// Enable structural validation (PDG motifs, basic blocks)
    pub structural_validation: bool,
    
    /// Enable live reachability boost integration
    pub live_reach_integration: bool,
    
    /// Stop motif percentile threshold (0.0-1.0, e.g., 0.75 &#x3D; top 0.75%)
    pub stop_motif_percentile: f64,
    
    /// Hub suppression threshold (0.0-1.0, patterns in &amp;gt;60% of files)
    pub hub_suppression_threshold: f64,
    
    /// Quality gate percentage (0.0-1.0, 80% of candidates must meet quality)
    pub quality_gate_percentage: f64,
    
    /// TF-IDF k-gram size for structural analysis
    pub tfidf_kgram_size: usize,
    
    /// Weisfeiler-Lehman hash iterations for PDG motifs
    pub wl_iterations: usize,
    
    /// Minimum rarity gain threshold
    pub min_rarity_gain: f64,
    
    /// External call Jaccard similarity penalty threshold
    pub external_call_jaccard_threshold: f64,
    
    /// Cache refresh interval in days
    pub cache_refresh_days: i64,
    
    /// Enable automatic cache refresh
    pub auto_refresh_cache: bool,
}

impl Default for AdaptiveDenoiseConfig {
    fn default() -&amp;gt; Self {
        Self {
            auto_denoise: true,
            adaptive_learning: true,
            rarity_weighting: true,
            structural_validation: true,
            live_reach_integration: true,
            stop_motif_percentile: 0.75,
            hub_suppression_threshold: 0.6,
            quality_gate_percentage: 0.8,
            tfidf_kgram_size: 8,
            wl_iterations: 3,
            min_rarity_gain: 1.2,
            external_call_jaccard_threshold: 0.2,
            cache_refresh_days: 7,
            auto_refresh_cache: true,
        }
    }
}

impl Default for DedupeConfig {
    fn default() -&amp;gt; Self {
        Self {
            include: vec![&amp;quot;src/**&amp;quot;.to_string()],
            exclude: vec![
                &amp;quot;benches/**&amp;quot;.to_string(),
                &amp;quot;examples/**&amp;quot;.to_string(),
                &amp;quot;datasets/**&amp;quot;.to_string(),
                &amp;quot;**/generated/**&amp;quot;.to_string(),
                &amp;quot;**/*.pb.rs&amp;quot;.to_string(),
            ],
            min_function_tokens: 40,
            min_ast_nodes: 35,
            min_match_tokens: 24,
            min_match_coverage: 0.40,
            shingle_k: 9,
            require_distinct_blocks: 2,
            weights: DedupeWeights::default(),
            io_mismatch_penalty: 0.25,
            threshold_s: 0.82,
            stop_phrases: vec![
                r&amp;quot;^\s*@staticmethod\b&amp;quot;.to_string(),
                r&amp;quot;group\.bench_with_input\s*\(&amp;quot;.to_string(),
                r&amp;quot;\bb\.iter\s*\(\|\|&amp;quot;.to_string(),
                r&amp;quot;\bgroup\.finish\s*\(\)\s*;?&amp;quot;.to_string(),
                r&amp;quot;\blet\s+config\s*&#x3D;\s*AnalysisConfig::(new|default)\s*\(\)\s*;?&amp;quot;.to_string(),
                r&amp;quot;\bchecks\.push\s*\(\s*HealthCheck\s*\{&amp;quot;.to_string(),
            ],
            rank_by: RankingCriteria::SavedTokens,
            min_saved_tokens: 100,
            keep_top_per_file: 3,
            adaptive: AdaptiveDenoiseConfig::default(),
        }
    }
}

impl Default for DedupeWeights {
    fn default() -&amp;gt; Self {
        Self {
            ast: 0.35,
            pdg: 0.45,
            emb: 0.20,
        }
    }
}

impl DedupeConfig {
    /// Validate dedupe configuration
    pub fn validate(&amp;amp;self) -&amp;gt; Result&amp;lt;()&amp;gt; {
        if self.min_function_tokens &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;min_function_tokens must be greater than 0&amp;quot;));
        }
        
        if self.min_ast_nodes &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;min_ast_nodes must be greater than 0&amp;quot;));
        }
        
        if self.min_match_tokens &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;min_match_tokens must be greater than 0&amp;quot;));
        }
        
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.min_match_coverage) {
            return Err(ValknutError::validation(&amp;quot;min_match_coverage must be between 0.0 and 1.0&amp;quot;));
        }
        
        if self.shingle_k &#x3D;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;shingle_k must be greater than 0&amp;quot;));
        }
        
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.io_mismatch_penalty) {
            return Err(ValknutError::validation(&amp;quot;io_mismatch_penalty must be between 0.0 and 1.0&amp;quot;));
        }
        
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.threshold_s) {
            return Err(ValknutError::validation(&amp;quot;threshold_s must be between 0.0 and 1.0&amp;quot;));
        }
        
        // Validate weights sum to reasonable values
        let weight_sum &#x3D; self.weights.ast + self.weights.pdg + self.weights.emb;
        if (weight_sum - 1.0).abs() &amp;gt; 0.1 {
            return Err(ValknutError::validation(&amp;quot;weights should sum to approximately 1.0&amp;quot;));
        }
        
        // Validate patterns (simplified - no regex validation)
        for pattern in &amp;amp;self.stop_phrases {
            if pattern.is_empty() {
                return Err(ValknutError::validation(&amp;quot;Empty pattern in stop_phrases&amp;quot;.to_string()));
            }
        }
        
        // Validate adaptive denoising configuration
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.adaptive.stop_motif_percentile) {
            return Err(ValknutError::validation(&amp;quot;adaptive.stop_motif_percentile must be between 0.0 and 1.0&amp;quot;));
        }
        
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.adaptive.hub_suppression_threshold) {
            return Err(ValknutError::validation(&amp;quot;adaptive.hub_suppression_threshold must be between 0.0 and 1.0&amp;quot;));
        }
        
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.adaptive.quality_gate_percentage) {
            return Err(ValknutError::validation(&amp;quot;adaptive.quality_gate_percentage must be between 0.0 and 1.0&amp;quot;));
        }
        
        if self.adaptive.tfidf_kgram_size &#x3D;&#x3D; 0 || self.adaptive.tfidf_kgram_size &amp;gt; 20 {
            return Err(ValknutError::validation(&amp;quot;adaptive.tfidf_kgram_size must be between 1 and 20&amp;quot;));
        }
        
        if self.adaptive.wl_iterations &#x3D;&#x3D; 0 || self.adaptive.wl_iterations &amp;gt; 10 {
            return Err(ValknutError::validation(&amp;quot;adaptive.wl_iterations must be between 1 and 10&amp;quot;));
        }
        
        if self.adaptive.min_rarity_gain &amp;lt;&#x3D; 0.0 {
            return Err(ValknutError::validation(&amp;quot;adaptive.min_rarity_gain must be greater than 0.0&amp;quot;));
        }
        
        if !(0.0..&#x3D;1.0).contains(&amp;amp;self.adaptive.external_call_jaccard_threshold) {
            return Err(ValknutError::validation(&amp;quot;adaptive.external_call_jaccard_threshold must be between 0.0 and 1.0&amp;quot;));
        }
        
        if self.adaptive.cache_refresh_days &amp;lt;&#x3D; 0 {
            return Err(ValknutError::validation(&amp;quot;adaptive.cache_refresh_days must be greater than 0&amp;quot;));
        }
        
        Ok(())
    }
}</pre>
                </div>
            </div>
            <div class="file-section" id="file-44">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>src/core/pipeline/pipeline_config.rs</div>
                <div class="file-content">
                    <pre>//! Configuration types and defaults for the analysis pipeline.

use std::path::PathBuf;
use serde::{Deserialize, Serialize};

use crate::core::config::ValknutConfig;

/// Configuration for comprehensive analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisConfig {
    /// Enable structure analysis
    pub enable_structure_analysis: bool,
    /// Enable complexity analysis
    pub enable_complexity_analysis: bool,
    /// Enable refactoring analysis
    pub enable_refactoring_analysis: bool,
    /// Enable impact analysis
    pub enable_impact_analysis: bool,
    /// Enable LSH-based clone detection
    pub enable_lsh_analysis: bool,
    /// Enable coverage analysis
    pub enable_coverage_analysis: bool,
    /// File extensions to include
    pub file_extensions: Vec&amp;lt;String&amp;gt;,
    /// Directories to exclude
    pub exclude_directories: Vec&amp;lt;String&amp;gt;,
    /// Maximum files to analyze (0 &#x3D; no limit)
    pub max_files: usize,
}

impl Default for AnalysisConfig {
    fn default() -&amp;gt; Self {
        Self {
            enable_structure_analysis: true,
            enable_complexity_analysis: true,
            enable_refactoring_analysis: true,
            enable_impact_analysis: true,
            enable_lsh_analysis: false, // Disabled by default
            enable_coverage_analysis: true, // Enabled by default for comprehensive analysis
            file_extensions: vec![
                &amp;quot;py&amp;quot;.to_string(),
                &amp;quot;js&amp;quot;.to_string(),
                &amp;quot;ts&amp;quot;.to_string(),
                &amp;quot;tsx&amp;quot;.to_string(),
                &amp;quot;jsx&amp;quot;.to_string(),
                &amp;quot;rs&amp;quot;.to_string(),
                &amp;quot;go&amp;quot;.to_string(),
                &amp;quot;java&amp;quot;.to_string(),
            ],
            exclude_directories: vec![
                &amp;quot;node_modules&amp;quot;.to_string(),
                &amp;quot;target&amp;quot;.to_string(),
                &amp;quot;__pycache__&amp;quot;.to_string(),
                &amp;quot;.git&amp;quot;.to_string(),
                &amp;quot;dist&amp;quot;.to_string(),
                &amp;quot;build&amp;quot;.to_string(),
            ],
            max_files: 5000,
        }
    }
}

impl From&amp;lt;ValknutConfig&amp;gt; for AnalysisConfig {
    fn from(config: ValknutConfig) -&amp;gt; Self {
        // Convert exclude patterns to directories - extract directory names from patterns
        let exclude_directories: Vec&amp;lt;String&amp;gt; &#x3D; config.analysis.exclude_patterns
            .into_iter()
            .filter_map(|pattern| {
                // Extract directory names from patterns like &amp;quot;*/node_modules/*&amp;quot; -&amp;gt; &amp;quot;node_modules&amp;quot;
                if pattern.contains(&amp;#x27;/&amp;#x27;) {
                    let trimmed &#x3D; pattern.trim_start_matches(&amp;quot;*/&amp;quot;).trim_end_matches(&amp;quot;/*&amp;quot;);
                    if !trimmed.is_empty() &amp;amp;&amp;amp; !trimmed.contains(&amp;#x27;*&amp;#x27;) {
                        Some(trimmed.to_string())
                    } else {
                        None
                    }
                } else {
                    None
                }
            })
            .collect();
        
        // Derive file extensions from language config
        let file_extensions: Vec&amp;lt;String&amp;gt; &#x3D; config.languages
            .values()
            .filter(|lang| lang.enabled)
            .flat_map(|lang| lang.file_extensions.clone())
            .map(|ext| ext.trim_start_matches(&amp;#x27;.&amp;#x27;).to_string()) // Remove leading dots
            .collect();
            
        let final_file_extensions &#x3D; if file_extensions.is_empty() {
            vec![
                &amp;quot;py&amp;quot;.to_string(),
                &amp;quot;js&amp;quot;.to_string(),
                &amp;quot;ts&amp;quot;.to_string(),
                &amp;quot;tsx&amp;quot;.to_string(),
                &amp;quot;jsx&amp;quot;.to_string(),
                &amp;quot;rs&amp;quot;.to_string(),
                &amp;quot;go&amp;quot;.to_string(),
                &amp;quot;java&amp;quot;.to_string(),
            ]
        } else {
            file_extensions
        };
        
        let final_exclude_directories &#x3D; if exclude_directories.is_empty() {
            vec![
                &amp;quot;node_modules&amp;quot;.to_string(),
                &amp;quot;target&amp;quot;.to_string(),
                &amp;quot;__pycache__&amp;quot;.to_string(),
                &amp;quot;.git&amp;quot;.to_string(),
                &amp;quot;dist&amp;quot;.to_string(),
                &amp;quot;build&amp;quot;.to_string(),
            ]
        } else {
            exclude_directories
        };
        
        Self {
            enable_structure_analysis: config.analysis.enable_structure_analysis,
            enable_complexity_analysis: true, // Default enabled, no equivalent in core config
            enable_refactoring_analysis: config.analysis.enable_refactoring_analysis,
            enable_impact_analysis: config.analysis.enable_graph_analysis, // Map graph analysis to impact analysis
            enable_lsh_analysis: config.analysis.enable_lsh_analysis,
            enable_coverage_analysis: config.analysis.enable_coverage_analysis,
            file_extensions: final_file_extensions,
            exclude_directories: final_exclude_directories,
            max_files: config.analysis.max_files,
        }
    }
}

/// Quality gate configuration for CI/CD integration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QualityGateConfig {
    /// Whether quality gates are enabled
    pub enabled: bool,
    /// Maximum allowed complexity score (0-100, lower is better)
    pub max_complexity_score: f64,
    /// Maximum allowed technical debt ratio (0-100, lower is better)
    pub max_technical_debt_ratio: f64,
    /// Minimum required maintainability score (0-100, higher is better)
    pub min_maintainability_score: f64,
    /// Maximum allowed critical issues
    pub max_critical_issues: usize,
    /// Maximum allowed high-priority issues
    pub max_high_priority_issues: usize,
}

impl Default for QualityGateConfig {
    fn default() -&amp;gt; Self {
        Self {
            enabled: false,
            max_complexity_score: 70.0,
            max_technical_debt_ratio: 50.0,
            min_maintainability_score: 60.0,
            max_critical_issues: 5,
            max_high_priority_issues: 20,
        }
    }
}

/// Quality gate violation details
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QualityGateViolation {
    /// Name of the violated rule
    pub rule_name: String,
    /// Description of the violation
    pub description: String,
    /// Current value that violated the threshold
    pub current_value: f64,
    /// The threshold that was violated
    pub threshold: f64,
    /// Severity of the violation
    pub severity: String,
    /// Files or components that contribute to this violation
    pub affected_files: Vec&amp;lt;PathBuf&amp;gt;,
    /// Recommended actions to fix this violation
    pub recommended_actions: Vec&amp;lt;String&amp;gt;,
}

/// Result of quality gate evaluation
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QualityGateResult {
    /// Whether all quality gates passed
    pub passed: bool,
    /// List of violations (empty if all gates passed)
    pub violations: Vec&amp;lt;QualityGateViolation&amp;gt;,
    /// Overall quality score
    pub overall_score: f64,
}</pre>
                </div>
            </div>
            <div class="file-section" id="file-45">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/@types/yargs/helpers.d.mts</div>
                <div class="file-content">
                    <pre>export * from &amp;quot;./helpers.js&amp;quot;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-46">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>src/detectors/structure/directory.rs</div>
                <div class="file-content">
                    <pre>//! Directory analysis, graph partitioning, and reorganization logic

use std::collections::{HashMap, HashSet};
use std::path::{Path, PathBuf};
use petgraph::graph::NodeIndex;
use petgraph::visit::EdgeRef;
use rayon::prelude::*;
use dashmap::DashMap;

use crate::core::errors::{Result, ValknutError};
use crate::core::file_utils::FileReader;

use super::config::{
    StructureConfig, DirectoryMetrics, BranchReorgPack, DirectoryPartition, 
    ReorganizationGain, ReorganizationEffort, FileMove, DependencyGraph, 
    FileNode, DependencyEdge, ImportStatement
};

pub struct DirectoryAnalyzer {
    config: StructureConfig,
    metrics_cache: DashMap&amp;lt;PathBuf, DirectoryMetrics&amp;gt;,
}

impl DirectoryAnalyzer {
    pub fn new(config: StructureConfig) -&amp;gt; Self {
        Self {
            config,
            metrics_cache: DashMap::new(),
        }
    }

    /// Calculate directory metrics
    pub fn calculate_directory_metrics(&amp;amp;self, dir_path: &amp;amp;Path) -&amp;gt; Result&amp;lt;DirectoryMetrics&amp;gt; {
        // Check cache first
        if let Some(cached) &#x3D; self.metrics_cache.get(dir_path) {
            return Ok(cached.clone());
        }

        let (files, subdirs, loc_distribution) &#x3D; self.gather_directory_stats(dir_path)?;
        let total_loc &#x3D; loc_distribution.iter().sum::&amp;lt;usize&amp;gt;();
        
        // Calculate dispersion metrics
        let gini &#x3D; self.calculate_gini_coefficient(&amp;amp;loc_distribution);
        let entropy &#x3D; self.calculate_entropy(&amp;amp;loc_distribution);
        
        // Calculate pressure metrics (clipped to [0,1])
        let file_pressure &#x3D; (files as f64 / self.config.fsdir.max_files_per_dir as f64).min(1.0);
        let branch_pressure &#x3D; (subdirs as f64 / self.config.fsdir.max_subdirs_per_dir as f64).min(1.0);
        let size_pressure &#x3D; (total_loc as f64 / self.config.fsdir.max_dir_loc as f64).min(1.0);
        
        // Calculate dispersion combining gini and entropy
        let max_entropy &#x3D; if files &amp;gt; 0 { (files as f64).log2() } else { 1.0 };
        let normalized_entropy &#x3D; if max_entropy &amp;gt; 0.0 { entropy / max_entropy } else { 0.0 };
        let dispersion &#x3D; gini.max(1.0 - normalized_entropy);
        
        // Apply size normalization to prevent bias against larger codebases
        let size_normalization_factor &#x3D; self.calculate_size_normalization_factor(files, total_loc);
        
        // Calculate overall imbalance score with normalization
        let raw_imbalance &#x3D; 0.35 * file_pressure + 
                           0.25 * branch_pressure + 
                           0.25 * size_pressure + 
                           0.15 * dispersion;
        
        let imbalance &#x3D; raw_imbalance * size_normalization_factor;
        
        let metrics &#x3D; DirectoryMetrics {
            files,
            subdirs,
            loc: total_loc,
            gini,
            entropy,
            file_pressure,
            branch_pressure,
            size_pressure,
            dispersion,
            imbalance,
        };
        
        // Cache the result
        self.metrics_cache.insert(dir_path.to_path_buf(), metrics.clone());
        
        Ok(metrics)
    }

    /// Gather basic directory statistics
    fn gather_directory_stats(&amp;amp;self, dir_path: &amp;amp;Path) -&amp;gt; Result&amp;lt;(usize, usize, Vec&amp;lt;usize&amp;gt;)&amp;gt; {
        let mut files &#x3D; 0;
        let mut subdirs &#x3D; 0;
        let mut loc_distribution &#x3D; Vec::new();
        
        for entry in std::fs::read_dir(dir_path)? {
            let entry &#x3D; entry?;
            let path &#x3D; entry.path();
            
            if path.is_dir() {
                subdirs +&#x3D; 1;
            } else if path.is_file() {
                if let Some(ext) &#x3D; path.extension().and_then(|e| e.to_str()) {
                    if self.is_code_file(ext) {
                        files +&#x3D; 1;
                        let loc &#x3D; self.count_lines_of_code(&amp;amp;path)?;
                        loc_distribution.push(loc);
                    }
                }
            }
        }
        
        Ok((files, subdirs, loc_distribution))
    }

    /// Check if file extension indicates a code file
    fn is_code_file(&amp;amp;self, extension: &amp;amp;str) -&amp;gt; bool {
        matches!(extension, &amp;quot;py&amp;quot; | &amp;quot;js&amp;quot; | &amp;quot;ts&amp;quot; | &amp;quot;jsx&amp;quot; | &amp;quot;tsx&amp;quot; | &amp;quot;rs&amp;quot; | &amp;quot;go&amp;quot; | &amp;quot;java&amp;quot; | &amp;quot;cpp&amp;quot; | &amp;quot;c&amp;quot; | &amp;quot;h&amp;quot; | &amp;quot;hpp&amp;quot;)
    }

    /// Count lines of code in a file
    fn count_lines_of_code(&amp;amp;self, file_path: &amp;amp;Path) -&amp;gt; Result&amp;lt;usize&amp;gt; {
        let content &#x3D; FileReader::read_to_string(file_path)?;
        Ok(content.lines().filter(|line| !line.trim().is_empty() &amp;amp;&amp;amp; !line.trim().starts_with(&amp;quot;//&amp;quot;)).count())
    }

    /// Calculate Gini coefficient for LOC distribution with SIMD optimization
    pub fn calculate_gini_coefficient(&amp;amp;self, values: &amp;amp;[usize]) -&amp;gt; f64 {
        if values.len() &amp;lt;&#x3D; 1 {
            return 0.0;
        }

        let n &#x3D; values.len() as f64;
        let sum: usize &#x3D; values.iter().sum();
        
        if sum &#x3D;&#x3D; 0 {
            return 0.0;
        }

        // For small arrays, use the standard algorithm
        if values.len() &amp;lt; 32 {
            let mut sum_diff &#x3D; 0.0;
            for i in 0..values.len() {
                for j in 0..values.len() {
                    sum_diff +&#x3D; (values[i] as i64 - values[j] as i64).abs() as f64;
                }
            }
            return sum_diff / (2.0 * n * sum as f64);
        }

        // For larger arrays, use optimized parallel computation
        let sum_diff: f64 &#x3D; values.par_iter()
            .enumerate()
            .map(|(_, &amp;amp;val_i)| {
                values.iter()
                    .map(|&amp;amp;val_j| (val_i as i64 - val_j as i64).abs() as f64)
                    .sum::&amp;lt;f64&amp;gt;()
            })
            .sum();

        sum_diff / (2.0 * n * sum as f64)
    }

    /// Calculate entropy for LOC distribution with parallel optimization
    pub fn calculate_entropy(&amp;amp;self, values: &amp;amp;[usize]) -&amp;gt; f64 {
        if values.is_empty() {
            return 0.0;
        }

        let total: usize &#x3D; values.iter().sum();
        if total &#x3D;&#x3D; 0 {
            return 0.0;
        }

        // For small arrays, use sequential computation
        if values.len() &amp;lt; 100 {
            return values.iter()
                .filter(|&amp;amp;&amp;amp;x| x &amp;gt; 0)
                .map(|&amp;amp;x| {
                    let p &#x3D; x as f64 / total as f64;
                    -p * p.log2()
                })
                .sum();
        }

        // For larger arrays, use parallel computation
        let total_f64 &#x3D; total as f64;
        values.par_iter()
            .filter(|&amp;amp;&amp;amp;x| x &amp;gt; 0)
            .map(|&amp;amp;x| {
                let p &#x3D; x as f64 / total_f64;
                -p * p.log2()
            })
            .sum()
    }

    /// Analyze directory for reorganization potential
    pub fn analyze_directory_for_reorg(&amp;amp;self, dir_path: &amp;amp;Path) -&amp;gt; Result&amp;lt;Option&amp;lt;BranchReorgPack&amp;gt;&amp;gt; {
        let metrics &#x3D; self.calculate_directory_metrics(dir_path)?;
        
        // Check if directory meets threshold for consideration
        if metrics.imbalance &amp;lt; 0.6 {
            return Ok(None);
        }
        
        // Additional conditions
        let meets_conditions &#x3D; metrics.files &amp;gt; self.config.fsdir.max_files_per_dir ||
                              metrics.loc &amp;gt; self.config.fsdir.max_dir_loc ||
                              metrics.dispersion &amp;gt;&#x3D; 0.5;
        
        if !meets_conditions {
            return Ok(None);
        }

        // Skip small directories
        if metrics.files &amp;lt;&#x3D; 5 &amp;amp;&amp;amp; metrics.loc &amp;lt;&#x3D; 600 {
            return Ok(None);
        }

        // Build dependency graph and partition
        let dependency_graph &#x3D; self.build_dependency_graph(dir_path)?;
        let partitions &#x3D; self.partition_directory(&amp;amp;dependency_graph, &amp;amp;metrics)?;
        
        if partitions.is_empty() {
            return Ok(None);
        }

        // Calculate expected gains
        let gain &#x3D; self.calculate_reorganization_gain(&amp;amp;metrics, &amp;amp;partitions, dir_path)?;
        
        if gain.imbalance_delta &amp;lt; self.config.fsdir.min_branch_recommendation_gain {
            return Ok(None);
        }

        // Calculate effort estimation and file moves
        let effort &#x3D; self.calculate_reorganization_effort(&amp;amp;partitions, dir_path)?;
        let file_moves &#x3D; self.generate_file_moves(&amp;amp;partitions, dir_path)?;

        let pack &#x3D; BranchReorgPack {
            kind: &amp;quot;branch_reorg&amp;quot;.to_string(),
            dir: dir_path.to_path_buf(),
            current: metrics,
            proposal: partitions,
            file_moves,
            gain,
            effort,
            rules: self.generate_reorganization_rules(dir_path),
        };

        Ok(Some(pack))
    }

    /// Build internal dependency graph for directory
    pub fn build_dependency_graph(&amp;amp;self, dir_path: &amp;amp;Path) -&amp;gt; Result&amp;lt;DependencyGraph&amp;gt; {
        let mut graph &#x3D; petgraph::Graph::new();
        let mut path_to_node: HashMap&amp;lt;PathBuf, NodeIndex&amp;gt; &#x3D; HashMap::new();
        
        // First pass: create nodes for all code files in directory
        for entry in std::fs::read_dir(dir_path)? {
            let entry &#x3D; entry?;
            let file_path &#x3D; entry.path();
            
            if file_path.is_file() {
                if let Some(ext) &#x3D; file_path.extension().and_then(|e| e.to_str()) {
                    if self.is_code_file(ext) {
                        let loc &#x3D; self.count_lines_of_code(&amp;amp;file_path)?;
                        let metadata &#x3D; std::fs::metadata(&amp;amp;file_path)?;
                        
                        let file_node &#x3D; FileNode {
                            path: file_path.clone(),
                            loc,
                            size_bytes: metadata.len() as usize,
                        };
                        
                        let node_idx &#x3D; graph.add_node(file_node);
                        path_to_node.insert(file_path, node_idx);
                    }
                }
            }
        }
        
        // Second pass: analyze imports and create edges
        for (file_path, &amp;amp;source_node) in &amp;amp;path_to_node {
            if let Ok(imports) &#x3D; self.extract_imports(file_path) {
                for import in imports {
                    // Resolve import to file path within the same directory
                    if let Some(target_path) &#x3D; self.resolve_import_to_local_file(&amp;amp;import, dir_path) {
                        if let Some(&amp;amp;target_node) &#x3D; path_to_node.get(&amp;amp;target_path) {
                            // Add edge from source to target with weight based on import frequency
                            let edge &#x3D; DependencyEdge {
                                weight: 1, // Could be enhanced to count import usage frequency
                                relationship_type: import.import_type,
                            };
                            
                            graph.add_edge(source_node, target_node, edge);
                        }
                    }
                }
            }
        }
        
        Ok(graph)
    }

    /// Partition directory using graph algorithms
    pub fn partition_directory(&amp;amp;self, graph: &amp;amp;DependencyGraph, metrics: &amp;amp;DirectoryMetrics) -&amp;gt; Result&amp;lt;Vec&amp;lt;DirectoryPartition&amp;gt;&amp;gt; {
        if graph.node_count() &#x3D;&#x3D; 0 {
            return Ok(Vec::new());
        }

        // Calculate optimal number of clusters
        let target_loc_per_subdir &#x3D; self.config.fsdir.target_loc_per_subdir;
        let k &#x3D; ((metrics.loc as f64 / target_loc_per_subdir as f64).round() as usize)
            .clamp(2, self.config.partitioning.max_clusters);

        let node_indices: Vec&amp;lt;_&amp;gt; &#x3D; graph.node_indices().collect();
        
        // Use different algorithms based on graph size
        let communities &#x3D; if node_indices.len() &amp;lt;&#x3D; 8 {
            // Brute force optimal bipartition for small graphs
            self.brute_force_partition(&amp;amp;node_indices, graph, k)?
        } else {
            // Use label propagation followed by Kernighan-Lin refinement
            let initial_communities &#x3D; self.label_propagation_partition(graph)?;
            self.refine_partition_with_kl(graph, initial_communities, k)?
        };

        // Convert communities to directory partitions
        self.communities_to_partitions(graph, communities, k)
    }

    /// Brute force optimal partitioning for small graphs
    fn brute_force_partition(
        &amp;amp;self,
        nodes: &amp;amp;[NodeIndex],
        graph: &amp;amp;DependencyGraph,
        k: usize,
    ) -&amp;gt; Result&amp;lt;Vec&amp;lt;Vec&amp;lt;NodeIndex&amp;gt;&amp;gt;&amp;gt; {
        if k &#x3D;&#x3D; 2 &amp;amp;&amp;amp; nodes.len() &amp;lt;&#x3D; 8 {
            // Optimal bipartition using exhaustive search
            let best_partition &#x3D; self.find_optimal_bipartition(nodes, graph)?;
            Ok(vec![best_partition.0, best_partition.1])
        } else {
            // Fall back to simple random partitioning for larger k
            self.random_partition(nodes, k)
        }
    }

    /// Find optimal bipartition that minimizes cut and balances LOC
    fn find_optimal_bipartition(
        &amp;amp;self,
        nodes: &amp;amp;[NodeIndex],
        graph: &amp;amp;DependencyGraph,
    ) -&amp;gt; Result&amp;lt;(Vec&amp;lt;NodeIndex&amp;gt;, Vec&amp;lt;NodeIndex&amp;gt;)&amp;gt; {
        let n &#x3D; nodes.len();
        let mut best_cut &#x3D; usize::MAX;
        let mut best_balance &#x3D; f64::MAX;
        let mut best_partition &#x3D; (Vec::new(), Vec::new());

        // Try all possible bipartitions (2^n possibilities)
        for mask in 1..(1 &amp;lt;&amp;lt; n) - 1 {
            let mut part1 &#x3D; Vec::new();
            let mut part2 &#x3D; Vec::new();
            let mut loc1 &#x3D; 0;
            let mut loc2 &#x3D; 0;

            for i in 0..n {
                if mask &amp;amp; (1 &amp;lt;&amp;lt; i) !&#x3D; 0 {
                    part1.push(nodes[i]);
                    loc1 +&#x3D; graph.node_weight(nodes[i]).map(|n| n.loc).unwrap_or(0);
                } else {
                    part2.push(nodes[i]);
                    loc2 +&#x3D; graph.node_weight(nodes[i]).map(|n| n.loc).unwrap_or(0);
                }
            }

            // Calculate cut size and balance
            let cut_size &#x3D; self.calculate_cut_size(graph, &amp;amp;part1, &amp;amp;part2);
            let total_loc &#x3D; loc1 + loc2;
            let balance &#x3D; if total_loc &amp;gt; 0 {
                (loc1 as f64 / total_loc as f64 - 0.5).abs()
            } else {
                0.0
            };

            // Check if within balance tolerance
            if balance &amp;lt;&#x3D; self.config.partitioning.balance_tolerance {
                if cut_size &amp;lt; best_cut || (cut_size &#x3D;&#x3D; best_cut &amp;amp;&amp;amp; balance &amp;lt; best_balance) {
                    best_cut &#x3D; cut_size;
                    best_balance &#x3D; balance;
                    best_partition &#x3D; (part1, part2);
                }
            }
        }

        if best_partition.0.is_empty() {
            // If no balanced partition found, use simple split
            let mid &#x3D; n / 2;
            let part1 &#x3D; nodes[..mid].to_vec();
            let part2 &#x3D; nodes[mid..].to_vec();
            Ok((part1, part2))
        } else {
            Ok(best_partition)
        }
    }

    /// Calculate cut size between two partitions
    fn calculate_cut_size(
        &amp;amp;self,
        graph: &amp;amp;DependencyGraph,
        part1: &amp;amp;[NodeIndex],
        part2: &amp;amp;[NodeIndex],
    ) -&amp;gt; usize {
        let part1_set: HashSet&amp;lt;_&amp;gt; &#x3D; part1.iter().copied().collect();
        let part2_set: HashSet&amp;lt;_&amp;gt; &#x3D; part2.iter().copied().collect();
        
        let mut cut_size &#x3D; 0;
        
        for &amp;amp;node in part1 {
            for edge in graph.edges(node) {
                if part2_set.contains(&amp;amp;edge.target()) {
                    cut_size +&#x3D; edge.weight().weight;
                }
            }
        }
        
        cut_size
    }

    /// Random partition as fallback
    fn random_partition(&amp;amp;self, nodes: &amp;amp;[NodeIndex], k: usize) -&amp;gt; Result&amp;lt;Vec&amp;lt;Vec&amp;lt;NodeIndex&amp;gt;&amp;gt;&amp;gt; {
        let mut communities &#x3D; vec![Vec::new(); k];
        
        for (i, &amp;amp;node) in nodes.iter().enumerate() {
            communities[i % k].push(node);
        }
        
        Ok(communities)
    }

    /// Label propagation algorithm for community detection
    fn label_propagation_partition(&amp;amp;self, graph: &amp;amp;DependencyGraph) -&amp;gt; Result&amp;lt;Vec&amp;lt;Vec&amp;lt;NodeIndex&amp;gt;&amp;gt;&amp;gt; {
        let node_indices: Vec&amp;lt;_&amp;gt; &#x3D; graph.node_indices().collect();
        let mut labels: HashMap&amp;lt;NodeIndex, usize&amp;gt; &#x3D; HashMap::new();
        
        // Initialize each node with its own label
        for (i, &amp;amp;node) in node_indices.iter().enumerate() {
            labels.insert(node, i);
        }

        let max_iterations &#x3D; 100;
        let mut changed &#x3D; true;
        let mut iteration &#x3D; 0;

        while changed &amp;amp;&amp;amp; iteration &amp;lt; max_iterations {
            changed &#x3D; false;
            
            // Randomize order to avoid bias
            let shuffled_nodes &#x3D; node_indices.clone();
            // In a real implementation, would use proper randomization
            // shuffled_nodes.shuffle(&amp;amp;mut thread_rng());
            
            for &amp;amp;node in &amp;amp;shuffled_nodes {
                // Count labels of neighbors
                let mut neighbor_labels: HashMap&amp;lt;usize, f64&amp;gt; &#x3D; HashMap::new();
                
                for edge in graph.edges(node) {
                    let neighbor &#x3D; edge.target();
                    if let Some(&amp;amp;neighbor_label) &#x3D; labels.get(&amp;amp;neighbor) {
                        *neighbor_labels.entry(neighbor_label).or_insert(0.0) +&#x3D; edge.weight().weight as f64;
                    }
                }
                
                // Find most frequent label
                if let Some((&amp;amp;new_label, _)) &#x3D; neighbor_labels.iter().max_by(|a, b| a.1.partial_cmp(b.1).unwrap()) {
                    if labels.get(&amp;amp;node) !&#x3D; Some(&amp;amp;new_label) {
                        labels.insert(node, new_label);
                        changed &#x3D; true;
                    }
                }
            }
            
            iteration +&#x3D; 1;
        }

        // Group nodes by label
        let mut communities: HashMap&amp;lt;usize, Vec&amp;lt;NodeIndex&amp;gt;&amp;gt; &#x3D; HashMap::new();
        for (&amp;amp;node, &amp;amp;label) in &amp;amp;labels {
            communities.entry(label).or_insert_with(Vec::new).push(node);
        }

        Ok(communities.into_values().collect())
    }

    /// Refine partition using Kernighan-Lin algorithm
    fn refine_partition_with_kl(
        &amp;amp;self,
        graph: &amp;amp;DependencyGraph,
        mut communities: Vec&amp;lt;Vec&amp;lt;NodeIndex&amp;gt;&amp;gt;,
        target_k: usize,
    ) -&amp;gt; Result&amp;lt;Vec&amp;lt;Vec&amp;lt;NodeIndex&amp;gt;&amp;gt;&amp;gt; {
        // Merge or split communities to reach target k
        while communities.len() &amp;gt; target_k {
            // Merge smallest communities
            communities.sort_by_key(|c| c.len());
            let smallest &#x3D; communities.remove(0);
            let second_smallest &#x3D; communities.remove(0);
            let mut merged &#x3D; smallest;
            merged.extend(second_smallest);
            communities.push(merged);
        }

        while communities.len() &amp;lt; target_k {
            // Split largest community
            communities.sort_by_key(|c| c.len());
            let largest &#x3D; communities.pop().unwrap();
            if largest.len() &amp;gt;&#x3D; self.config.partitioning.min_clusters {
                let mid &#x3D; largest.len() / 2;
                let (first_half, second_half) &#x3D; largest.split_at(mid);
                communities.push(first_half.to_vec());
                communities.push(second_half.to_vec());
            } else {
                communities.push(largest);
                break;
            }
        }

        // Apply Kernighan-Lin refinement
        self.kernighan_lin_refinement(graph, communities)
    }

    /// Kernighan-Lin refinement algorithm
    fn kernighan_lin_refinement(
        &amp;amp;self,
        graph: &amp;amp;DependencyGraph,
        mut communities: Vec&amp;lt;Vec&amp;lt;NodeIndex&amp;gt;&amp;gt;,
    ) -&amp;gt; Result&amp;lt;Vec&amp;lt;Vec&amp;lt;NodeIndex&amp;gt;&amp;gt;&amp;gt; {
        let max_iterations &#x3D; 10;
        let mut improved &#x3D; true;
        let mut iteration &#x3D; 0;

        while improved &amp;amp;&amp;amp; iteration &amp;lt; max_iterations {
            improved &#x3D; false;
            
            // Try to improve each pair of communities
            for i in 0..communities.len() {
                for j in i + 1..communities.len() {
                    let _initial_cost &#x3D; self.calculate_partition_cost(graph, &amp;amp;communities);
                    
                    // Try swapping nodes between communities i and j
                    if let Some((best_swap, cost_improvement)) &#x3D; 
                        self.find_best_node_swap(graph, &amp;amp;communities[i], &amp;amp;communities[j]) {
                        
                        if cost_improvement &amp;gt; 0.0 {
                            // Apply the swap
                            let (from_comm, _to_comm, node) &#x3D; best_swap;
                            if from_comm &#x3D;&#x3D; i {
                                communities[i].retain(|&amp;amp;n| n !&#x3D; node);
                                communities[j].push(node);
                            } else {
                                communities[j].retain(|&amp;amp;n| n !&#x3D; node);
                                communities[i].push(node);
                            }
                            improved &#x3D; true;
                        }
                    }
                }
            }
            
            iteration +&#x3D; 1;
        }

        Ok(communities)
    }

    /// Calculate overall cost/cut of partition
    fn calculate_partition_cost(&amp;amp;self, graph: &amp;amp;DependencyGraph, communities: &amp;amp;[Vec&amp;lt;NodeIndex&amp;gt;]) -&amp;gt; f64 {
        let mut total_cut &#x3D; 0.0;
        
        for i in 0..communities.len() {
            for j in i + 1..communities.len() {
                total_cut +&#x3D; self.calculate_cut_size(graph, &amp;amp;communities[i], &amp;amp;communities[j]) as f64;
            }
        }
        
        total_cut
    }

    /// Find best node swap between two communities
    fn find_best_node_swap(
        &amp;amp;self,
        graph: &amp;amp;DependencyGraph,
        comm1: &amp;amp;[NodeIndex],
        comm2: &amp;amp;[NodeIndex],
    ) -&amp;gt; Option&amp;lt;((usize, usize, NodeIndex), f64)&amp;gt; {
        let mut best_swap &#x3D; None;
        let mut best_improvement &#x3D; 0.0;
        
        // Try moving each node from comm1 to comm2
        for &amp;amp;node in comm1 {
            let improvement &#x3D; self.calculate_swap_improvement(graph, node, comm1, comm2);
            if improvement &amp;gt; best_improvement {
                best_improvement &#x3D; improvement;
                best_swap &#x3D; Some((0, 1, node));
            }
        }
        
        // Try moving each node from comm2 to comm1
        for &amp;amp;node in comm2 {
            let improvement &#x3D; self.calculate_swap_improvement(graph, node, comm2, comm1);
            if improvement &amp;gt; best_improvement {
                best_improvement &#x3D; improvement;
                best_swap &#x3D; Some((1, 0, node));
            }
        }
        
        best_swap.map(|swap| (swap, best_improvement))
    }

    /// Calculate improvement from swapping a node between communities
    fn calculate_swap_improvement(
        &amp;amp;self,
        graph: &amp;amp;DependencyGraph,
        node: NodeIndex,
        from_comm: &amp;amp;[NodeIndex],
        to_comm: &amp;amp;[NodeIndex],
    ) -&amp;gt; f64 {
        let from_set: HashSet&amp;lt;_&amp;gt; &#x3D; from_comm.iter().copied().collect();
        let to_set: HashSet&amp;lt;_&amp;gt; &#x3D; to_comm.iter().copied().collect();
        
        let mut internal_edges_lost &#x3D; 0;
        let mut external_edges_gained &#x3D; 0;
        
        for edge in graph.edges(node) {
            let neighbor &#x3D; edge.target();
            let weight &#x3D; edge.weight().weight;
            
            if from_set.contains(&amp;amp;neighbor) {
                // Losing internal edge in from_comm
                internal_edges_lost +&#x3D; weight;
            } else if to_set.contains(&amp;amp;neighbor) {
                // Gaining internal edge in to_comm
                external_edges_gained +&#x3D; weight;
            }
        }
        
        // Improvement &#x3D; edges gained internally - edges lost internally
        (external_edges_gained as f64) - (internal_edges_lost as f64)
    }

    /// Convert graph communities to directory partitions
    fn communities_to_partitions(
        &amp;amp;self,
        graph: &amp;amp;DependencyGraph,
        communities: Vec&amp;lt;Vec&amp;lt;NodeIndex&amp;gt;&amp;gt;,
        k: usize,
    ) -&amp;gt; Result&amp;lt;Vec&amp;lt;DirectoryPartition&amp;gt;&amp;gt; {
        let mut partitions &#x3D; Vec::new();
        
        for (i, community) in communities.into_iter().take(k).enumerate() {
            let mut files &#x3D; Vec::new();
            let mut total_loc &#x3D; 0;
            
            for node_idx in community {
                if let Some(file_node) &#x3D; graph.node_weight(node_idx) {
                    // Ensure we store the complete absolute path
                    let complete_path &#x3D; if file_node.path.is_absolute() {
                        file_node.path.clone()
                    } else {
                        std::env::current_dir().unwrap_or_default().join(&amp;amp;file_node.path)
                    };
                    files.push(complete_path);
                    total_loc +&#x3D; file_node.loc;
                }
            }
            
            // Generate deterministic name for partition
            let name &#x3D; self.generate_partition_name(&amp;amp;files, i);
            
            partitions.push(DirectoryPartition {
                name,
                files,
                loc: total_loc,
            });
        }
        
        Ok(partitions)
    }

    /// Generate deterministic partition name based on file paths
    fn generate_partition_name(&amp;amp;self, files: &amp;amp;[PathBuf], index: usize) -&amp;gt; String {
        // Extract common tokens from file paths
        let mut token_counts: HashMap&amp;lt;String, usize&amp;gt; &#x3D; HashMap::new();
        
        for file_path in files {
            if let Some(stem) &#x3D; file_path.file_stem().and_then(|s| s.to_str()) {
                // Split on common separators and count tokens
                for token in stem.split([&amp;#x27;_&amp;#x27;, &amp;#x27;-&amp;#x27;, &amp;#x27;.&amp;#x27;]) {
                    let token &#x3D; token.to_lowercase();
                    if token.len() &amp;gt; 2 &amp;amp;&amp;amp; !token.chars().all(|c| c.is_ascii_digit()) {
                        *token_counts.entry(token).or_insert(0) +&#x3D; 1;
                    }
                }
            }
        }
        
        // Find most common meaningful token
        if let Some((best_token, _)) &#x3D; token_counts.iter()
            .filter(|(token, &amp;amp;count)| count &amp;gt; 1 &amp;amp;&amp;amp; ![&amp;quot;file&amp;quot;, &amp;quot;test&amp;quot;, &amp;quot;spec&amp;quot;].contains(&amp;amp;token.as_str()))
            .max_by_key(|(_, &amp;amp;count)| count) {
            return best_token.clone();
        }
        
        // Fall back to predefined names
        self.config.partitioning.naming_fallbacks
            .get(index)
            .cloned()
            .unwrap_or_else(|| format!(&amp;quot;partition_{}&amp;quot;, index))
    }

    /// Calculate expected gains from reorganization
    pub fn calculate_reorganization_gain(
        &amp;amp;self, 
        current_metrics: &amp;amp;DirectoryMetrics,
        partitions: &amp;amp;[DirectoryPartition],
        dir_path: &amp;amp;Path
    ) -&amp;gt; Result&amp;lt;ReorganizationGain&amp;gt; {
        // Calculate imbalance for each proposed partition
        let mut partition_imbalances &#x3D; Vec::new();
        
        for partition in partitions {
            // Create a temporary directory metrics for this partition
            let partition_files &#x3D; partition.files.len();
            let _partition_subdirs &#x3D; 0; // New partitions start with 0 subdirs
            let partition_loc &#x3D; partition.loc;
            
            // Simulate LOC distribution within partition (simplified)
            let avg_loc_per_file &#x3D; if partition_files &amp;gt; 0 {
                partition_loc / partition_files
            } else {
                0
            };
            let loc_distribution: Vec&amp;lt;usize&amp;gt; &#x3D; (0..partition_files)
                .map(|_| avg_loc_per_file)
                .collect();
            
            // Calculate metrics for this partition
            let gini &#x3D; self.calculate_gini_coefficient(&amp;amp;loc_distribution);
            let entropy &#x3D; self.calculate_entropy(&amp;amp;loc_distribution);
            
            // Calculate pressure metrics
            let file_pressure &#x3D; (partition_files as f64 / self.config.fsdir.max_files_per_dir as f64).min(1.0);
            let branch_pressure &#x3D; 0.0; // No subdirs in new partition
            let size_pressure &#x3D; (partition_loc as f64 / self.config.fsdir.max_dir_loc as f64).min(1.0);
            
            // Calculate dispersion
            let max_entropy &#x3D; if partition_files &amp;gt; 0 { (partition_files as f64).log2() } else { 1.0 };
            let normalized_entropy &#x3D; if max_entropy &amp;gt; 0.0 { entropy / max_entropy } else { 0.0 };
            let dispersion &#x3D; gini.max(1.0 - normalized_entropy);
            
            // Apply size normalization
            let size_normalization_factor &#x3D; self.calculate_size_normalization_factor(partition_files, partition_loc);
            
            // Calculate imbalance for this partition
            let raw_imbalance &#x3D; 0.35 * file_pressure + 
                               0.25 * branch_pressure + 
                               0.25 * size_pressure + 
                               0.15 * dispersion;
            
            let partition_imbalance &#x3D; raw_imbalance * size_normalization_factor;
            partition_imbalances.push(partition_imbalance);
        }
        
        // Calculate average imbalance of new partitions
        let avg_new_imbalance &#x3D; if !partition_imbalances.is_empty() {
            partition_imbalances.iter().sum::&amp;lt;f64&amp;gt;() / partition_imbalances.len() as f64
        } else {
            current_metrics.imbalance
        };
        
        // Imbalance improvement (positive means improvement)
        let imbalance_delta &#x3D; (current_metrics.imbalance - avg_new_imbalance).max(0.0);
        
        // Calculate cross-edges reduced by analyzing dependency graph
        let cross_edges_reduced &#x3D; self.estimate_cross_edges_reduced(partitions, dir_path)?;
        
        Ok(ReorganizationGain {
            imbalance_delta,
            cross_edges_reduced,
        })
    }
    
    /// Estimate how many cross-partition edges would be reduced
    fn estimate_cross_edges_reduced(&amp;amp;self, partitions: &amp;amp;[DirectoryPartition], dir_path: &amp;amp;Path) -&amp;gt; Result&amp;lt;usize&amp;gt; {
        // Build dependency graph to analyze edge cuts
        let dependency_graph &#x3D; self.build_dependency_graph(dir_path)?;
        
        // Create partition mapping
        let mut file_to_partition: HashMap&amp;lt;PathBuf, usize&amp;gt; &#x3D; HashMap::new();
        for (partition_idx, partition) in partitions.iter().enumerate() {
            for file_path in &amp;amp;partition.files {
                file_to_partition.insert(file_path.clone(), partition_idx);
            }
        }
        
        // Count edges that would cross partition boundaries
        let mut cross_edges &#x3D; 0;
        let mut _total_internal_edges &#x3D; 0;
        
        for edge_idx in dependency_graph.edge_indices() {
            if let Some((source, target)) &#x3D; dependency_graph.edge_endpoints(edge_idx) {
                if let (Some(source_node), Some(target_node)) &#x3D; 
                    (dependency_graph.node_weight(source), dependency_graph.node_weight(target)) {
                    
                    _total_internal_edges +&#x3D; 1;
                    
                    // Check if this edge would cross partition boundaries
                    if let (Some(&amp;amp;source_partition), Some(&amp;amp;target_partition)) &#x3D; 
                        (file_to_partition.get(&amp;amp;source_node.path), file_to_partition.get(&amp;amp;target_node.path)) {
                        if source_partition !&#x3D; target_partition {
                            cross_edges +&#x3D; 1;
                        }
                    }
                }
            }
        }
        
        // Return estimated edges that would be internal after reorganization
        Ok(cross_edges)
    }

    /// Calculate effort estimation for reorganization
    pub fn calculate_reorganization_effort(
        &amp;amp;self,
        partitions: &amp;amp;[DirectoryPartition], 
        _dir_path: &amp;amp;Path
    ) -&amp;gt; Result&amp;lt;ReorganizationEffort&amp;gt; {
        let files_moved &#x3D; partitions.iter().map(|p| p.files.len()).sum();
        
        // Rough estimation: 2 import updates per moved file on average
        let import_updates_est &#x3D; files_moved * 2;
        
        Ok(ReorganizationEffort {
            files_moved,
            import_updates_est,
        })
    }

    /// Generate reorganization rules
    fn generate_reorganization_rules(&amp;amp;self, _dir_path: &amp;amp;Path) -&amp;gt; Vec&amp;lt;String&amp;gt; {
        vec![
            &amp;quot;Create subdirectories for each partition&amp;quot;.to_string(),
            &amp;quot;Update relative import statements&amp;quot;.to_string(), 
            &amp;quot;Preserve file names and structure within partitions&amp;quot;.to_string(),
            &amp;quot;Test imports after reorganization&amp;quot;.to_string(),
        ]
    }

    /// Generate file moves for reorganization
    pub fn generate_file_moves(&amp;amp;self, partitions: &amp;amp;[DirectoryPartition], dir_path: &amp;amp;Path) -&amp;gt; Result&amp;lt;Vec&amp;lt;FileMove&amp;gt;&amp;gt; {
        let mut file_moves &#x3D; Vec::new();
        
        for partition in partitions {
            for file_path in &amp;amp;partition.files {
                // Create destination path in new subdirectory
                let file_name &#x3D; file_path.file_name()
                    .ok_or_else(|| ValknutError::internal(&amp;quot;Invalid file path&amp;quot;))?;
                
                let destination &#x3D; dir_path.join(&amp;amp;partition.name).join(file_name);
                
                file_moves.push(FileMove {
                    from: file_path.clone(),
                    to: destination,
                });
            }
        }
        
        Ok(file_moves)
    }

    /// Calculate size normalization factor for directory metrics
    pub fn calculate_size_normalization_factor(&amp;amp;self, files: usize, total_loc: usize) -&amp;gt; f64 {
        // Prevent small codebases from being over-penalized 
        // and large ones from being under-penalized
        let base_files &#x3D; 10.0;
        let base_loc &#x3D; 1000.0;
        
        let file_factor &#x3D; (files as f64 / base_files).ln_1p() / base_files.ln();
        let loc_factor &#x3D; (total_loc as f64 / base_loc).ln_1p() / base_loc.ln();
        
        // Combine factors and normalize to [0.5, 1.5] range
        let combined &#x3D; (file_factor + loc_factor) * 0.5;
        1.0 + combined.tanh() * 0.5
    }

    /// Extract imports from source file
    fn extract_imports(&amp;amp;self, file_path: &amp;amp;Path) -&amp;gt; Result&amp;lt;Vec&amp;lt;ImportStatement&amp;gt;&amp;gt; {
        let content &#x3D; FileReader::read_to_string(file_path)?;
        let extension &#x3D; file_path.extension()
            .and_then(|ext| ext.to_str())
            .unwrap_or(&amp;quot;&amp;quot;);
        
        match extension {
            &amp;quot;py&amp;quot; &#x3D;&amp;gt; self.extract_python_imports(&amp;amp;content),
            &amp;quot;js&amp;quot; | &amp;quot;jsx&amp;quot; | &amp;quot;ts&amp;quot; | &amp;quot;tsx&amp;quot; &#x3D;&amp;gt; self.extract_javascript_imports(&amp;amp;content),
            &amp;quot;rs&amp;quot; &#x3D;&amp;gt; self.extract_rust_imports(&amp;amp;content),
            _ &#x3D;&amp;gt; Ok(Vec::new()),
        }
    }

    /// Extract Python import statements
    fn extract_python_imports(&amp;amp;self, content: &amp;amp;str) -&amp;gt; Result&amp;lt;Vec&amp;lt;ImportStatement&amp;gt;&amp;gt; {
        let mut imports &#x3D; Vec::new();
        
        for (line_number, line) in content.lines().enumerate() {
            let trimmed &#x3D; line.trim();
            
            // Skip comments and empty lines
            if trimmed.is_empty() || trimmed.starts_with(&amp;#x27;#&amp;#x27;) {
                continue;
            }
            
            if let Some(import_part) &#x3D; trimmed.strip_prefix(&amp;quot;import &amp;quot;) {
                // Handle: import module
                let module &#x3D; import_part.split_whitespace().next().unwrap_or(&amp;quot;&amp;quot;).to_string();
                imports.push(ImportStatement {
                    module,
                    imports: None,
                    import_type: &amp;quot;module&amp;quot;.to_string(),
                    line_number: line_number + 1,
                });
            } else if let Some(from_part) &#x3D; trimmed.strip_prefix(&amp;quot;from &amp;quot;) {
                // Handle: from module import ...
                if let Some(import_pos) &#x3D; from_part.find(&amp;quot; import &amp;quot;) {
                    let module &#x3D; from_part[..import_pos].trim().to_string();
                    let import_list &#x3D; from_part[import_pos + 8..].trim();
                    
                    let specific_imports &#x3D; if import_list &#x3D;&#x3D; &amp;quot;*&amp;quot; {
                        None // Star import
                    } else {
                        Some(import_list.split(&amp;#x27;,&amp;#x27;)
                            .map(|s| s.trim().to_string())
                            .collect())
                    };
                    
                    imports.push(ImportStatement {
                        module,
                        imports: specific_imports,
                        import_type: if import_list &#x3D;&#x3D; &amp;quot;*&amp;quot; { &amp;quot;star&amp;quot; } else { &amp;quot;named&amp;quot; }.to_string(),
                        line_number: line_number + 1,
                    });
                }
            }
        }
        
        Ok(imports)
    }

    /// Extract JavaScript/TypeScript import statements  
    fn extract_javascript_imports(&amp;amp;self, content: &amp;amp;str) -&amp;gt; Result&amp;lt;Vec&amp;lt;ImportStatement&amp;gt;&amp;gt; {
        let mut imports &#x3D; Vec::new();
        
        for (line_number, line) in content.lines().enumerate() {
            let trimmed &#x3D; line.trim();
            
            // Skip comments and empty lines
            if trimmed.is_empty() || trimmed.starts_with(&amp;quot;//&amp;quot;) || trimmed.starts_with(&amp;quot;/*&amp;quot;) {
                continue;
            }
            
            if let Some(import_part) &#x3D; trimmed.strip_prefix(&amp;quot;import &amp;quot;) {
                // Handle various import patterns
                if let Some(from_pos) &#x3D; import_part.find(&amp;quot; from &amp;quot;) {
                    let import_spec &#x3D; import_part[..from_pos].trim();
                    let module_part &#x3D; import_part[from_pos + 6..].trim().trim_matches([&amp;#x27;&amp;quot;&amp;#x27;, &amp;#x27;\&amp;#x27;&amp;#x27;, &amp;#x27;;&amp;#x27;]);
                    
                    let specific_imports &#x3D; if import_spec.starts_with(&amp;#x27;*&amp;#x27;) {
                        None // Star import
                    } else if import_spec.starts_with(&amp;#x27;{&amp;#x27;) &amp;amp;&amp;amp; import_spec.ends_with(&amp;#x27;}&amp;#x27;) {
                        // Named imports: { a, b, c }
                        let inner &#x3D; &amp;amp;import_spec[1..import_spec.len()-1];
                        Some(inner.split(&amp;#x27;,&amp;#x27;)
                            .map(|s| s.trim().to_string())
                            .collect())
                    } else {
                        // Default import
                        Some(vec![import_spec.to_string()])
                    };
                    
                    imports.push(ImportStatement {
                        module: module_part.to_string(),
                        imports: specific_imports,
                        import_type: if import_spec.starts_with(&amp;#x27;*&amp;#x27;) { &amp;quot;star&amp;quot; } else { &amp;quot;named&amp;quot; }.to_string(),
                        line_number: line_number + 1,
                    });
                }
            }
        }
        
        Ok(imports)
    }

    /// Extract Rust use statements
    fn extract_rust_imports(&amp;amp;self, content: &amp;amp;str) -&amp;gt; Result&amp;lt;Vec&amp;lt;ImportStatement&amp;gt;&amp;gt; {
        let mut imports &#x3D; Vec::new();
        
        for (line_number, line) in content.lines().enumerate() {
            let trimmed &#x3D; line.trim();
            
            // Skip comments and empty lines
            if trimmed.is_empty() || trimmed.starts_with(&amp;quot;//&amp;quot;) {
                continue;
            }
            
            if let Some(use_part) &#x3D; trimmed.strip_prefix(&amp;quot;use &amp;quot;) {
                let use_part &#x3D; use_part.trim_end_matches(&amp;#x27;;&amp;#x27;);
                
                if let Some(brace_pos) &#x3D; use_part.find(&amp;#x27;{&amp;#x27;) {
                    // Handle: use module::{item1, item2}
                    let module &#x3D; use_part[..brace_pos].trim().to_string();
                    let items_part &#x3D; &amp;amp;use_part[brace_pos + 1..];
                    
                    if let Some(close_brace) &#x3D; items_part.find(&amp;#x27;}&amp;#x27;) {
                        let items &#x3D; &amp;amp;items_part[..close_brace];
                        let specific_imports &#x3D; Some(items.split(&amp;#x27;,&amp;#x27;)
                            .map(|s| s.trim().to_string())
                            .collect());
                        
                        imports.push(ImportStatement {
                            module,
                            imports: specific_imports,
                            import_type: &amp;quot;named&amp;quot;.to_string(),
                            line_number: line_number + 1,
                        });
                    }
                } else {
                    // Handle: use module::item
                    imports.push(ImportStatement {
                        module: use_part.to_string(),
                        imports: None,
                        import_type: &amp;quot;module&amp;quot;.to_string(),
                        line_number: line_number + 1,
                    });
                }
            }
        }
        
        Ok(imports)
    }

    /// Resolve import statement to local file path
    fn resolve_import_to_local_file(&amp;amp;self, import: &amp;amp;ImportStatement, dir_path: &amp;amp;Path) -&amp;gt; Option&amp;lt;PathBuf&amp;gt; {
        // This is a simplified resolution - in practice would be more sophisticated
        let module_name &#x3D; &amp;amp;import.module;
        
        // Check if it&amp;#x27;s a relative import within the same directory
        if module_name.starts_with(&amp;#x27;.&amp;#x27;) {
            return None; // Skip relative imports for now
        }
        
        // Try common file extensions
        let extensions &#x3D; [&amp;quot;py&amp;quot;, &amp;quot;js&amp;quot;, &amp;quot;ts&amp;quot;, &amp;quot;jsx&amp;quot;, &amp;quot;tsx&amp;quot;, &amp;quot;rs&amp;quot;];
        
        for ext in &amp;amp;extensions {
            let potential_path &#x3D; dir_path.join(format!(&amp;quot;{}.{}&amp;quot;, module_name, ext));
            if potential_path.exists() {
                return Some(potential_path);
            }
        }
        
        None
    }

    /// Discover directories recursively for analysis
    pub async fn discover_directories(&amp;amp;self, root_path: &amp;amp;Path) -&amp;gt; Result&amp;lt;Vec&amp;lt;PathBuf&amp;gt;&amp;gt; {
        let mut directories &#x3D; Vec::new();
        self.collect_directories_recursive(root_path, &amp;amp;mut directories)?;
        Ok(directories)
    }

    /// Collect directories recursively
    fn collect_directories_recursive(&amp;amp;self, path: &amp;amp;Path, directories: &amp;amp;mut Vec&amp;lt;PathBuf&amp;gt;) -&amp;gt; Result&amp;lt;()&amp;gt; {
        for entry in std::fs::read_dir(path)? {
            let entry &#x3D; entry?;
            let entry_path &#x3D; entry.path();
            
            if entry_path.is_dir() {
                if !self.should_skip_directory(&amp;amp;entry_path) {
                    directories.push(entry_path.clone());
                    self.collect_directories_recursive(&amp;amp;entry_path, directories)?;
                }
            }
        }
        Ok(())
    }

    /// Check if directory should be skipped from analysis
    fn should_skip_directory(&amp;amp;self, path: &amp;amp;Path) -&amp;gt; bool {
        let filename &#x3D; path.file_name()
            .and_then(|name| name.to_str())
            .unwrap_or(&amp;quot;&amp;quot;);
        
        // Skip common ignore patterns
        matches!(filename, 
            &amp;quot;node_modules&amp;quot; | &amp;quot;target&amp;quot; | &amp;quot;.git&amp;quot; | &amp;quot;__pycache__&amp;quot; | 
            &amp;quot;dist&amp;quot; | &amp;quot;build&amp;quot; | &amp;quot;.next&amp;quot; | &amp;quot;vendor&amp;quot; | &amp;quot;venv&amp;quot;)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::detectors::structure::config::{
        StructureConfig, FsDirectoryConfig, PartitioningConfig, StructureToggles, FsFileConfig
    };
    use std::fs;
    use tempfile::TempDir;

    fn create_test_config() -&amp;gt; StructureConfig {
        StructureConfig {
            enable_branch_packs: true,
            enable_file_split_packs: true,
            top_packs: 20,
            fsdir: FsDirectoryConfig {
                max_files_per_dir: 20,
                max_subdirs_per_dir: 10,
                max_dir_loc: 2000,
                target_loc_per_subdir: 500,
                min_branch_recommendation_gain: 0.1,
                min_files_for_split: 5,
            },
            fsfile: FsFileConfig {
                huge_loc: 800,
                huge_bytes: 128_000,
                min_split_loc: 200,
                min_entities_per_split: 3,
            },
            partitioning: PartitioningConfig {
                max_clusters: 8,
                min_clusters: 2,
                balance_tolerance: 0.3,
                naming_fallbacks: vec![
                    &amp;quot;core&amp;quot;.to_string(),
                    &amp;quot;utils&amp;quot;.to_string(), 
                    &amp;quot;components&amp;quot;.to_string(),
                    &amp;quot;services&amp;quot;.to_string(),
                ],
            },
        }
    }

    fn setup_test_directory() -&amp;gt; TempDir {
        let temp_dir &#x3D; TempDir::new().unwrap();
        let dir_path &#x3D; temp_dir.path();

        // Create test files with different sizes
        fs::write(dir_path.join(&amp;quot;small.py&amp;quot;), &amp;quot;# Small file\nprint(&amp;#x27;hello&amp;#x27;)&amp;quot;).unwrap();
        fs::write(dir_path.join(&amp;quot;medium.py&amp;quot;), &amp;quot;# Medium file\n&amp;quot;.repeat(50)).unwrap();
        fs::write(dir_path.join(&amp;quot;large.py&amp;quot;), &amp;quot;# Large file\n&amp;quot;.repeat(200)).unwrap();
        fs::write(dir_path.join(&amp;quot;test.js&amp;quot;), &amp;quot;// JavaScript file\nconsole.log(&amp;#x27;test&amp;#x27;);&amp;quot;).unwrap();
        fs::write(dir_path.join(&amp;quot;app.rs&amp;quot;), &amp;quot;// Rust file\nfn main() { println!(\&amp;quot;Hello\&amp;quot;); }&amp;quot;).unwrap();
        
        // Create subdirectory
        fs::create_dir(dir_path.join(&amp;quot;subdir&amp;quot;)).unwrap();
        fs::write(dir_path.join(&amp;quot;subdir/nested.py&amp;quot;), &amp;quot;# Nested file&amp;quot;).unwrap();

        temp_dir
    }

    #[test]
    fn test_directory_analyzer_new() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config.clone());
        
        assert_eq!(analyzer.config.fsdir.max_files_per_dir, config.fsdir.max_files_per_dir);
        assert!(analyzer.metrics_cache.is_empty());
    }

    #[test]
    fn test_is_code_file() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        assert!(analyzer.is_code_file(&amp;quot;py&amp;quot;));
        assert!(analyzer.is_code_file(&amp;quot;js&amp;quot;));
        assert!(analyzer.is_code_file(&amp;quot;ts&amp;quot;));
        assert!(analyzer.is_code_file(&amp;quot;rs&amp;quot;));
        assert!(!analyzer.is_code_file(&amp;quot;txt&amp;quot;));
        assert!(!analyzer.is_code_file(&amp;quot;md&amp;quot;));
    }

    #[test]
    fn test_count_lines_of_code() {
        let temp_dir &#x3D; TempDir::new().unwrap();
        let file_path &#x3D; temp_dir.path().join(&amp;quot;test.py&amp;quot;);
        
        let content &#x3D; r#&amp;quot;# Comment line
import os

def hello():
    print(&amp;quot;Hello world&amp;quot;)
    # Another comment
    return True

    # Empty line above
&amp;quot;#;
        fs::write(&amp;amp;file_path, content).unwrap();
        
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        let loc &#x3D; analyzer.count_lines_of_code(&amp;amp;file_path).unwrap();
        
        // Should count non-empty, non-comment lines
        assert!(loc &amp;gt; 0);
        assert!(loc &amp;lt; content.lines().count()); // Less than total lines due to comments
    }

    #[test]
    fn test_gather_directory_stats() {
        let temp_dir &#x3D; setup_test_directory();
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let (files, subdirs, loc_distribution) &#x3D; analyzer
            .gather_directory_stats(temp_dir.path())
            .unwrap();
        
        assert_eq!(files, 5); // 5 code files
        assert_eq!(subdirs, 1); // 1 subdirectory
        assert_eq!(loc_distribution.len(), 5);
        assert!(loc_distribution.iter().all(|&amp;amp;loc| loc &amp;gt; 0));
    }

    #[test]
    fn test_calculate_gini_coefficient_empty() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let gini &#x3D; analyzer.calculate_gini_coefficient(&amp;amp;[]);
        assert_eq!(gini, 0.0);
    }

    #[test]
    fn test_calculate_gini_coefficient_single_value() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let gini &#x3D; analyzer.calculate_gini_coefficient(&amp;amp;[100]);
        assert_eq!(gini, 0.0);
    }

    #[test]
    fn test_calculate_gini_coefficient_equal_values() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let gini &#x3D; analyzer.calculate_gini_coefficient(&amp;amp;[50, 50, 50, 50]);
        assert!(gini &amp;lt; 0.1); // Should be close to 0 for equal distribution
    }

    #[test]
    fn test_calculate_gini_coefficient_unequal_values() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let gini &#x3D; analyzer.calculate_gini_coefficient(&amp;amp;[10, 20, 30, 100]);
        assert!(gini &amp;gt; 0.1); // Should be higher for unequal distribution
    }

    #[test]
    fn test_calculate_entropy_empty() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let entropy &#x3D; analyzer.calculate_entropy(&amp;amp;[]);
        assert_eq!(entropy, 0.0);
    }

    #[test]
    fn test_calculate_entropy_single_value() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let entropy &#x3D; analyzer.calculate_entropy(&amp;amp;[100]);
        assert_eq!(entropy, 0.0);
    }

    #[test]
    fn test_calculate_entropy_equal_values() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let entropy &#x3D; analyzer.calculate_entropy(&amp;amp;[25, 25, 25, 25]);
        assert!(entropy &amp;gt; 1.0); // Should be high for uniform distribution
    }

    #[test]
    fn test_calculate_size_normalization_factor() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let factor1 &#x3D; analyzer.calculate_size_normalization_factor(5, 500);
        let factor2 &#x3D; analyzer.calculate_size_normalization_factor(10, 1000);
        let factor3 &#x3D; analyzer.calculate_size_normalization_factor(20, 2000);
        
        // Normalization factor should be within reasonable range
        assert!(factor1 &amp;gt;&#x3D; 0.5 &amp;amp;&amp;amp; factor1 &amp;lt;&#x3D; 1.5);
        assert!(factor2 &amp;gt;&#x3D; 0.5 &amp;amp;&amp;amp; factor2 &amp;lt;&#x3D; 1.5);
        assert!(factor3 &amp;gt;&#x3D; 0.5 &amp;amp;&amp;amp; factor3 &amp;lt;&#x3D; 1.5);
    }

    #[test]
    fn test_calculate_directory_metrics() {
        let temp_dir &#x3D; setup_test_directory();
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let metrics &#x3D; analyzer.calculate_directory_metrics(temp_dir.path()).unwrap();
        
        assert_eq!(metrics.files, 5);
        assert_eq!(metrics.subdirs, 1);
        assert!(metrics.loc &amp;gt; 0);
        assert!(metrics.gini &amp;gt;&#x3D; 0.0 &amp;amp;&amp;amp; metrics.gini &amp;lt;&#x3D; 1.0);
        assert!(metrics.entropy &amp;gt;&#x3D; 0.0);
        assert!(metrics.file_pressure &amp;gt;&#x3D; 0.0 &amp;amp;&amp;amp; metrics.file_pressure &amp;lt;&#x3D; 1.0);
        assert!(metrics.branch_pressure &amp;gt;&#x3D; 0.0 &amp;amp;&amp;amp; metrics.branch_pressure &amp;lt;&#x3D; 1.0);
        assert!(metrics.size_pressure &amp;gt;&#x3D; 0.0 &amp;amp;&amp;amp; metrics.size_pressure &amp;lt;&#x3D; 1.0);
        assert!(metrics.dispersion &amp;gt;&#x3D; 0.0 &amp;amp;&amp;amp; metrics.dispersion &amp;lt;&#x3D; 1.0);
        assert!(metrics.imbalance &amp;gt;&#x3D; 0.0);
    }

    #[test]
    fn test_calculate_directory_metrics_caching() {
        let temp_dir &#x3D; setup_test_directory();
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        // First call
        let metrics1 &#x3D; analyzer.calculate_directory_metrics(temp_dir.path()).unwrap();
        
        // Second call should return cached result
        let metrics2 &#x3D; analyzer.calculate_directory_metrics(temp_dir.path()).unwrap();
        
        assert_eq!(metrics1.files, metrics2.files);
        assert_eq!(metrics1.subdirs, metrics2.subdirs);
        assert_eq!(metrics1.loc, metrics2.loc);
        assert!(!analyzer.metrics_cache.is_empty());
    }

    #[test]
    fn test_should_skip_directory() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        assert!(analyzer.should_skip_directory(Path::new(&amp;quot;node_modules&amp;quot;)));
        assert!(analyzer.should_skip_directory(Path::new(&amp;quot;target&amp;quot;)));
        assert!(analyzer.should_skip_directory(Path::new(&amp;quot;.git&amp;quot;)));
        assert!(analyzer.should_skip_directory(Path::new(&amp;quot;__pycache__&amp;quot;)));
        assert!(!analyzer.should_skip_directory(Path::new(&amp;quot;src&amp;quot;)));
        assert!(!analyzer.should_skip_directory(Path::new(&amp;quot;lib&amp;quot;)));
    }

    #[test]
    fn test_extract_python_imports_basic() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let content &#x3D; r#&amp;quot;import os
import sys
from pathlib import Path
from collections import OrderedDict, defaultdict
&amp;quot;#;
        
        let imports &#x3D; analyzer.extract_python_imports(content).unwrap();
        
        assert_eq!(imports.len(), 4);
        
        assert_eq!(imports[0].module, &amp;quot;os&amp;quot;);
        assert_eq!(imports[0].import_type, &amp;quot;module&amp;quot;);
        
        assert_eq!(imports[2].module, &amp;quot;pathlib&amp;quot;);
        assert_eq!(imports[2].import_type, &amp;quot;named&amp;quot;);
        assert!(imports[2].imports.as_ref().unwrap().contains(&amp;amp;&amp;quot;Path&amp;quot;.to_string()));
    }

    #[test]
    fn test_extract_python_imports_star_import() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let content &#x3D; &amp;quot;from module import *&amp;quot;;
        let imports &#x3D; analyzer.extract_python_imports(content).unwrap();
        
        assert_eq!(imports.len(), 1);
        assert_eq!(imports[0].import_type, &amp;quot;star&amp;quot;);
        assert!(imports[0].imports.is_none());
    }

    #[test]
    fn test_extract_javascript_imports_basic() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let content &#x3D; r#&amp;quot;import React from &amp;#x27;react&amp;#x27;;
import { useState, useEffect } from &amp;#x27;react&amp;#x27;;
import * as utils from &amp;#x27;./utils&amp;#x27;;
&amp;quot;#;
        
        let imports &#x3D; analyzer.extract_javascript_imports(content).unwrap();
        
        assert_eq!(imports.len(), 3);
        assert_eq!(imports[0].module, &amp;quot;react&amp;quot;);
        assert_eq!(imports[1].import_type, &amp;quot;named&amp;quot;);
        assert_eq!(imports[2].import_type, &amp;quot;star&amp;quot;);
    }

    #[test]
    fn test_extract_rust_imports_basic() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let content &#x3D; r#&amp;quot;use std::collections::HashMap;
use std::fs::{File, OpenOptions};
use serde::{Serialize, Deserialize};
&amp;quot;#;
        
        let imports &#x3D; analyzer.extract_rust_imports(content).unwrap();
        
        assert_eq!(imports.len(), 3);
        assert_eq!(imports[0].module, &amp;quot;std::collections::HashMap&amp;quot;);
        assert_eq!(imports[0].import_type, &amp;quot;module&amp;quot;);
        
        assert_eq!(imports[1].module, &amp;quot;std::fs::&amp;quot;);
        assert_eq!(imports[1].import_type, &amp;quot;named&amp;quot;);
        assert!(imports[1].imports.as_ref().unwrap().contains(&amp;amp;&amp;quot;File&amp;quot;.to_string()));
    }

    #[test]
    fn test_generate_partition_name_with_common_tokens() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let files &#x3D; vec![
            PathBuf::from(&amp;quot;user_service.py&amp;quot;),
            PathBuf::from(&amp;quot;user_model.py&amp;quot;),
            PathBuf::from(&amp;quot;user_controller.py&amp;quot;),
        ];
        
        let name &#x3D; analyzer.generate_partition_name(&amp;amp;files, 0);
        assert_eq!(name, &amp;quot;user&amp;quot;);
    }

    #[test]
    fn test_generate_partition_name_fallback() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let files &#x3D; vec![
            PathBuf::from(&amp;quot;a.py&amp;quot;),
            PathBuf::from(&amp;quot;b.py&amp;quot;),
        ];
        
        let name &#x3D; analyzer.generate_partition_name(&amp;amp;files, 0);
        assert_eq!(name, &amp;quot;core&amp;quot;); // First fallback name
    }

    #[test]
    fn test_calculate_cut_size() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        // Create a simple graph for testing
        let mut graph &#x3D; petgraph::Graph::new();
        let node1 &#x3D; graph.add_node(FileNode {
            path: PathBuf::from(&amp;quot;file1.py&amp;quot;),
            loc: 100,
            size_bytes: 1000,
        });
        let node2 &#x3D; graph.add_node(FileNode {
            path: PathBuf::from(&amp;quot;file2.py&amp;quot;),
            loc: 200,
            size_bytes: 2000,
        });
        
        graph.add_edge(node1, node2, DependencyEdge {
            weight: 3,
            relationship_type: &amp;quot;import&amp;quot;.to_string(),
        });
        
        let part1 &#x3D; vec![node1];
        let part2 &#x3D; vec![node2];
        
        let cut_size &#x3D; analyzer.calculate_cut_size(&amp;amp;graph, &amp;amp;part1, &amp;amp;part2);
        assert_eq!(cut_size, 3);
    }

    #[test]
    fn test_random_partition() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        // Create test node indices
        let mut graph: DependencyGraph &#x3D; petgraph::Graph::new();
        let nodes: Vec&amp;lt;_&amp;gt; &#x3D; (0..6).map(|i| {
            graph.add_node(FileNode {
                path: PathBuf::from(format!(&amp;quot;file{}.py&amp;quot;, i)),
                loc: 100,
                size_bytes: 1000,
            })
        }).collect();
        
        let communities &#x3D; analyzer.random_partition(&amp;amp;nodes, 3).unwrap();
        
        assert_eq!(communities.len(), 3);
        assert_eq!(communities.iter().map(|c| c.len()).sum::&amp;lt;usize&amp;gt;(), 6);
    }

    #[tokio::test]
    async fn test_discover_directories() {
        let temp_dir &#x3D; TempDir::new().unwrap();
        let root_path &#x3D; temp_dir.path();
        
        // Create nested directory structure
        fs::create_dir(root_path.join(&amp;quot;src&amp;quot;)).unwrap();
        fs::create_dir(root_path.join(&amp;quot;src/lib&amp;quot;)).unwrap();
        fs::create_dir(root_path.join(&amp;quot;tests&amp;quot;)).unwrap();
        fs::create_dir(root_path.join(&amp;quot;node_modules&amp;quot;)).unwrap(); // Should be skipped
        
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let directories &#x3D; analyzer.discover_directories(root_path).await.unwrap();
        
        // Should find src, src/lib, and tests, but not node_modules
        assert!(directories.len() &amp;gt;&#x3D; 3);
        assert!(directories.iter().any(|d| d.file_name().unwrap() &#x3D;&#x3D; &amp;quot;src&amp;quot;));
        assert!(directories.iter().any(|d| d.file_name().unwrap() &#x3D;&#x3D; &amp;quot;tests&amp;quot;));
        assert!(!directories.iter().any(|d| d.file_name().unwrap() &#x3D;&#x3D; &amp;quot;node_modules&amp;quot;));
    }

    #[test]
    fn test_analyze_directory_for_reorg_low_imbalance() {
        let temp_dir &#x3D; setup_test_directory();
        let mut config &#x3D; create_test_config();
        // Set very high thresholds so imbalance will be low
        config.fsdir.max_files_per_dir &#x3D; 1000;
        config.fsdir.max_dir_loc &#x3D; 100000;
        
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let result &#x3D; analyzer.analyze_directory_for_reorg(temp_dir.path()).unwrap();
        
        // Should return None due to low imbalance
        assert!(result.is_none());
    }

    #[test]
    fn test_calculate_reorganization_effort() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let partitions &#x3D; vec![
            DirectoryPartition {
                name: &amp;quot;partition1&amp;quot;.to_string(),
                files: vec![PathBuf::from(&amp;quot;file1.py&amp;quot;), PathBuf::from(&amp;quot;file2.py&amp;quot;)],
                loc: 200,
            },
            DirectoryPartition {
                name: &amp;quot;partition2&amp;quot;.to_string(),
                files: vec![PathBuf::from(&amp;quot;file3.py&amp;quot;)],
                loc: 100,
            },
        ];
        
        let effort &#x3D; analyzer.calculate_reorganization_effort(&amp;amp;partitions, Path::new(&amp;quot;.&amp;quot;)).unwrap();
        
        assert_eq!(effort.files_moved, 3);
        assert_eq!(effort.import_updates_est, 6); // 2 * files_moved
    }

    #[test]
    fn test_generate_file_moves() {
        let temp_dir &#x3D; TempDir::new().unwrap();
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let partitions &#x3D; vec![
            DirectoryPartition {
                name: &amp;quot;core&amp;quot;.to_string(),
                files: vec![temp_dir.path().join(&amp;quot;file1.py&amp;quot;), temp_dir.path().join(&amp;quot;file2.py&amp;quot;)],
                loc: 200,
            },
        ];
        
        let moves &#x3D; analyzer.generate_file_moves(&amp;amp;partitions, temp_dir.path()).unwrap();
        
        assert_eq!(moves.len(), 2);
        assert!(moves[0].to.starts_with(temp_dir.path().join(&amp;quot;core&amp;quot;)));
        assert!(moves[1].to.starts_with(temp_dir.path().join(&amp;quot;core&amp;quot;)));
    }

    #[test]
    fn test_resolve_import_to_local_file() {
        let temp_dir &#x3D; TempDir::new().unwrap();
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        // Create a test file
        fs::write(temp_dir.path().join(&amp;quot;utils.py&amp;quot;), &amp;quot;# Utils module&amp;quot;).unwrap();
        
        let import &#x3D; ImportStatement {
            module: &amp;quot;utils&amp;quot;.to_string(),
            imports: None,
            import_type: &amp;quot;module&amp;quot;.to_string(),
            line_number: 1,
        };
        
        let resolved &#x3D; analyzer.resolve_import_to_local_file(&amp;amp;import, temp_dir.path());
        
        assert!(resolved.is_some());
        assert_eq!(resolved.unwrap(), temp_dir.path().join(&amp;quot;utils.py&amp;quot;));
    }

    #[test]
    fn test_resolve_import_to_local_file_not_found() {
        let temp_dir &#x3D; TempDir::new().unwrap();
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let import &#x3D; ImportStatement {
            module: &amp;quot;nonexistent&amp;quot;.to_string(),
            imports: None,
            import_type: &amp;quot;module&amp;quot;.to_string(),
            line_number: 1,
        };
        
        let resolved &#x3D; analyzer.resolve_import_to_local_file(&amp;amp;import, temp_dir.path());
        assert!(resolved.is_none());
    }

    #[test]
    fn test_resolve_import_relative_import_skipped() {
        let temp_dir &#x3D; TempDir::new().unwrap();
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let import &#x3D; ImportStatement {
            module: &amp;quot;.relative_module&amp;quot;.to_string(),
            imports: None,
            import_type: &amp;quot;module&amp;quot;.to_string(),
            line_number: 1,
        };
        
        let resolved &#x3D; analyzer.resolve_import_to_local_file(&amp;amp;import, temp_dir.path());
        assert!(resolved.is_none()); // Relative imports are skipped
    }

    #[test]
    fn test_calculate_gini_coefficient_large_array_parallel() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        // Create array with &amp;gt;&#x3D; 32 elements to trigger parallel computation
        let values: Vec&amp;lt;usize&amp;gt; &#x3D; (1..50).collect();
        let gini &#x3D; analyzer.calculate_gini_coefficient(&amp;amp;values);
        
        assert!(gini &amp;gt;&#x3D; 0.0 &amp;amp;&amp;amp; gini &amp;lt;&#x3D; 1.0);
        assert!(gini &amp;gt; 0.1); // Should show some inequality
    }

    #[test]
    fn test_calculate_gini_coefficient_sum_zero() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let gini &#x3D; analyzer.calculate_gini_coefficient(&amp;amp;[0, 0, 0, 0]);
        assert_eq!(gini, 0.0);
    }

    #[test]
    fn test_calculate_entropy_large_array_parallel() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        // Create array with &amp;gt;&#x3D; 100 elements to trigger parallel computation
        let values: Vec&amp;lt;usize&amp;gt; &#x3D; (1..150).collect();
        let entropy &#x3D; analyzer.calculate_entropy(&amp;amp;values);
        
        assert!(entropy &amp;gt; 0.0);
    }

    #[test]
    fn test_calculate_entropy_total_zero() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let entropy &#x3D; analyzer.calculate_entropy(&amp;amp;[0, 0, 0, 0]);
        assert_eq!(entropy, 0.0);
    }

    #[test]
    fn test_analyze_directory_for_reorg_meets_conditions() {
        // Create a directory with multiple files to ensure imbalance and meet size requirements
        let temp_dir &#x3D; TempDir::new().unwrap();
        
        // Create files with extreme imbalance to ensure imbalance &amp;gt;&#x3D; 0.6
        let files &#x3D; [
            (&amp;quot;file1.py&amp;quot;, &amp;quot;# Very large file\n&amp;quot;.repeat(100)), // 100 lines
            (&amp;quot;file2.py&amp;quot;, &amp;quot;# Tiny file\npass\n&amp;quot;.to_string()), // 2 lines
            (&amp;quot;file3.py&amp;quot;, &amp;quot;# Small file\npass\n&amp;quot;.to_string()), // 2 lines
            (&amp;quot;file4.py&amp;quot;, &amp;quot;# Small file\npass\n&amp;quot;.to_string()), // 2 lines
            (&amp;quot;file5.py&amp;quot;, &amp;quot;# Small file\npass\n&amp;quot;.to_string()), // 2 lines
            (&amp;quot;file6.py&amp;quot;, &amp;quot;# Small file\npass\n&amp;quot;.to_string()), // 2 lines
        ];
        
        for (name, content) in &amp;amp;files {
            std::fs::write(temp_dir.path().join(name), content).unwrap();
        }
        
        let mut config &#x3D; create_test_config();
        // Set thresholds to ensure conditions are met
        config.fsdir.max_files_per_dir &#x3D; 4; // Less than 6 files created
        config.fsdir.max_dir_loc &#x3D; 90; // Less than total LOC (~110)
        
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let result &#x3D; analyzer.analyze_directory_for_reorg(temp_dir.path()).unwrap();
        
        // Should return Some since conditions are met (high imbalance from mixed file sizes)
        assert!(result.is_some());
        let reorg_pack &#x3D; result.unwrap();
        assert!(!reorg_pack.proposal.is_empty());
    }

    #[test]
    fn test_analyze_directory_for_reorg_small_directory_skipped() {
        let temp_dir &#x3D; TempDir::new().unwrap();
        // Create a very small directory
        fs::write(temp_dir.path().join(&amp;quot;small.py&amp;quot;), &amp;quot;# Small file\nprint(&amp;#x27;hi&amp;#x27;)&amp;quot;).unwrap();
        
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let result &#x3D; analyzer.analyze_directory_for_reorg(temp_dir.path()).unwrap();
        
        // Should return None for small directory
        assert!(result.is_none());
    }

    #[test] 
    fn test_build_dependency_graph_basic() {
        let temp_dir &#x3D; TempDir::new().unwrap();
        
        // Create files with imports
        fs::write(temp_dir.path().join(&amp;quot;main.py&amp;quot;), &amp;quot;import utils\nfrom helpers import helper&amp;quot;).unwrap();
        fs::write(temp_dir.path().join(&amp;quot;utils.py&amp;quot;), &amp;quot;def utility(): pass&amp;quot;).unwrap();
        fs::write(temp_dir.path().join(&amp;quot;helpers.py&amp;quot;), &amp;quot;def helper(): pass&amp;quot;).unwrap();
        
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let graph &#x3D; analyzer.build_dependency_graph(temp_dir.path()).unwrap();
        
        assert!(graph.node_count() &amp;gt; 0);
        assert!(graph.edge_count() &amp;gt;&#x3D; 0); // May have edges if imports are resolved
    }

    #[test]
    fn test_partition_directory_basic() {
        let temp_dir &#x3D; setup_test_directory();
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let graph &#x3D; analyzer.build_dependency_graph(temp_dir.path()).unwrap();
        let metrics &#x3D; analyzer.calculate_directory_metrics(temp_dir.path()).unwrap();
        
        let partitions &#x3D; analyzer.partition_directory(&amp;amp;graph, &amp;amp;metrics).unwrap();
        
        assert!(!partitions.is_empty());
        assert!(partitions.iter().all(|p| !p.files.is_empty()));
    }

    #[test]
    fn test_calculate_reorganization_gain() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let partitions &#x3D; vec![
            DirectoryPartition {
                name: &amp;quot;core&amp;quot;.to_string(),
                files: vec![PathBuf::from(&amp;quot;file1.py&amp;quot;), PathBuf::from(&amp;quot;file2.py&amp;quot;)],
                loc: 200,
            },
            DirectoryPartition {
                name: &amp;quot;utils&amp;quot;.to_string(), 
                files: vec![PathBuf::from(&amp;quot;file3.py&amp;quot;)],
                loc: 100,
            },
        ];
        
        let current_metrics &#x3D; DirectoryMetrics {
            files: 3,
            subdirs: 0,
            loc: 300,
            gini: 0.5,
            entropy: 1.5,
            file_pressure: 0.6,
            branch_pressure: 0.0,
            size_pressure: 0.3,
            dispersion: 0.4,
            imbalance: 0.8,
        };
        
        let gain &#x3D; analyzer.calculate_reorganization_gain(&amp;amp;current_metrics, &amp;amp;partitions, Path::new(&amp;quot;.&amp;quot;)).unwrap();
        
        assert!(gain.imbalance_delta &amp;gt;&#x3D; 0.0);
        assert!(gain.cross_edges_reduced &amp;gt;&#x3D; 0);
    }

    #[test]
    fn test_communities_to_partitions() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        // Create a simple graph
        let mut graph &#x3D; petgraph::Graph::new();
        let node1 &#x3D; graph.add_node(FileNode {
            path: PathBuf::from(&amp;quot;file1.py&amp;quot;),
            loc: 100,
            size_bytes: 1000,
        });
        let node2 &#x3D; graph.add_node(FileNode {
            path: PathBuf::from(&amp;quot;file2.py&amp;quot;), 
            loc: 150,
            size_bytes: 1500,
        });
        
        let communities &#x3D; vec![vec![node1], vec![node2]];
        
        let partitions &#x3D; analyzer.communities_to_partitions(&amp;amp;graph, communities, 2).unwrap();
        
        assert_eq!(partitions.len(), 2);
        assert_eq!(partitions[0].files.len(), 1);
        assert_eq!(partitions[1].files.len(), 1);
        assert_eq!(partitions[0].loc, 100);
        assert_eq!(partitions[1].loc, 150);
    }

    #[test]
    fn test_label_propagation_partition_empty() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let graph &#x3D; petgraph::Graph::new();
        let result &#x3D; analyzer.label_propagation_partition(&amp;amp;graph).unwrap();
        
        assert!(result.is_empty());
    }

    #[test]
    fn test_brute_force_partition() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        // Create test node indices
        let mut graph: DependencyGraph &#x3D; petgraph::Graph::new();
        let nodes: Vec&amp;lt;_&amp;gt; &#x3D; (0..4).map(|i| {
            graph.add_node(FileNode {
                path: PathBuf::from(format!(&amp;quot;file{}.py&amp;quot;, i)),
                loc: 100,
                size_bytes: 1000,
            })
        }).collect();
        
        let partitions &#x3D; analyzer.brute_force_partition(&amp;amp;nodes, &amp;amp;graph, 2).unwrap();
        
        assert_eq!(partitions.len(), 2);
        assert_eq!(partitions.iter().map(|p| p.len()).sum::&amp;lt;usize&amp;gt;(), 4);
    }

    #[test]
    fn test_find_optimal_bipartition() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        // Create a simple connected graph
        let mut graph &#x3D; petgraph::Graph::new();
        let node1 &#x3D; graph.add_node(FileNode {
            path: PathBuf::from(&amp;quot;file1.py&amp;quot;),
            loc: 100,
            size_bytes: 1000,
        });
        let node2 &#x3D; graph.add_node(FileNode {
            path: PathBuf::from(&amp;quot;file2.py&amp;quot;),
            loc: 100,
            size_bytes: 1000,
        });
        let node3 &#x3D; graph.add_node(FileNode {
            path: PathBuf::from(&amp;quot;file3.py&amp;quot;), 
            loc: 100,
            size_bytes: 1000,
        });
        
        graph.add_edge(node1, node2, DependencyEdge {
            weight: 1,
            relationship_type: &amp;quot;import&amp;quot;.to_string(),
        });
        
        let nodes &#x3D; vec![node1, node2, node3];
        let (part1, part2) &#x3D; analyzer.find_optimal_bipartition(&amp;amp;nodes, &amp;amp;graph).unwrap();
        
        assert!(!part1.is_empty());
        assert!(!part2.is_empty());
        assert_eq!(part1.len() + part2.len(), 3);
    }

    #[test]
    fn test_extract_imports_by_extension() {
        let temp_dir &#x3D; TempDir::new().unwrap();
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        // Test Python file
        let py_file &#x3D; temp_dir.path().join(&amp;quot;test.py&amp;quot;);
        fs::write(&amp;amp;py_file, &amp;quot;import os\nfrom sys import path&amp;quot;).unwrap();
        
        let imports &#x3D; analyzer.extract_imports(&amp;amp;py_file).unwrap();
        assert_eq!(imports.len(), 2);
        
        // Test JavaScript file  
        let js_file &#x3D; temp_dir.path().join(&amp;quot;test.js&amp;quot;);
        fs::write(&amp;amp;js_file, &amp;quot;import React from &amp;#x27;react&amp;#x27;;\nimport {useState} from &amp;#x27;react&amp;#x27;;&amp;quot;).unwrap();
        
        let imports &#x3D; analyzer.extract_imports(&amp;amp;js_file).unwrap();
        assert_eq!(imports.len(), 2);
        
        // Test Rust file
        let rs_file &#x3D; temp_dir.path().join(&amp;quot;test.rs&amp;quot;);
        fs::write(&amp;amp;rs_file, &amp;quot;use std::collections::HashMap;\nuse serde::Serialize;&amp;quot;).unwrap();
        
        let imports &#x3D; analyzer.extract_imports(&amp;amp;rs_file).unwrap();
        assert_eq!(imports.len(), 2);
        
        // Test unsupported extension
        let txt_file &#x3D; temp_dir.path().join(&amp;quot;test.txt&amp;quot;);
        fs::write(&amp;amp;txt_file, &amp;quot;Some text content&amp;quot;).unwrap();
        
        let imports &#x3D; analyzer.extract_imports(&amp;amp;txt_file).unwrap();
        assert!(imports.is_empty());
    }

    #[test]
    fn test_estimate_cross_edges_reduced() {
        let config &#x3D; create_test_config();
        let analyzer &#x3D; DirectoryAnalyzer::new(config);
        
        let partitions &#x3D; vec![
            DirectoryPartition {
                name: &amp;quot;core&amp;quot;.to_string(),
                files: vec![PathBuf::from(&amp;quot;main.py&amp;quot;), PathBuf::from(&amp;quot;utils.py&amp;quot;)],
                loc: 200,
            }
        ];
        
        let result &#x3D; analyzer.estimate_cross_edges_reduced(&amp;amp;partitions, Path::new(&amp;quot;.&amp;quot;)).unwrap();
        assert!(result &amp;gt;&#x3D; 0);
    }
}</pre>
                </div>
            </div>
            <div class="file-section" id="file-47">
                <div class="file-header"><i data-lucide="book-open" class="icon"></i>templates/assets/node_modules/@babel/core/README.md</div>
                <div class="file-content">
                    <pre># @babel/core

&amp;gt; Babel compiler core.

See our website [@babel/core](https://babeljs.io/docs/babel-core) for more information or the [issues](https://github.com/babel/babel/issues?utf8&#x3D;%E2%9C%93&amp;amp;q&#x3D;is%3Aissue+label%3A%22pkg%3A%20core%22+is%3Aopen) associated with this package.

## Install

Using npm:

&#x60;&#x60;&#x60;sh
npm install --save-dev @babel/core
&#x60;&#x60;&#x60;

or using yarn:

&#x60;&#x60;&#x60;sh
yarn add @babel/core --dev
&#x60;&#x60;&#x60;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-48">
                <div class="file-header"><i data-lucide="terminal" class="icon"></i>templates/assets/node_modules/playwright-core/bin/install_media_pack.ps1</div>
                <div class="file-content">
                    <pre>$osInfo &#x3D; Get-WmiObject -Class Win32_OperatingSystem
# check if running on Windows Server
if ($osInfo.ProductType -eq 3) {
  Install-WindowsFeature Server-Media-Foundation
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-49">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/point-of-sale/after/main.py</div>
                <div class="file-content">
                    <pre>from pos.customer import Customer
from pos.line_item import LineItem
from pos.order import Order
from pos.payment import StripePaymentProcessor
from pos.system import POSSystem


def main() -&amp;gt; None:
    # create the POS system and setup the payment processor
    payment_processor &#x3D; StripePaymentProcessor.create(&amp;quot;https://api.stripe.com/v2&amp;quot;)
    system &#x3D; POSSystem(payment_processor)

    # create the customer
    customer &#x3D; Customer(
        id&#x3D;12345,
        name&#x3D;&amp;quot;Arjan&amp;quot;,
        address&#x3D;&amp;quot;Sesame street 104&amp;quot;,
        postal_code&#x3D;&amp;quot;1234&amp;quot;,
        city&#x3D;&amp;quot;Amsterdam&amp;quot;,
        email&#x3D;&amp;quot;hi@arjancodes.com&amp;quot;,
    )

    # create the order
    order &#x3D; Order(customer)
    order.add_line_item(LineItem(&amp;quot;Keyboard&amp;quot;, 1, 5000))
    order.add_line_item(LineItem(&amp;quot;SSD&amp;quot;, 1, 15000))
    order.add_line_item(LineItem(&amp;quot;USB cable&amp;quot;, 2, 500))

    # register the order in the POS system
    system.register_order(order)

    # process the order
    system.process_order(order)


if __name__ &#x3D;&#x3D; &amp;quot;__main__&amp;quot;:
    main()
</pre>
                </div>
            </div>
            <div class="file-section" id="file-50">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/point-of-sale/before/main.py</div>
                <div class="file-content">
                    <pre>from pos.order import Order
from pos.system import POSSystem


def main() -&amp;gt; None:
    # create the POS system and setup the payment processor
    system &#x3D; POSSystem()
    system.setup_payment_processor(&amp;quot;https://api.stripe.com/v2&amp;quot;)

    # create the order
    order &#x3D; Order(
        12345, &amp;quot;Arjan&amp;quot;, &amp;quot;Sesame street 104&amp;quot;, &amp;quot;1234&amp;quot;, &amp;quot;Amsterdam&amp;quot;, &amp;quot;hi@arjancodes.com&amp;quot;
    )
    order.create_line_item(&amp;quot;Keyboard&amp;quot;, 1, 5000)
    order.create_line_item(&amp;quot;SSD&amp;quot;, 1, 15000)
    order.create_line_item(&amp;quot;USB cable&amp;quot;, 2, 500)

    # register and process the order
    system.register_order(order)
    system.process_order(order)


if __name__ &#x3D;&#x3D; &amp;quot;__main__&amp;quot;:
    main()
</pre>
                </div>
            </div>
            <div class="file-section" id="file-51">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/escalade/sync/index.d.mts</div>
                <div class="file-content">
                    <pre>export type Callback &#x3D; (
	directory: string,
	files: string[],
) &#x3D;&amp;gt; string | false | void;

export default function (
	directory: string,
	callback: Callback,
): string | void;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-52">
                <div class="file-header"><i data-lucide="list" class="icon"></i>templates/assets/node_modules/walker/.travis.yml</div>
                <div class="file-content">
                    <pre>language: node_js
node_js:
  - 0.6
</pre>
                </div>
            </div>
            <div class="file-section" id="file-53">
                <div class="file-header"><i data-lucide="list" class="icon"></i>templates/assets/node_modules/makeerror/.travis.yml</div>
                <div class="file-content">
                    <pre>language: node_js
node_js:
  - 0.6
</pre>
                </div>
            </div>
            <div class="file-section" id="file-54">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/y18n/index.mjs</div>
                <div class="file-content">
                    <pre>import shim from &amp;#x27;./build/lib/platform-shims/node.js&amp;#x27;
import { y18n as _y18n } from &amp;#x27;./build/lib/index.js&amp;#x27;

const y18n &#x3D; (opts) &#x3D;&amp;gt; {
  return _y18n(opts, shim)
}

export default y18n
</pre>
                </div>
            </div>
            <div class="file-section" id="file-55">
                <div class="file-header"><i data-lucide="list" class="icon"></i>templates/assets/node_modules/require-directory/.travis.yml</div>
                <div class="file-content">
                    <pre>language: node_js
node_js:
  - 0.10
</pre>
                </div>
            </div>
            <div class="file-section" id="file-56">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/cliui/index.mjs</div>
                <div class="file-content">
                    <pre>// Bootstrap cliui with CommonJS dependencies:
import { cliui } from &amp;#x27;./build/lib/index.js&amp;#x27;
import { wrap, stripAnsi } from &amp;#x27;./build/lib/string-utils.js&amp;#x27;

export default function ui (opts) {
  return cliui(opts, {
    stringWidth: (str) &#x3D;&amp;gt; {
      return [...str].length
    },
    stripAnsi,
    wrap
  })
}
</pre>
                </div>
            </div>
            <div class="file-section" id="file-57">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/yargs/index.mjs</div>
                <div class="file-content">
                    <pre>&amp;#x27;use strict&amp;#x27;;

// Bootstraps yargs for ESM:
import esmPlatformShim from &amp;#x27;./lib/platform-shims/esm.mjs&amp;#x27;;
import {YargsFactory} from &amp;#x27;./build/lib/yargs-factory.js&amp;#x27;;

const Yargs &#x3D; YargsFactory(esmPlatformShim);
export default Yargs;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-58">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/get-package-type/index.cjs</div>
                <div class="file-content">
                    <pre>&amp;#x27;use strict&amp;#x27;;

const getPackageType &#x3D; require(&amp;#x27;./async.cjs&amp;#x27;);
const getPackageTypeSync &#x3D; require(&amp;#x27;./sync.cjs&amp;#x27;);

module.exports &#x3D; filename &#x3D;&amp;gt; getPackageType(filename);
module.exports.sync &#x3D; getPackageTypeSync;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-59">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>src/detectors/structure/config.rs</div>
                <div class="file-content">
                    <pre>//! Configuration structs, data types, and core types for structure analysis

use std::collections::HashSet;
use std::path::PathBuf;
use petgraph::{Graph, Directed, Undirected};
use serde::{Deserialize, Serialize};

/// Configuration for structure analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StructureConfig {
    /// Enable branch reorganization packs
    pub enable_branch_packs: bool,
    /// Enable file split packs
    pub enable_file_split_packs: bool,
    /// Maximum number of top packs to return
    pub top_packs: usize,
    /// File system directory settings
    pub fsdir: FsDirectoryConfig,
    /// File system file settings
    pub fsfile: FsFileConfig,
    /// Graph partitioning settings
    pub partitioning: PartitioningConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StructureToggles {
    /// Enable branch reorganization packs
    pub enable_branch_packs: bool,
    /// Enable file split packs
    pub enable_file_split_packs: bool,
    /// Maximum number of top packs to return
    pub top_packs: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FsDirectoryConfig {
    /// Maximum files per directory before pressure
    pub max_files_per_dir: usize,
    /// Maximum subdirectories per directory before pressure
    pub max_subdirs_per_dir: usize,
    /// Maximum lines of code per directory before pressure
    pub max_dir_loc: usize,
    /// Minimum imbalance gain required for branch recommendation
    pub min_branch_recommendation_gain: f64,
    /// Minimum files required before considering directory split
    pub min_files_for_split: usize,
    /// Target lines of code per subdirectory when partitioning
    pub target_loc_per_subdir: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FsFileConfig {
    /// Lines of code threshold for huge files
    pub huge_loc: usize,
    /// Byte size threshold for huge files
    pub huge_bytes: usize,
    /// Minimum lines of code before considering file split
    pub min_split_loc: usize,
    /// Minimum entities per file split
    pub min_entities_per_split: usize,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PartitioningConfig {
    /// Balance tolerance for partitioning (0.25 &#x3D; ¬±25%)
    pub balance_tolerance: f64,
    /// Maximum number of clusters per partition
    pub max_clusters: usize,
    /// Minimum number of clusters per partition
    pub min_clusters: usize,
    /// Fallback names for clusters when automatic naming fails
    pub naming_fallbacks: Vec&amp;lt;String&amp;gt;,
}

impl Default for StructureConfig {
    fn default() -&amp;gt; Self {
        Self {
            enable_branch_packs: true,
            enable_file_split_packs: true,
            top_packs: 20,
            fsdir: FsDirectoryConfig {
                max_files_per_dir: 25,
                max_subdirs_per_dir: 10,
                max_dir_loc: 2000,
                min_branch_recommendation_gain: 0.15,
                min_files_for_split: 5,
                target_loc_per_subdir: 1000,
            },
            fsfile: FsFileConfig {
                huge_loc: 800,
                huge_bytes: 128_000,
                min_split_loc: 200,
                min_entities_per_split: 3,
            },
            partitioning: PartitioningConfig {
                balance_tolerance: 0.25,
                max_clusters: 4,
                min_clusters: 2,
                naming_fallbacks: vec![
                    &amp;quot;core&amp;quot;.to_string(),
                    &amp;quot;io&amp;quot;.to_string(), 
                    &amp;quot;api&amp;quot;.to_string(),
                    &amp;quot;util&amp;quot;.to_string(),
                ],
            },
        }
    }
}

/// Directory metrics for imbalance calculation
#[derive(Debug, Clone, Serialize)]
pub struct DirectoryMetrics {
    /// Number of files in directory
    pub files: usize,
    /// Number of subdirectories
    pub subdirs: usize,
    /// Total lines of code
    pub loc: usize,
    /// Gini coefficient of LOC distribution
    pub gini: f64,
    /// Entropy of LOC distribution
    pub entropy: f64,
    /// File pressure (files / max_files_per_dir)
    pub file_pressure: f64,
    /// Branch pressure (subdirs / max_subdirs_per_dir)
    pub branch_pressure: f64,
    /// Size pressure (loc / max_dir_loc)
    pub size_pressure: f64,
    /// Dispersion metric combining gini and entropy
    pub dispersion: f64,
    /// Overall imbalance score
    pub imbalance: f64,
}

/// Branch reorganization pack recommendation
#[derive(Debug, Clone, Serialize)]
pub struct BranchReorgPack {
    /// Type identifier
    pub kind: String,
    /// Directory path
    pub dir: PathBuf,
    /// Current directory state
    pub current: DirectoryMetrics,
    /// Proposed partitions
    pub proposal: Vec&amp;lt;DirectoryPartition&amp;gt;,
    /// File move operations
    pub file_moves: Vec&amp;lt;FileMove&amp;gt;,
    /// Expected gains from reorganization
    pub gain: ReorganizationGain,
    /// Estimated effort for reorganization
    pub effort: ReorganizationEffort,
    /// Rules and constraints
    pub rules: Vec&amp;lt;String&amp;gt;,
}

/// Proposed directory partition
#[derive(Debug, Clone, Serialize)]
pub struct DirectoryPartition {
    /// Suggested partition name
    pub name: String,
    /// Files to move to this partition
    pub files: Vec&amp;lt;PathBuf&amp;gt;,
    /// Total lines of code in partition
    pub loc: usize,
}

/// Expected gains from reorganization
#[derive(Debug, Clone, Serialize)]
pub struct ReorganizationGain {
    /// Change in imbalance score (positive &#x3D; improvement)
    pub imbalance_delta: f64,
    /// Number of cross-cluster edges reduced
    pub cross_edges_reduced: usize,
}

/// Effort estimation for reorganization
#[derive(Debug, Clone, Serialize)]
pub struct ReorganizationEffort {
    /// Number of files that need to be moved
    pub files_moved: usize,
    /// Estimated number of import statement updates
    pub import_updates_est: usize,
}

/// File move operation
#[derive(Debug, Clone, Serialize)]
pub struct FileMove {
    /// Source file path
    pub from: PathBuf,
    /// Destination file path
    pub to: PathBuf,
}

/// File split pack recommendation
#[derive(Debug, Clone, Serialize)]
pub struct FileSplitPack {
    /// Type identifier
    pub kind: String,
    /// File path to split
    pub file: PathBuf,
    /// Reasons for splitting
    pub reasons: Vec&amp;lt;String&amp;gt;,
    /// Suggested split files
    pub suggested_splits: Vec&amp;lt;SuggestedSplit&amp;gt;,
    /// Value metrics
    pub value: SplitValue,
    /// Effort estimation
    pub effort: SplitEffort,
}

/// Suggested file split
#[derive(Debug, Clone, Serialize)]
pub struct SuggestedSplit {
    /// Name of the split file
    pub name: String,
    /// Entities (functions, classes) to move
    pub entities: Vec&amp;lt;String&amp;gt;,
    /// Lines of code in split
    pub loc: usize,
}

/// Value metrics for file splitting
#[derive(Debug, Clone, Serialize)]
pub struct SplitValue {
    /// Overall value score
    pub score: f64,
}

/// Effort estimation for file splitting
#[derive(Debug, Clone, Serialize)]
pub struct SplitEffort {
    /// Number of exports that need updating
    pub exports: usize,
    /// Number of external importers affected
    pub external_importers: usize,
}

/// Internal dependency graph for partitioning
pub type DependencyGraph &#x3D; Graph&amp;lt;FileNode, DependencyEdge, Directed&amp;gt;;

/// File node in dependency graph
#[derive(Debug, Clone)]
pub struct FileNode {
    /// File path
    pub path: PathBuf,
    /// Lines of code
    pub loc: usize,
    /// File size in bytes
    pub size_bytes: usize,
}

/// Dependency edge in graph
#[derive(Debug, Clone)]
pub struct DependencyEdge {
    /// Weight (import count)
    pub weight: usize,
    /// Import type/relationship
    pub relationship_type: String,
}

/// Entity cohesion graph for file splitting
pub type CohesionGraph &#x3D; Graph&amp;lt;EntityNode, CohesionEdge, Undirected&amp;gt;;

/// Entity node in cohesion graph
#[derive(Debug, Clone)]
pub struct EntityNode {
    /// Entity name (function, class, etc.)
    pub name: String,
    /// Entity type (function, class, etc.)
    pub entity_type: String,
    /// Lines of code for entity
    pub loc: usize,
    /// Referenced symbols/identifiers
    pub symbols: HashSet&amp;lt;String&amp;gt;,
}

/// Cohesion edge between entities
#[derive(Debug, Clone)]
pub struct CohesionEdge {
    /// Similarity weight (0.0 to 1.0)
    pub similarity: f64,
    /// Number of shared symbols
    pub shared_symbols: usize,
}

/// Import statement for dependency analysis
#[derive(Debug, Clone)]
pub struct ImportStatement {
    /// Module being imported
    pub module: String,
    /// Specific imports (None for star imports)
    pub imports: Option&amp;lt;Vec&amp;lt;String&amp;gt;&amp;gt;,
    /// Import type (default, named, star, etc.)
    pub import_type: String,
    /// Line number in file
    pub line_number: usize,
}</pre>
                </div>
            </div>
            <div class="file-section" id="file-60">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/escalade/index.d.mts</div>
                <div class="file-content">
                    <pre>type Promisable&amp;lt;T&amp;gt; &#x3D; T | Promise&amp;lt;T&amp;gt;;

export type Callback &#x3D; (
	directory: string,
	files: string[],
) &#x3D;&amp;gt; Promisable&amp;lt;string | false | void&amp;gt;;

export default function (
	directory: string,
	callback: Callback,
): Promise&amp;lt;string | void&amp;gt;;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-61">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>templates/assets/node_modules/get-package-type/cache.cjs</div>
                <div class="file-content">
                    <pre>&amp;#x27;use strict&amp;#x27;;

module.exports &#x3D; new Map();
</pre>
                </div>
            </div>
            <div class="file-section" id="file-62">
                <div class="file-header"><i data-lucide="list" class="icon"></i>templates/assets/node_modules/concat-map/.travis.yml</div>
                <div class="file-content">
                    <pre>language: node_js
node_js:
  - 0.4
  - 0.6
</pre>
                </div>
            </div>
            <div class="file-section" id="file-63">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>src/lib.rs</div>
                <div class="file-content">
                    <pre>//! # Valknut-RS: High-Performance Code Analysis Engine
//!
//! A Rust implementation of the valknut code analysis platform, designed for superior
//! performance and memory safety. This library provides comprehensive code analysis
//! capabilities including:
//!
//! - **Statistical Analysis**: Bayesian normalization and feature scoring
//! - **Graph Analysis**: Dependency graphs, centrality metrics, and cycle detection  
//! - **Similarity Detection**: LSH-based duplicate detection and MinHash signatures
//! - **Refactoring Analysis**: Code smell detection and refactoring opportunities
//! - **Multi-language Support**: Python, JavaScript, TypeScript, Rust, Go
//!
//! ## Performance Features
//!
//! - Zero-cost abstractions with compile-time optimizations
//! - SIMD-accelerated mathematical computations  
//! - Lock-free concurrent data structures
//! - Memory-efficient probabilistic algorithms
//! - Async-first design for I/O operations
//!
//! ## Architecture
//!
//! &#x60;&#x60;&#x60;text
//! ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
//! ‚îÇ                        API Layer                            ‚îÇ
//! ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
//! ‚îÇ  Core Engine  ‚îÇ  Detectors  ‚îÇ  Language  ‚îÇ  I/O &amp;amp; Storage  ‚îÇ
//! ‚îÇ              ‚îÇ             ‚îÇ  Adapters  ‚îÇ                 ‚îÇ
//! ‚îÇ ‚Ä¢ Scoring    ‚îÇ ‚Ä¢ Graph     ‚îÇ ‚Ä¢ Python   ‚îÇ ‚Ä¢ Cache         ‚îÇ
//! ‚îÇ ‚Ä¢ Bayesian   ‚îÇ ‚Ä¢ LSH/Hash  ‚îÇ ‚Ä¢ JS/TS    ‚îÇ ‚Ä¢ Persistence   ‚îÇ
//! ‚îÇ ‚Ä¢ Pipeline   ‚îÇ ‚Ä¢ Structure ‚îÇ ‚Ä¢ Rust     ‚îÇ ‚Ä¢ Reports       ‚îÇ
//! ‚îÇ ‚Ä¢ Config     ‚îÇ ‚Ä¢ Coverage  ‚îÇ ‚Ä¢ Go       ‚îÇ                 ‚îÇ
//! ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
//! &#x60;&#x60;&#x60;
//!
//! ## Quick Start
//!
//! &#x60;&#x60;&#x60;rust,no_run
//! use valknut_rs::{ValknutEngine, AnalysisConfig};
//!
//! #[tokio::main]
//! async fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn std::error::Error&amp;gt;&amp;gt; {
//!     let config &#x3D; AnalysisConfig::default()
//!         .with_language(&amp;quot;python&amp;quot;)
//!         .with_scoring_enabled()
//!         .with_graph_analysis();
//!
//!     let mut engine &#x3D; ValknutEngine::new(config).await?;
//!     let results &#x3D; engine.analyze_directory(&amp;quot;./src&amp;quot;).await?;
//!     
//!     println!(&amp;quot;Analysis completed: {} files processed&amp;quot;, results.files_analyzed());
//!     Ok(())
//! }
//! &#x60;&#x60;&#x60;

#![warn(missing_docs)]
#![warn(unsafe_code)]
#![warn(clippy::all, clippy::pedantic)]
#![allow(clippy::module_name_repetitions)]
#![cfg_attr(docsrs, feature(doc_cfg))]

// Memory allocator selection
#[cfg(feature &#x3D; &amp;quot;mimalloc&amp;quot;)]
#[global_allocator]
static ALLOC: mimalloc::MiMalloc &#x3D; mimalloc::MiMalloc;

#[cfg(feature &#x3D; &amp;quot;jemalloc&amp;quot;)]
#[global_allocator]
static ALLOC: jemallocator::Jemalloc &#x3D; jemallocator::Jemalloc;

// Core analysis engine modules
pub mod core {
    //! Core analysis algorithms and data structures.
    
    pub mod config;
    pub mod pipeline;
    pub mod scoring;
    pub mod bayesian;
    pub mod featureset;
    pub mod errors;
    pub mod file_utils;
}

// Specialized detection algorithms
pub mod detectors {
    //! Specialized code analysis detectors.
    
    pub mod complexity;
    pub mod graph;
    pub mod lsh;
    pub mod structure;
    pub mod coverage;
    pub mod refactoring;
    pub mod names_simple;
    pub mod clone_detection;
}

// Language-specific AST adapters
pub mod lang {
    //! Language-specific parsing and AST processing.
    
    pub mod common;
    // Tree-sitter adapters
    pub mod python;
    pub mod javascript;
    pub mod typescript;
    pub mod rust_lang;
    pub mod go;
}

// I/O, persistence, and reporting
pub mod io {
    //! I/O operations, caching, and result persistence.
    
    pub mod cache;
    pub mod persistence;
    pub mod reports;
}

// AI refactoring oracle
pub mod oracle;

// Live reachability analysis
pub mod live {
    //! Live reachability analysis for production call graphs.
    
    pub mod types;
    pub mod collectors;
    pub mod storage;
    pub mod graph;
    pub mod community;
    pub mod scoring;
    pub mod reports;
    pub mod cli;
}

// Public API and engine interface
pub mod api {
    //! High-level API and engine interface.
    
    pub mod engine;
    pub mod config_types;
    pub mod results;
}

// Re-export primary types for convenience
pub use api::engine::ValknutEngine;
pub use api::config_types::AnalysisConfig;
pub use api::results::AnalysisResults;
pub use core::errors::{ValknutError, Result};

#[cfg(test)]
mod test_coverage_integration;

// Feature-gated exports
#[cfg(feature &#x3D; &amp;quot;database&amp;quot;)]
pub mod database {
    //! Database integration for large-scale analysis.
    pub use crate::io::persistence::DatabaseBackend;
}

/// Library version information
pub const VERSION: &amp;amp;str &#x3D; env!(&amp;quot;CARGO_PKG_VERSION&amp;quot;);

/// Build-time feature detection
pub mod features {
    //! Runtime feature detection.
    
    /// Check if SIMD acceleration is available
    pub const fn has_simd() -&amp;gt; bool {
        cfg!(feature &#x3D; &amp;quot;simd&amp;quot;)
    }
    
    /// Check if parallel processing is enabled
    pub const fn has_parallel() -&amp;gt; bool {
        cfg!(feature &#x3D; &amp;quot;parallel&amp;quot;)
    }
    
    /// Check if database integration is available
    pub const fn has_database() -&amp;gt; bool {
        cfg!(feature &#x3D; &amp;quot;database&amp;quot;)
    }
}</pre>
                </div>
            </div>
            <div class="file-section" id="file-64">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/memoize-one/src/memoize-one.js.flow</div>
                <div class="file-content">
                    <pre>// @flow
export type EqualityFn &#x3D; (newArgs: mixed[], lastArgs: mixed[]) &#x3D;&amp;gt; boolean;

// default export
declare export default function memoizeOne&amp;lt;ResultFn: (...any[]) &#x3D;&amp;gt; mixed&amp;gt;(
  fn: ResultFn,
  isEqual?: EqualityFn,
): ResultFn;
</pre>
                </div>
            </div>
            <div class="file-section" id="file-65">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/get-caller-file/index.js.map</div>
                <div class="file-content">
                    <pre>{&amp;quot;version&amp;quot;:3,&amp;quot;file&amp;quot;:&amp;quot;index.js&amp;quot;,&amp;quot;sourceRoot&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;sources&amp;quot;:[&amp;quot;index.ts&amp;quot;],&amp;quot;names&amp;quot;:[],&amp;quot;mappings&amp;quot;:&amp;quot;;AAAA,qEAAqE;AACrE,qEAAqE;AACrE,EAAE;AACF,0DAA0D;AAE1D,iBAAS,SAAS,aAAa,CAAC,QAAY;IAAZ,yBAAA,EAAA,YAAY;IAC1C,IAAI,QAAQ,IAAI,KAAK,CAAC,eAAe,EAAE;QACrC,MAAM,IAAI,SAAS,CAAC,kGAAkG,GAAG,QAAQ,GAAG,oCAAoC,GAAG,KAAK,CAAC,eAAe,GAAG,GAAG,CAAC,CAAC;KACzM;IAED,IAAM,oBAAoB,GAAG,KAAK,CAAC,iBAAiB,CAAC;IACrD,KAAK,CAAC,iBAAiB,GAAG,UAAC,CAAC,EAAE,KAAK,IAAM,OAAA,KAAK,EAAL,CAAK,CAAC;IAC/C,IAAM,KAAK,GAAG,IAAI,KAAK,EAAE,CAAC,KAAK,CAAC;IAChC,KAAK,CAAC,iBAAiB,GAAG,oBAAoB,CAAC;IAG/C,IAAI,KAAK,KAAK,IAAI,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE;QAC/C,2BAA2B;QAC3B,gDAAgD;QAChD,8CAA8C;QAC9C,OAAO,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAE,KAAK,CAAC,QAAQ,CAAS,CAAC,WAAW,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC;KAC7E;AACH,CAAC,CAAC&amp;quot;}</pre>
                </div>
            </div>
            <div class="file-section" id="file-66">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/fastest-levenshtein/esm/mod.d.ts.map</div>
                <div class="file-content">
                    <pre>{&amp;quot;version&amp;quot;:3,&amp;quot;file&amp;quot;:&amp;quot;mod.d.ts&amp;quot;,&amp;quot;sourceRoot&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;sources&amp;quot;:[&amp;quot;../mod.ts&amp;quot;],&amp;quot;names&amp;quot;:[],&amp;quot;mappings&amp;quot;:&amp;quot;AAiHA,QAAA,MAAM,QAAQ,MAAO,MAAM,KAAK,MAAM,KAAG,MAaxC,CAAC;AAEF,QAAA,MAAM,OAAO,QAAS,MAAM,OAAO,SAAS,MAAM,EAAE,KAAG,MAWtD,CAAC;AAEF,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,CAAC&amp;quot;}</pre>
                </div>
            </div>
            <div class="file-section" id="file-67">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/command-line-shell/before/src/UtilPackage/TestingDir/UTestEncoding.py</div>
                <div class="file-content">
                    <pre>import ..Algorithms







</pre>
                </div>
            </div>
            <div class="file-section" id="file-68">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/@jridgewell/trace-mapping/types/strip-filename.d.cts.map</div>
                <div class="file-content">
                    <pre>{&amp;quot;version&amp;quot;:3,&amp;quot;file&amp;quot;:&amp;quot;strip-filename.d.ts&amp;quot;,&amp;quot;sourceRoot&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;sources&amp;quot;:[&amp;quot;../src/strip-filename.ts&amp;quot;],&amp;quot;names&amp;quot;:[],&amp;quot;mappings&amp;quot;:&amp;quot;AAAA;;GAEG;AACH,MAAM,CAAC,OAAO,UAAU,aAAa,CAAC,IAAI,EAAE,MAAM,GAAG,SAAS,GAAG,IAAI,GAAG,MAAM,CAI7E&amp;quot;}</pre>
                </div>
            </div>
            <div class="file-section" id="file-69">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/command-line-shell/after/src/shell/__init__.py</div>
                <div class="file-content">
                    <pre>
</pre>
                </div>
            </div>
            <div class="file-section" id="file-70">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/node_modules/resolve/test/resolver/mug.coffee</div>
                <div class="file-content">
                    <pre></pre>
                </div>
            </div>
            <div class="file-section" id="file-71">
                <div class="file-header"><i data-lucide="file" class="icon"></i>templates/assets/test-results/.playwright-artifacts-1/f68b0a029edec8b1ad5d972accf3be0f.webm</div>
                <div class="file-content">
                    <pre></pre>
                </div>
            </div>
            <div class="file-section" id="file-72">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/point-of-sale/after/pos/__init__.py</div>
                <div class="file-content">
                    <pre>
</pre>
                </div>
            </div>
            <div class="file-section" id="file-73">
                <div class="file-header"><i data-lucide="file-code" class="icon"></i>datasets/code-smells-python/point-of-sale/before/pos/__init__.py</div>
                <div class="file-content">
                    <pre>
</pre>
                </div>
            </div>
        </div>
    </div>
    <script type="text/babel">
        const { useState, useCallback, useEffect } = React;
        const { Tree } = ReactArborist;

        // File data from Handlebars template
        const fileData = [
            {
                path: "templates/assets/node_modules/resolve/test/resolver/cup.coffee",
                icon: "file",
                index: 0,
                size: "1 B",
                tokens: "0",
                score: "2.48"
            },
            {
                path: "templates/assets/node_modules/resolve/test/resolver/same_names/foo/index.js",
                icon: "file-code",
                index: 1,
                size: "20 B",
                tokens: "4",
                score: "2.43"
            },
            {
                path: "templates/assets/node_modules/resolve/test/resolver/dot_main/index.js",
                icon: "file-code",
                index: 2,
                size: "20 B",
                tokens: "4",
                score: "2.43"
            },
            {
                path: "templates/assets/node_modules/resolve/test/resolver/dot_slash_main/index.js",
                icon: "file-code",
                index: 3,
                size: "20 B",
                tokens: "4",
                score: "2.43"
            },
            {
                path: "templates/assets/node_modules/resolve/test/resolver/quux/foo/index.js",
                icon: "file-code",
                index: 4,
                size: "20 B",
                tokens: "4",
                score: "2.43"
            },
            {
                path: "templates/assets/node_modules/delayed-stream/.npmignore",
                icon: "file",
                index: 5,
                size: "5 B",
                tokens: "1",
                score: "2.39"
            },
            {
                path: "templates/assets/node_modules/require-directory/.npmignore",
                icon: "file",
                index: 6,
                size: "8 B",
                tokens: "1",
                score: "2.39"
            },
            {
                path: "templates/assets/node_modules/randombytes/.zuul.yml",
                icon: "list",
                index: 7,
                size: "9 B",
                tokens: "2",
                score: "2.39"
            },
            {
                path: "templates/assets/node_modules/call-bind/.eslintignore",
                icon: "file",
                index: 8,
                size: "10 B",
                tokens: "1",
                score: "2.39"
            },
            {
                path: "templates/assets/node_modules/resolve/test/node_path/x/aaa/index.js",
                icon: "file-code",
                index: 9,
                size: "22 B",
                tokens: "4",
                score: "2.35"
            },
            {
                path: "templates/assets/node_modules/resolve/test/node_path/x/ccc/index.js",
                icon: "file-code",
                index: 10,
                size: "22 B",
                tokens: "4",
                score: "2.35"
            },
            {
                path: "templates/assets/node_modules/resolve/test/node_path/y/bbb/index.js",
                icon: "file-code",
                index: 11,
                size: "22 B",
                tokens: "4",
                score: "2.35"
            },
            {
                path: "templates/assets/node_modules/resolve/test/node_path/y/ccc/index.js",
                icon: "file-code",
                index: 12,
                size: "23 B",
                tokens: "4",
                score: "2.32"
            },
            {
                path: "templates/assets/node_modules/resolve/test/precedence/aaa/index.js",
                icon: "file-code",
                index: 13,
                size: "25 B",
                tokens: "4",
                score: "2.25"
            },
            {
                path: "templates/assets/node_modules/resolve/test/precedence/aaa/main.js",
                icon: "file-code",
                index: 14,
                size: "28 B",
                tokens: "1",
                score: "2.21"
            },
            {
                path: "templates/assets/node_modules/is-map/.gitattributes",
                icon: "git-branch",
                index: 15,
                size: "12 B",
                tokens: "2",
                score: "2.19"
            },
            {
                path: "templates/assets/node_modules/is-set/.gitattributes",
                icon: "git-branch",
                index: 16,
                size: "12 B",
                tokens: "2",
                score: "2.19"
            },
            {
                path: "templates/assets/node_modules/is-weakset/.gitattributes",
                icon: "git-branch",
                index: 17,
                size: "12 B",
                tokens: "2",
                score: "2.19"
            },
            {
                path: "templates/assets/node_modules/resolve/test/dotdot/index.js",
                icon: "file-code",
                index: 18,
                size: "29 B",
                tokens: "4",
                score: "2.15"
            },
            {
                path: "templates/assets/node_modules/@sinclair/typebox/errors/index.d.ts",
                icon: "file-code",
                index: 19,
                size: "26 B",
                tokens: "5",
                score: "2.09"
            },
            {
                path: "templates/assets/node_modules/@sinclair/typebox/system/index.d.ts",
                icon: "file-code",
                index: 20,
                size: "26 B",
                tokens: "5",
                score: "2.09"
            },
            {
                path: "templates/assets/node_modules/@babel/core/src/config/files/index.ts",
                icon: "file-code",
                index: 21,
                size: "747 B",
                tokens: "114",
                score: "2.09"
            },
            {
                path: "templates/assets/node_modules/@jest/core/node_modules/react-is/index.js",
                icon: "file-code",
                index: 22,
                size: "196 B",
                tokens: "22",
                score: "2.06"
            },
            {
                path: "templates/assets/node_modules/sprintf-js/.npmignore",
                icon: "file",
                index: 23,
                size: "14 B",
                tokens: "1",
                score: "2.02"
            },
            {
                path: "templates/assets/node_modules/@webassemblyjs/utf8/src/index.js",
                icon: "file-code",
                index: 24,
                size: "82 B",
                tokens: "18",
                score: "2.02"
            },
            {
                path: "templates/assets/node_modules/@babel/core/src/config/files/index-browser.ts",
                icon: "file-code",
                index: 25,
                size: "2.9 KB",
                tokens: "412",
                score: "1.98"
            },
            {
                path: "templates/assets/node_modules/@testing-library/jest-dom/types/index.d.ts",
                icon: "file-code",
                index: 26,
                size: "35 B",
                tokens: "5",
                score: "1.98"
            },
            {
                path: "templates/assets/node_modules/@testing-library/react/types/pure.d.ts",
                icon: "file-code",
                index: 27,
                size: "19 B",
                tokens: "5",
                score: "1.83"
            },
            {
                path: "node_modules/tldts-core/src/domain.ts",
                icon: "file-code",
                index: 28,
                size: "3.1 KB",
                tokens: "625",
                score: "1.83"
            },
            {
                path: "templates/assets/node_modules/@react-dnd/asap/src/index.ts",
                icon: "file-code",
                index: 29,
                size: "117 B",
                tokens: "21",
                score: "1.82"
            },
            {
                path: "templates/assets/node_modules/acorn-import-phases/src/index.cjs",
                icon: "file-code",
                index: 30,
                size: "182 B",
                tokens: "29",
                score: "1.80"
            },
            {
                path: "templates/assets/node_modules/math-intrinsics/abs.d.ts",
                icon: "file-code",
                index: 31,
                size: "18 B",
                tokens: "4",
                score: "1.79"
            },
            {
                path: "templates/assets/node_modules/math-intrinsics/max.d.ts",
                icon: "file-code",
                index: 32,
                size: "18 B",
                tokens: "4",
                score: "1.79"
            },
            {
                path: "templates/assets/node_modules/playwright-core/index.mjs",
                icon: "file-code",
                index: 33,
                size: "1.0 KB",
                tokens: "198",
                score: "1.77"
            },
            {
                path: "datasets/code-smells-python/command-line-shell/before/src/main.py",
                icon: "file-code",
                index: 34,
                size: "3.8 KB",
                tokens: "580",
                score: "1.76"
            },
            {
                path: "datasets/code-smells-python/command-line-shell/after/src/main.py",
                icon: "file-code",
                index: 35,
                size: "2.5 KB",
                tokens: "333",
                score: "1.75"
            },
            {
                path: "templates/assets/node_modules/acorn-import-phases/src/index.d.mts",
                icon: "file",
                index: 36,
                size: "203 B",
                tokens: "33",
                score: "1.74"
            },
            {
                path: "templates/assets/node_modules/playwright-core/README.md",
                icon: "book-open",
                index: 37,
                size: "120 B",
                tokens: "13",
                score: "1.73"
            },
            {
                path: "templates/assets/node_modules/acorn-import-phases/src/index.d.cts",
                icon: "file",
                index: 38,
                size: "223 B",
                tokens: "36",
                score: "1.73"
            },
            {
                path: "src/core/pipeline/mod.rs",
                icon: "file-code",
                index: 39,
                size: "6.1 KB",
                tokens: "501",
                score: "1.69"
            },
            {
                path: "templates/assets/node_modules/@jest/core/README.md",
                icon: "book-open",
                index: 40,
                size: "163 B",
                tokens: "33",
                score: "1.61"
            },
            {
                path: "node_modules/playwright-core/index.mjs",
                icon: "file-code",
                index: 41,
                size: "1.0 KB",
                tokens: "198",
                score: "1.49"
            },
            {
                path: "src/core/config.rs",
                icon: "file-code",
                index: 42,
                size: "44.9 KB",
                tokens: "5,469",
                score: "1.45"
            },
            {
                path: "src/core/pipeline/pipeline_config.rs",
                icon: "file-code",
                index: 43,
                size: "6.7 KB",
                tokens: "741",
                score: "1.43"
            },
            {
                path: "templates/assets/node_modules/@types/yargs/helpers.d.mts",
                icon: "file",
                index: 44,
                size: "30 B",
                tokens: "5",
                score: "1.38"
            },
            {
                path: "src/detectors/structure/directory.rs",
                icon: "file-code",
                index: 45,
                size: "71.2 KB",
                tokens: "7,745",
                score: "1.38"
            },
            {
                path: "templates/assets/node_modules/@babel/core/README.md",
                icon: "book-open",
                index: 46,
                size: "401 B",
                tokens: "52",
                score: "1.37"
            },
            {
                path: "templates/assets/node_modules/playwright-core/bin/install_media_pack.ps1",
                icon: "terminal",
                index: 47,
                size: "174 B",
                tokens: "26",
                score: "1.33"
            },
            {
                path: "datasets/code-smells-python/point-of-sale/after/main.py",
                icon: "file-code",
                index: 48,
                size: "995 B",
                tokens: "122",
                score: "1.32"
            },
            {
                path: "datasets/code-smells-python/point-of-sale/before/main.py",
                icon: "file-code",
                index: 49,
                size: "650 B",
                tokens: "86",
                score: "1.32"
            },
            {
                path: "templates/assets/node_modules/escalade/sync/index.d.mts",
                icon: "file",
                index: 50,
                size: "177 B",
                tokens: "37",
                score: "1.30"
            },
            {
                path: "templates/assets/node_modules/walker/.travis.yml",
                icon: "list",
                index: 51,
                size: "35 B",
                tokens: "6",
                score: "1.30"
            },
            {
                path: "templates/assets/node_modules/makeerror/.travis.yml",
                icon: "list",
                index: 52,
                size: "35 B",
                tokens: "6",
                score: "1.30"
            },
            {
                path: "templates/assets/node_modules/y18n/index.mjs",
                icon: "file-code",
                index: 53,
                size: "183 B",
                tokens: "33",
                score: "1.29"
            },
            {
                path: "templates/assets/node_modules/require-directory/.travis.yml",
                icon: "list",
                index: 54,
                size: "36 B",
                tokens: "6",
                score: "1.28"
            },
            {
                path: "templates/assets/node_modules/cliui/index.mjs",
                icon: "file-code",
                index: 55,
                size: "309 B",
                tokens: "52",
                score: "1.28"
            },
            {
                path: "templates/assets/node_modules/yargs/index.mjs",
                icon: "file-code",
                index: 56,
                size: "231 B",
                tokens: "29",
                score: "1.27"
            },
            {
                path: "templates/assets/node_modules/get-package-type/index.cjs",
                icon: "file-code",
                index: 57,
                size: "210 B",
                tokens: "24",
                score: "1.25"
            },
            {
                path: "src/detectors/structure/config.rs",
                icon: "file-code",
                index: 58,
                size: "8.6 KB",
                tokens: "1,361",
                score: "1.25"
            },
            {
                path: "templates/assets/node_modules/escalade/index.d.mts",
                icon: "file",
                index: 59,
                size: "236 B",
                tokens: "45",
                score: "1.23"
            },
            {
                path: "templates/assets/node_modules/get-package-type/cache.cjs",
                icon: "file-code",
                index: 60,
                size: "43 B",
                tokens: "8",
                score: "1.22"
            },
            {
                path: "templates/assets/node_modules/concat-map/.travis.yml",
                icon: "list",
                index: 61,
                size: "43 B",
                tokens: "9",
                score: "1.18"
            },
            {
                path: "src/lib.rs",
                icon: "file-code",
                index: 62,
                size: "5.5 KB",
                tokens: "848",
                score: "1.18"
            },
            {
                path: "templates/assets/node_modules/memoize-one/src/memoize-one.js.flow",
                icon: "file",
                index: 63,
                size: "231 B",
                tokens: "38",
                score: "1.14"
            },
            {
                path: "templates/assets/node_modules/get-caller-file/index.js.map",
                icon: "file",
                index: 64,
                size: "773 B",
                tokens: "1",
                score: "0.88"
            },
            {
                path: "templates/assets/node_modules/fastest-levenshtein/esm/mod.d.ts.map",
                icon: "file",
                index: 65,
                size: "258 B",
                tokens: "1",
                score: "0.57"
            },
            {
                path: "datasets/code-smells-python/command-line-shell/before/src/UtilPackage/TestingDir/UTestEncoding.py",
                icon: "file-code",
                index: 66,
                size: "27 B",
                tokens: "2",
                score: "0.54"
            },
            {
                path: "templates/assets/node_modules/@jridgewell/trace-mapping/types/strip-filename.d.cts.map",
                icon: "file",
                index: 67,
                size: "218 B",
                tokens: "1",
                score: "0.52"
            },
            {
                path: "datasets/code-smells-python/command-line-shell/after/src/shell/__init__.py",
                icon: "file-code",
                index: 68,
                size: "1 B",
                tokens: "0",
                score: "0.46"
            },
            {
                path: "templates/assets/node_modules/resolve/test/resolver/mug.coffee",
                icon: "file",
                index: 69,
                size: "0 B",
                tokens: "0",
                score: "0.33"
            },
            {
                path: "templates/assets/test-results/.playwright-artifacts-1/f68b0a029edec8b1ad5d972accf3be0f.webm",
                icon: "file",
                index: 70,
                size: "0 B",
                tokens: "0",
                score: "0.33"
            },
            {
                path: "datasets/code-smells-python/point-of-sale/after/pos/__init__.py",
                icon: "file-code",
                index: 71,
                size: "1 B",
                tokens: "0",
                score: "0.01"
            },
            {
                path: "datasets/code-smells-python/point-of-sale/before/pos/__init__.py",
                icon: "file-code",
                index: 72,
                size: "1 B",
                tokens: "0",
                score: "0.01"
            }
        ];

        // Build hierarchical tree structure from flat file paths
        function buildTreeData(files) {
            const tree = {};
            
            files.forEach((file, index) => {
                const parts = file.path.split('/');
                let current = tree;
                
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    const isLast = i === parts.length - 1;
                    
                    if (!current[part]) {
                        current[part] = {
                            id: isLast ? `file-${index + 1}` : `folder-${file.path}-${i}`,
                            name: part,
                            isFolder: !isLast,
                            path: parts.slice(0, i + 1).join('/'),
                            children: isLast ? undefined : {},
                            fileData: isLast ? file : undefined
                        };
                    }
                    
                    if (!isLast) {
                        current = current[part].children;
                    }
                }
            });
            
            // Convert tree object to array format
            function convertToArray(obj) {
                return Object.values(obj).map(node => ({
                    ...node,
                    children: node.children ? convertToArray(node.children) : undefined
                }));
            }
            
            return convertToArray(tree);
        }

        // Get file icon based on extension
        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            switch (ext) {
                case 'js': case 'jsx': return 'javascript';
                case 'ts': case 'tsx': return 'typescript';
                case 'py': return 'python';
                case 'rs': return 'rust';
                case 'go': return 'golang';
                case 'java': return 'java';
                case 'cpp': case 'c': case 'h': return 'cplusplus';
                case 'css': return 'css3';
                case 'html': return 'html5';
                case 'json': return 'json';
                case 'md': return 'markdown';
                case 'yml': case 'yaml': return 'yaml';
                case 'xml': return 'xml';
                case 'sql': return 'database';
                case 'sh': case 'bash': return 'terminal';
                case 'dockerfile': return 'docker';
                case 'gitignore': return 'git-branch';
                default: return 'file-text';
            }
        }

        // Tree Node Component
        function Node({ node, style, dragHandle, tree }) {
            const isFolder = node.data.isFolder;
            const isOpen = tree.isOpen(node.id);
            
            const handleClick = useCallback(() => {
                if (isFolder) {
                    tree.toggle(node.id);
                } else {
                    // Navigate to file section
                    const element = document.getElementById(node.data.id);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }
            }, [node.id, isFolder, tree]);

            return (
                <div 
                    ref={dragHandle} 
                    style={style} 
                    className="tree-node"
                    onClick={handleClick}
                >
                    <div className="tree-node-content">
                        {isFolder && (
                            <div className={`tree-arrow ${isOpen ? 'expanded' : ''}`}>
                                <i data-lucide="chevron-right" className="tree-icon"></i>
                            </div>
                        )}
                        {!isFolder && <div className="tree-arrow"></div>}
                        
                        <i 
                            data-lucide={isFolder ? 'folder' : getFileIcon(node.data.name)} 
                            className={`tree-icon ${isFolder ? 'folder-icon' : 'file-icon'}`}
                        ></i>
                        
                        <span className="tree-label" title={node.data.path}>
                            {node.data.name}
                        </span>
                    </div>
                </div>
            );
        }

        // File Tree Component
        function FileTree() {
            const [treeData] = useState(() => buildTreeData(fileData));
            
            useEffect(() => {
                // Re-initialize Lucide icons after React renders
                setTimeout(() => {
                    lucide.createIcons();
                }, 100);
            }, []);

            return (
                <Tree
                    data={treeData}
                    openByDefault={false}
                    width="100%"
                    height={400}
                    padding={25}
                    rowHeight={28}
                    indent={16}
                    overscanCount={8}
                >
                    {Node}
                </Tree>
            );
        }

        // Render the component
        const container = document.getElementById('file-tree-container');
        const root = ReactDOM.createRoot(container);
        root.render(<FileTree />);
    </script>
    <script>
        // Initialize Lucide icons
        lucide.createIcons();
    </script>
</body>
</html>